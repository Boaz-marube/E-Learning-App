{"instruction": "What is '1PYTHON BASICS' and how does it work in Python?", "input": "", "output": "The Python programming language has a wide range of syntactical constructions, standard library functions, and interactive development environment features. Fortunately, you can ignore most of that; you just need to learn enough to write some handy little programs.\n\nYou will, however, have to learn some basic programming concepts before you can do anything. Like a wizard in training, you might think these concepts seem arcane and tedious, but with some knowledge and practice, you\u2019ll be able to command your computer like a magic wand and perform incredible feats.\n\nThis chapter has a few examples that encourage you to type into the interactive shell , also called the REPL (Read-Evaluate-Print Loop), which lets you run (or execute ) Python instructions one at a time and instantly shows you the results. Using the interactive shell is great for learning what basic Python instructions do, so give it a try as you follow along. You\u2019ll remember the things you do much better than the things you only read.", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "What is 'Entering Expressions into the Interactive Shell' and how does it work in Python?", "input": "", "output": "You can run the interactive shell by launching the Mu editor, which you should have downloaded when going through the setup instructions in the Preface. On Windows, open the Start menu, type \u201cMu,\u201d and open the Mu app. On macOS, open your Applications folder and double-click Mu . Click the New button and save an empty file as blank.py . When you run this blank file by clicking the Run button or pressing F5 , it will open the interactive shell, which will open as a new pane that opens at the bottom of the Mu editor\u2019s window. You should see a >>> prompt in the interactive shell.\n\nEnter 2 + 2 at the prompt to have Python do some simple math. The Mu window should now look like this:\n\n>>> 2 + 2 4 >>>\n\nIn Python, 2 + 2 is called an expression , which is the most basic kind of programming instruction in the language. Expressions consist of values (such as 2 ) and operators (such as + ), and they can always evaluate (that is, reduce) down to a single value. That means you can use expressions anywhere in Python code that you could also use a value.\n\nIn the previous example, 2 + 2 is evaluated down to a single value, 4 . A single value with no operators is also considered an expression, though it evaluates only to itself, as shown here:\n\n>>> 2 2\n\nYou can use plenty of other operators in Python expressions, too. For example, Table 1-1 lists all the math operators in Python.\n\nTable 1-1: Math Operators from Highest to Lowest Precedence\n\nThe order of operations (also called precedence ) of Python math operators is similar to that of mathematics. The ** operator is evaluated first; the * , / , // , and % operators are evaluated next, from left to right; and the + and - operators are evaluated last (also from left to right). You can use parentheses to override the usual precedence if you need to. Whitespace in between the operators and values doesn\u2019t matter for Python (except for the indentation at the beginning of the line), but a single space is convention. Enter the following expressions into the interactive shell:\n\n>>> 2 + 3 * 6 20 >>> (2 + 3) * 6 30 >>> 48565878 * 578453 28093077826734 >>> 2 ** 8 256 >>> 23 / 7 3.2857142857142856 >>> 23 // 7 3 >>> 23 % 7 2 >>> 2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02 4 >>> (5 - 1) * ((7 + 1) / (3 - 1)) 16.0\n\nIn each case, you as the programmer must enter the expression, but Python does the hard part of evaluating it down to a single value. Python will keep evaluating parts of the expression until it becomes a single value, as shown here:\n\nThese rules for putting operators and values together to form expressions are a fundamental part of Python as a programming language, just like the grammar rules that help us communicate. Here\u2019s an example:\n\nThis is a grammatically correct English sentence.\n\nThis grammatically is sentence not English correct a.\n\nThe second line is difficult to parse because it doesn\u2019t follow the rules of English. Similarly, if you enter a bad Python instruction, Python won\u2019t be able to understand it and will display a SyntaxError error message, as shown here:\n\n>>> 5 + File \"<stdin>\", line 1 5 + ^ SyntaxError: invalid syntax >>> 42 + 5 + * 2 File \"<stdin>\", line 1 42 + 5 + * 2 ^ SyntaxError: invalid syntax\n\nYou can always test to see whether an instruction works by entering it into the interactive shell. Don\u2019t worry about breaking the computer: the worst that could happen is that Python responds with an error message. Professional software developers get error messages while writing code all the time.", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "Explain the concept of 'The Integer, Floating-Point, and String Data Types' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Remember that expressions are just values combined with operators, and they always evaluate down to a single value. A data type is a category for values, and every value belongs to exactly one data type. The most common data types in Python are listed in Table 1-2. The values -2 and 30 , for example, are said to be integer values. The integer (or int ) data type indicates values that are whole numbers. Numbers with a decimal point, such as 3.14 , are called floating-point numbers (or floats ). Note that even though the value 42 is an integer, the value 42.0 would be a floating-point number.\n\nTable 1-2: Common Data Types\n\nPython programs can also have text values called strings , or strs (pronounced \u201cstirs\u201d). Always surround your string in single quote ( ' ) characters (as in 'Hello' or 'Goodbye cruel world!' ) so Python knows where the string begins and ends. You can even have a string with no characters in it, '' , called a blank string or an empty string . Strings are explained in greater detail in Chapter 4.\n\nIf you ever see the error message SyntaxError: EOL while scanning string literal , you probably forgot the final single quote character at the end of the string, such as in this example:\n\n>>> 'Hello, world! SyntaxError: EOL while scanning string literal", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "How do I use 'String Concatenation and Replication' in Python?", "input": "", "output": "The meaning of an operator may change based on the data types of the values next to it. For example, + is the addition operator when it operates on two integers or floating-point values. However, when + is used on two string values, it joins the strings as the string concatenation operator. Enter the following into the interactive shell:\n\n>>> 'Alice' + 'Bob' 'AliceBob'\n\nThe expression evaluates down to a single, new string value that combines the text of the two strings. However, if you try to use the + operator on a string and an integer value, Python will not know how to handle this, and it will display an error message.\n\n>>> 'Alice' + 42 Traceback (most recent call last): File \"<pyshell#0>\", line 1, in <module> 'Alice' + 42 TypeError: can only concatenate str (not \"int\") to str\n\nThe error message can only concatenate str (not \"int\") to str means that Python thought you were trying to concatenate an integer to the string 'Alice' . Your code will have to explicitly convert the integer to a string because Python cannot do this automatically. (Converting data types will be explained in \u201cDissecting Your Program\u201d on page 13 when we talk about the str() , int() , and float() functions.)\n\nThe * operator multiplies two integer or floating-point values. But when the * operator is used on one string value and one integer value, it becomes the string replication operator. Enter a string multiplied by a number into the interactive shell to see this in action.\n\n>>> 'Alice' * 5 'AliceAliceAliceAliceAlice'\n\nThe expression evaluates down to a single string value that repeats the original string a number of times equal to the integer value. String replication is a useful trick, but it\u2019s not used as often as string concatenation.\n\nThe * operator can be used with only two numeric values (for multiplication), or one string value and one integer value (for string replication). Otherwise, Python will just display an error message, like the following:\n\n>>> 'Alice' * 'Bob' Traceback (most recent call last): File \"<pyshell#32>\", line 1, in <module> 'Alice' * 'Bob' TypeError: can't multiply sequence by non-int of type 'str' >>> 'Alice' * 5.0 Traceback (most recent call last): File \"<pyshell#33>\", line 1, in <module> 'Alice' * 5.0 TypeError: can't multiply sequence by non-int of type 'float'\n\nIt makes sense that Python wouldn\u2019t understand these expressions: you can\u2019t multiply two words, and it\u2019s hard to replicate an arbitrary string a fractional number of times.", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "How do I use 'Storing Values in Variables' in Python?", "input": "", "output": "A variable is like a box in the computer\u2019s memory where you can store a single value. If you want to use the result of an evaluated expression later in your program, you can save it inside a variable.\n\nYou\u2019ll store values in variables with an assignment statement . An assignment statement consists of a variable name, an equal sign (called the assignment operator ), and the value to be stored. If you enter the assignment statement spam = 42 , then a variable named spam will have the integer value 42 stored in it.\n\nThink of a variable as a labeled box that a value is placed in, as in Figure 1-1.\n\nFigure 1-1: spam = 42 is like telling the program, \u201cThe variable spam now has the integer value 42 in it.\u201d\n\nFor example, enter the following into the interactive shell:\n\n\u278a >>> spam = 40 >>> spam 40 >>> eggs = 2 \u278b >>> spam + eggs 42 >>> spam + eggs + spam 82 \u278c >>> spam = spam + 2 >>> spam 42\n\nA variable is initialized (or created) the first time a value is stored in it \u278a . After that, you can use it in expressions with other variables and values \u278b . When a variable is assigned a new value \u278c , the old value is forgotten, which is why spam evaluated to 42 instead of 40 at the end of the example. This is called overwriting the variable. Enter the following code into the interactive shell to try overwriting a string:\n\n>>> spam = 'Hello' >>> spam 'Hello' >>> spam = 'Goodbye' >>> spam 'Goodbye'\n\nJust like the box in Figure 1-2, the spam variable in this example stores 'Hello' until you replace the string with 'Goodbye' .\n\nFigure 1-2: When a new value is assigned to a variable, the old one is forgotten.\n\nA good variable name describes the data it contains. Imagine that you moved to a new house and labeled all of your moving boxes as Stuff . You\u2019d never find anything! Most of this book\u2019s examples (and Python\u2019s documentation) use generic variable names like spam , eggs , and bacon , which come from the Monty Python \u201cSpam\u201d sketch. But in your programs, a descriptive name will help make your code more readable.\n\nThough you can name your variables almost anything, Python does have some naming restrictions. Table 1-3 has examples of legal variable names. You can name a variable anything as long as it obeys the following three rules:\n\n* It can be only one word with no spaces.\n* It can use only letters, numbers, and the underscore ( _ ) character.\n* It can\u2019t begin with a number.\n\nTable 1-3: Valid and Invalid Variable Names\n\nVariable names are case-sensitive, meaning that spam , SPAM , Spam , and sPaM are four different variables. Though Spam is a valid variable you can use in a program, it is a Python convention to start your variables with a lowercase letter.\n\nThis book uses camelcase for variable names instead of underscores; that is, variables lookLikeThis instead of looking_like_this . Some experienced programmers may point out that the official Python code style, PEP 8, says that underscores should be used. I unapologetically prefer camelcase and point to the \u201cA Foolish Consistency Is the Hobgoblin of Little Minds\u201d section in PEP 8 itself:\n\nConsistency with the style guide is important. But most importantly: know when to be inconsistent\u2014sometimes the style guide just doesn\u2019t apply. When in doubt, use your best judgment.", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "Explain the concept of 'Your First Program' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "While the interactive shell is good for running Python instructions one at a time, to write entire Python programs, you\u2019ll type the instructions into the file editor. The file editor is similar to text editors such as Notepad or TextMate, but it has some features specifically for entering source code. To open a new file in Mu, click the New button on the top row.\n\nThe window that appears should contain a cursor awaiting your input, but it\u2019s different from the interactive shell, which runs Python instructions as soon as you press ENTER . The file editor lets you type in many instructions, save the file, and run the program. Here\u2019s how you can tell the difference between the two:\n\n* The interactive shell window will always be the one with the >>> prompt.\n* The file editor window will not have the >>> prompt.\n\nNow it\u2019s time to create your first program! When the file editor window opens, enter the following into it:\n\n\u278a # This program says hello and asks for my name. \u278b print('Hello, world!') print('What is your name?')\u00a0\u00a0\u00a0\u00a0# ask for their name \u278c myName = input() \u278d print('It is good to meet you, ' + myName) \u278e print('The length of your name is:') print(len(myName)) \u278f print('What is your age?')\u00a0\u00a0\u00a0\u00a0# ask for their age myAge = input() print('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nOnce you\u2019ve entered your source code, save it so that you won\u2019t have to retype it each time you start Mu. Click the Save button, enter hello.py in the File Name field, and then click Save .\n\nYou should save your programs every once in a while as you type them. That way, if the computer crashes or you accidentally exit Mu, you won\u2019t lose the code. As a shortcut, you can press CTRL -S on Windows and Linux or -S on macOS to save your file.\n\nOnce you\u2019ve saved, let\u2019s run our program. Press the F5 key. Your program should run in the interactive shell window. Remember, you have to press F5 from the file editor window, not the interactive shell window. Enter your name when your program asks for it. The program\u2019s output in the interactive shell should look something like this:\n\nPython 3.7.0b4 (v3.7.0b4:eb96c37699, May\u00a0\u00a02 2018, 19:02:22) [MSC v.1913 64 bit (AMD64)] on win32 Type \"copyright\", \"credits\" or \"license()\" for more information. >>> ================================ RESTART ================================ >>> Hello, world! What is your name? Al It is good to meet you, Al The length of your name is: 2 What is your age? 4 You will be 5 in a year. >>>\n\nWhen there are no more lines of code to execute, the Python program terminates ; that is, it stops running. (You can also say that the Python program exits .)\n\nYou can close the file editor by clicking the X at the top of the window. To reload a saved program, select File \u25b8 Open... from the menu. Do that now, and in the window that appears, choose hello.py and click the Open button. Your previously saved hello.py program should open in the file editor window.\n\nYou can view the execution of a program using the Python Tutor visualization tool at http://pythontutor.com/ . You can see the execution of this particular program at https://autbor.com/hellopy/ . Click the forward button to move through each step of the program\u2019s execution. You\u2019ll be able to see how the variables\u2019 values and the output change.", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "What is 'Dissecting Your Program' and how does it work in Python?", "input": "", "output": "With your new program open in the file editor, let\u2019s take a quick tour of the Python instructions it uses by looking at what each line of code does.\n\nThe following line is called a comment .\n\n\u278a # This program says hello and asks for my name.\n\nPython ignores comments, and you can use them to write notes or remind yourself what the code is trying to do. Any text for the rest of the line following a hash mark ( # ) is part of a comment.\n\nSometimes, programmers will put a # in front of a line of code to temporarily remove it while testing a program. This is called commenting out code, and it can be useful when you\u2019re trying to figure out why a program isn\u2019t working. You can remove the # later when you are ready to put the line back in.\n\nPython also ignores the blank line after the comment. You can add as many blank lines to your program as you want. This can make your code easier to read, like paragraphs in a book.\n\nThe print() function displays the string value inside its parentheses on the screen.\n\n\u278b print('Hello, world!') print('What is your name?') # ask for their name\n\nThe line print('Hello, world!') means \u201cPrint out the text in the string 'Hello, world!' .\u201d When Python executes this line, you say that Python is calling the print() function and the string value is being passed to the function. A value that is passed to a function call is an argument . Notice that the quotes are not printed to the screen. They just mark where the string begins and ends; they are not part of the string value.\n\nWhen you write a function name, the opening and closing parentheses at the end identify it as the name of a function. This is why in this book, you\u2019ll see print() rather than print . Chapter 3 describes functions in more detail.\n\nThe input() function waits for the user to type some text on the keyboard and press ENTER .\n\n\u278c myName = input()\n\nThis function call evaluates to a string equal to the user\u2019s text, and the line of code assigns the myName variable to this string value.\n\nYou can think of the input() function call as an expression that evaluates to whatever string the user typed in. If the user entered 'Al' , then the expression would evaluate to myName = 'Al' .\n\nIf you call input() and see an error message, like NameError: name 'Al' is not defined , the problem is that you\u2019re running the code with Python 2 instead of Python 3.\n\nThe following call to print() actually contains the expression 'It is good to meet you, ' + myName between the parentheses.\n\n\u278d print('It is good to meet you, ' + myName)\n\nRemember that expressions can always evaluate to a single value. If 'Al' is the value stored in myName on line \u278c , then this expression evaluates to 'It is good to meet you, Al' . This single string value is then passed to print() , which prints it on the screen.\n\nYou can pass the len() function a string value (or a variable containing a string), and the function evaluates to the integer value of the number of characters in that string.\n\n\u278e print('The length of your name is:') print(len(myName))\n\nEnter the following into the interactive shell to try this:\n\n>>> len('hello') 5 >>> len('My very energetic monster just scarfed nachos.') 46 >>> len('') 0\n\nJust like those examples, len(myName) evaluates to an integer. It is then passed to print() to be displayed on the screen. The print() function allows you to pass it either integer values or string values, but notice the error that shows up when you type the following into the interactive shell:\n\n>>> print('I am ' + 29 + ' years old.') Traceback (most recent call last): File \"<pyshell#6>\", line 1, in <module> print('I am ' + 29 + ' years old.') TypeError: can only concatenate str (not \"int\") to str\n\nThe print() function isn\u2019t causing that error, but rather it\u2019s the expression you tried to pass to print() . You get the same error message if you type the expression into the interactive shell on its own.\n\n>>> 'I am ' + 29 + ' years old.' Traceback (most recent call last): File \"<pyshell#7>\", line 1, in <module> 'I am ' + 29 + ' years old.' TypeError: can only concatenate str (not \"int\") to str\n\nPython gives an error because the + operator can only be used to add two integers together or concatenate two strings. You can\u2019t add an integer to a string, because this is ungrammatical in Python. You can fix this by using a string version of the integer instead, as explained in the next section.\n\nIf you want to concatenate an integer such as 29 with a string to pass to print() , you\u2019ll need to get the value '29' , which is the string form of 29 . The str() function can be passed an integer value and will evaluate to a string value version of the integer, as follows:\n\n>>> str(29) '29' >>> print('I am ' + str(29) + ' years old.') I am 29 years old.\n\nBecause str(29) evaluates to '29' , the expression 'I am ' + str(29) + ' years old.' evaluates to 'I am ' + '29' + ' years old.' , which in turn evaluates to 'I am 29 years old.' . This is the value that is passed to the print() function.\n\nThe str() , int() , and float() functions will evaluate to the string, integer, and floating-point forms of the value you pass, respectively. Try converting some values in the interactive shell with these functions and watch what happens.\n\n>>> str(0) '0' >>> str(-3.14) '-3.14' >>> int('42') 42 >>> int('-99') -99 >>> int(1.25) 1 >>> int(1.99) 1 >>> float('3.14') 3.14 >>> float(10) 10.0\n\nThe previous examples call the str() , int() , and float() functions and pass them values of the other data types to obtain a string, integer, or floating-point form of those values.\n\nThe str() function is handy when you have an integer or float that you want to concatenate to a string. The int() function is also helpful if you have a number as a string value that you want to use in some mathematics. For example, the input() function always returns a string, even if the user enters a number. Enter spam = input() into the interactive shell and enter 101 when it waits for your text.\n\n>>> spam = input() 101 >>> spam '101'\n\nThe value stored inside spam isn\u2019t the integer 101 but the string '101' . If you want to do math using the value in spam , use the int() function to get the integer form of spam and then store this as the new value in spam .\n\n>>> spam = int(spam) >>> spam 101\n\nNow you should be able to treat the spam variable as an integer instead of a string.\n\n>>> spam * 10 / 5 202.0\n\nNote that if you pass a value to int() that it cannot evaluate as an integer, Python will display an error message.\n\n>>> int('99.99') Traceback (most recent call last): File \"<pyshell#18>\", line 1, in <module> int('99.99') ValueError: invalid literal for int() with base 10: '99.99' >>> int('twelve') Traceback (most recent call last): File \"<pyshell#19>\", line 1, in <module> int('twelve') ValueError: invalid literal for int() with base 10: 'twelve'\n\nThe int() function is also useful if you need to round a floating-point number down.\n\n>>> int(7.7) 7 >>> int(7.7) + 1 8\n\nYou used the int() and str() functions in the last three lines of your program to get a value of the appropriate data type for the code.\n\n\u278f print('What is your age?') # ask for their age myAge = input() print('You will be ' + str(int(myAge) + 1) + ' in a year.')\n\nThe myAge variable contains the value returned from input() . Because the input() function always returns a string (even if the user typed in a number), you can use the int(myAge) code to return an integer value of the string in myAge . This integer value is then added to 1 in the expression int(myAge) + 1 .\n\nThe result of this addition is passed to the str() function: str(int(myAge) + 1) . The string value returned is then concatenated with the strings 'You will be ' and ' in a year.' to evaluate to one large string value. This large string is finally passed to print() to be displayed on the screen.\n\nLet\u2019s say the user enters the string '4' for myAge . The string '4' is converted to an integer, so you can add one to it. The result is 5 . The str() function converts the result back to a string, so you can concatenate it with the second string, 'in a year.' , to create the final message. These evaluation steps would look something like the following:", "source": "https://automatetheboringstuff.com/2e/chapter1/", "category": "1PYTHON BASICS"}
{"instruction": "How do I use '10ORGANIZING FILES' in Python?", "input": "", "output": "In the previous chapter, you learned how to create and write to new files in Python. Your programs can also organize preexisting files on the hard drive. Maybe you\u2019ve had the experience of going through a folder full of dozens, hundreds, or even thousands of files and copying, renaming, moving, or compressing them all by hand. Or consider tasks such as these:\n\n* Making copies of all PDF files (and only the PDF files) in every subfolder of a folder\n* Removing the leading zeros in the filenames for every file in a folder of hundreds of files named spam001.txt , spam002.txt , spam003.txt , and so on\n* Compressing the contents of several folders into one ZIP file (which could be a simple backup system)\n\nAll this boring stuff is just begging to be automated in Python. By programming your computer to do these tasks, you can transform it into a quick-working file clerk who never makes mistakes.\n\nAs you begin working with files, you may find it helpful to be able to quickly see what the extension (. txt , . pdf , . jpg , and so on) of a file is. With macOS and Linux, your file browser most likely shows extensions automatically. With Windows, file extensions may be hidden by default. To show extensions, go to Start \u25b8 Control Panel \u25b8 Appearance and Personalization \u25b8 Folder Options . On the View tab, under Advanced Settings, uncheck the Hide extensions for known file types checkbox.", "source": "https://automatetheboringstuff.com/2e/chapter10/", "category": "10ORGANIZING FILES"}
{"instruction": "Explain the concept of 'The shutil Module' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "The shutil (or shell utilities) module has functions to let you copy, move, rename, and delete files in your Python programs. To use the shutil functions, you will first need to use import shutil .\n\nThe shutil module provides functions for copying files, as well as entire folders.\n\nCalling shutil.copy( source , destination ) will copy the file at the path source to the folder at the path destination . (Both source and destination can be strings or Path objects.) If destination is a filename, it will be used as the new name of the copied file. This function returns a string or Path object of the copied file.\n\nEnter the following into the interactive shell to see how shutil.copy() works:\n\n>>> import shutil, os >>> from pathlib import Path >>> p = Path.home() \u278a >>> shutil.copy(p / 'spam.txt', p / 'some_folder') 'C:\\\\Users\\\\Al\\\\some_folder\\\\spam.txt' \u278b >>> shutil.copy(p / 'eggs.txt', p / 'some_folder/eggs2.txt') WindowsPath('C:/Users/Al/some_folder/eggs2.txt')\n\nThe first shutil.copy() call copies the file at C:\\Users\\Al\\spam.txt to the folder C:\\Users\\Al\\some_folder . The return value is the path of the newly copied file. Note that since a folder was specified as the destination \u278a , the original spam.txt filename is used for the new, copied file\u2019s filename. The second shutil.copy() call \u278b also copies the file at C:\\Users\\Al\\eggs.txt to the folder C:\\Users\\Al\\some_folder but gives the copied file the name eggs2.txt .\n\nWhile shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and file contained in it. Calling shutil.copytree( source , destination ) will copy the folder at the path source , along with all of its files and subfolders, to the folder at the path destination . The source and destination parameters are both strings. The function returns a string of the path of the copied folder.\n\nEnter the following into the interactive shell:\n\n>>> import shutil, os >>> from pathlib import Path >>> p = Path.home() >>> shutil.copytree(p / 'spam', p / 'spam_backup') WindowsPath('C:/Users/Al/spam_backup')\n\nThe shutil.copytree() call creates a new folder named spam_backup with the same content as the original spam folder. You have now safely backed up your precious, precious spam.\n\nCalling shutil.move( source , destination ) will move the file or folder at the path source to the path destination and will return a string of the absolute path of the new location.\n\nIf destination points to a folder, the source file gets moved into destination and keeps its current filename. For example, enter the following into the interactive shell:\n\n>>> import shutil >>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs') 'C:\\\\eggs\\\\bacon.txt'\n\nAssuming a folder named eggs already exists in the C:\\ directory, this shutil.move() call says, \u201cMove C:\\bacon.txt into the folder C:\\eggs .\u201d\n\nIf there had been a bacon.txt file already in C:\\eggs , it would have been overwritten. Since it\u2019s easy to accidentally overwrite files in this way, you should take some care when using move() .\n\nThe destination path can also specify a filename. In the following example, the source file is moved and renamed.\n\n>>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs\\\\new_bacon.txt') 'C:\\\\eggs\\\\new_bacon.txt'\n\nThis line says, \u201cMove C:\\bacon.txt into the folder C:\\eggs , and while you\u2019re at it, rename that bacon.txt file to new_bacon.txt .\u201d\n\nBoth of the previous examples worked under the assumption that there was a folder eggs in the C:\\ directory. But if there is no eggs folder, then move() will rename bacon.txt to a file named eggs .\n\n>>> shutil.move('C:\\\\bacon.txt', 'C:\\\\eggs') 'C:\\\\eggs'\n\nHere, move() can\u2019t find a folder named eggs in the C:\\ directory and so assumes that destination must be specifying a filename, not a folder. So the bacon.txt text file is renamed to eggs (a text file without the .txt file extension)\u2014probably not what you wanted! This can be a tough-to-spot bug in your programs since the move() call can happily do something that might be quite different from what you were expecting. This is yet another reason to be careful when using move() .\n\nFinally, the folders that make up the destination must already exist, or else Python will throw an exception. Enter the following into the interactive shell:\n\n>>> shutil.move('spam.txt', 'c:\\\\does_not_exist\\\\eggs\\\\ham') Traceback (most recent call last): -- snip -- FileNotFoundError: [Errno 2] No such file or directory: 'c:\\\\does_not_exist\\\\ eggs\\\\ham'\n\nPython looks for eggs and ham inside the directory does_not_exist . It doesn\u2019t find the nonexistent directory, so it can\u2019t move spam.txt to the path you specified.\n\nYou can delete a single file or a single empty folder with functions in the os module, whereas to delete a folder and all of its contents, you use the shutil module.\n\n* Calling os.unlink( path ) will delete the file at path .\n* Calling os.rmdir( path ) will delete the folder at path . This folder must be empty of any files or folders.\n* Calling shutil.rmtree( path ) will remove the folder at path , and all files and folders it contains will also be deleted.\n\nBe careful when using these functions in your programs! It\u2019s often a good idea to first run your program with these calls commented out and with print() calls added to show the files that would be deleted. Here is a Python program that was intended to delete files that have the .txt file extension but has a typo (highlighted in bold) that causes it to delete .rxt files instead:\n\nimport os from pathlib import Path for filename in Path.home().glob('*. r xt'): os.unlink(filename)\n\nIf you had any important files ending with .rxt , they would have been accidentally, permanently deleted. Instead, you should have first run the program like this:\n\nimport os from pathlib import Path for filename in Path.home().glob('*.rxt'): #os.unlink(filename) print(filename)\n\nNow the os.unlink() call is commented, so Python ignores it. Instead, you will print the filename of the file that would have been deleted. Running this version of the program first will show you that you\u2019ve accidentally told the program to delete .rxt files instead of .txt files.\n\nOnce you are certain the program works as intended, delete the print(filename) line and uncomment the os.unlink(filename) line. Then run the program again to actually delete the files.\n\nSince Python\u2019s built-in shutil.rmtree() function irreversibly deletes files and folders, it can be dangerous to use. A much better way to delete files and folders is with the third-party send2trash module. You can install this module by running pip install --user send2trash from a Terminal window. (See Appendix A for a more in-depth explanation of how to install third-party modules.)\n\nUsing send2trash is much safer than Python\u2019s regular delete functions, because it will send folders and files to your computer\u2019s trash or recycle bin instead of permanently deleting them. If a bug in your program deletes something with send2trash you didn\u2019t intend to delete, you can later restore it from the recycle bin.\n\nAfter you have installed send2trash , enter the following into the interactive shell:\n\n>>> import send2trash >>> baconFile = open('bacon.txt', 'a')\u00a0\u00a0\u00a0# creates the file >>> baconFile.write('Bacon is not a vegetable.') 25 >>> baconFile.close() >>> send2trash.send2trash('bacon.txt')\n\nIn general, you should always use the send2trash.send2trash() function to delete files and folders. But while sending files to the recycle bin lets you recover them later, it will not free up disk space like permanently deleting them does. If you want your program to free up disk space, use the os and shutil functions for deleting files and folders. Note that the send2trash() function can only send files to the recycle bin; it cannot pull files out of it.", "source": "https://automatetheboringstuff.com/2e/chapter10/", "category": "10ORGANIZING FILES"}
{"instruction": "How do I use 'Walking a Directory Tree' in Python?", "input": "", "output": "Say you want to rename every file in some folder and also every file in every subfolder of that folder. That is, you want to walk through the directory tree, touching each file as you go. Writing a program to do this could get tricky; fortunately, Python provides a function to handle this process for you.\n\nLet\u2019s look at the C:\\delicious folder with its contents, shown in Figure 10-1.\n\nFigure 10-1: An example folder that contains three folders and four files\n\nHere is an example program that uses the os.walk() function on the directory tree from Figure 10-1:\n\nimport os for folderName, subfolders, filenames in os.walk('C:\\\\delicious'): print('The current folder is ' + folderName) for subfolder in subfolders: print('SUBFOLDER OF ' + folderName + ': ' + subfolder) for filename in filenames: print('FILE INSIDE ' + folderName + ': '+ filename) print('')\n\nThe os.walk() function is passed a single string value: the path of a folder. You can use os.walk() in a for loop statement to walk a directory tree, much like how you can use the range() function to walk over a range of numbers. Unlike range() , the os.walk() function will return three values on each iteration through the loop:\n\n* A string of the current folder\u2019s name\n* A list of strings of the folders in the current folder\n* A list of strings of the files in the current folder\n\n(By current folder, I mean the folder for the current iteration of the for loop. The current working directory of the program is not changed by os.walk() .)\n\nJust like you can choose the variable name i in the code for i in range(10): , you can also choose the variable names for the three values listed earlier. I usually use the names foldername , subfolders , and filenames .\n\nWhen you run this program, it will output the following:\n\nThe current folder is C:\\delicious SUBFOLDER OF C:\\delicious: cats SUBFOLDER OF C:\\delicious: walnut FILE INSIDE C:\\delicious: spam.txt The current folder is C:\\delicious\\cats FILE INSIDE C:\\delicious\\cats: catnames.txt FILE INSIDE C:\\delicious\\cats: zophie.jpg The current folder is C:\\delicious\\walnut SUBFOLDER OF C:\\delicious\\walnut: waffles The current folder is C:\\delicious\\walnut\\waffles FILE INSIDE C:\\delicious\\walnut\\waffles: butter.txt.\n\nSince os.walk() returns lists of strings for the subfolder and filename variables, you can use these lists in their own for loops. Replace the print() function calls with your own custom code. (Or if you don\u2019t need one or both of them, remove the for loops.)", "source": "https://automatetheboringstuff.com/2e/chapter10/", "category": "10ORGANIZING FILES"}
{"instruction": "How do I use 'Compressing Files with the zipfile Module' in Python?", "input": "", "output": "You may be familiar with ZIP files (with the .zip file extension), which can hold the compressed contents of many other files. Compressing a file reduces its size, which is useful when transferring it over the internet. And since a ZIP file can also contain multiple files and subfolders, it\u2019s a handy way to package several files into one. This single file, called an archive file , can then be, say, attached to an email.\n\nYour Python programs can create and open (or extract ) ZIP files using functions in the zipfile module. Say you have a ZIP file named example.zip that has the contents shown in Figure 10-2.\n\nFigure 10-2: The contents of example.zip\n\nYou can download this ZIP file from https://nostarch.com/automatestuff2/ or just follow along using a ZIP file already on your computer.\n\nTo read the contents of a ZIP file, first you must create a ZipFile object (note the capital letters Z and F ). ZipFile objects are conceptually similar to the File objects you saw returned by the open() function in the previous chapter: they are values through which the program interacts with the file. To create a ZipFile object, call the zipfile.ZipFile() function, passing it a string of the .ZIP file\u2019s filename. Note that zipfile is the name of the Python module, and ZipFile() is the name of the function.\n\nFor example, enter the following into the interactive shell:\n\n>>> import zipfile, os >>> from pathlib import Path >>> p = Path.home() >>> exampleZip = zipfile.ZipFile(p / 'example.zip') >>> exampleZip.namelist() ['spam.txt', 'cats/', 'cats/catnames.txt', 'cats/zophie.jpg'] >>> spamInfo = exampleZip.getinfo('spam.txt') >>> spamInfo.file_size 13908 >>> spamInfo.compress_size 3828 \u278a >>> f'Compressed file is {round(spamInfo.file_size / spamInfo .compress_size, 2)}x smaller!' ) 'Compressed file is 3.63x smaller!' >>> exampleZip.close()\n\nA ZipFile object has a namelist() method that returns a list of strings for all the files and folders contained in the ZIP file. These strings can be passed to the getinfo() ZipFile method to return a ZipInfo object about that particular file. ZipInfo objects have their own attributes, such as file_size and compress_size in bytes, which hold integers of the original file size and compressed file size, respectively. While a ZipFile object represents an entire archive file, a ZipInfo object holds useful information about a single file in the archive.\n\nThe command at \u278a calculates how efficiently example.zip is compressed by dividing the original file size by the compressed file size and prints this information.\n\nThe extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the current working directory.\n\n>>> import zipfile, os >>> from pathlib import Path >>> p = Path.home() >>> exampleZip = zipfile.ZipFile(p / 'example.zip') \u278a >>> exampleZip.extractall() >>> exampleZip.close()\n\nAfter running this code, the contents of example.zip will be extracted to C:\\ . Optionally, you can pass a folder name to extractall() to have it extract the files into a folder other than the current working directory. If the folder passed to the extractall() method does not exist, it will be created. For instance, if you replaced the call at \u278a with exampleZip.extractall('C:\\\\delicious') , the code would extract the files from example.zip into a newly created C:\\delicious folder.\n\nThe extract() method for ZipFile objects will extract a single file from the ZIP file. Continue the interactive shell example:\n\n>>> exampleZip.extract('spam.txt') 'C:\\\\spam.txt' >>> exampleZip.extract('spam.txt', 'C:\\\\some\\\\new\\\\folders') 'C:\\\\some\\\\new\\\\folders\\\\spam.txt' >>> exampleZip.close()\n\nThe string you pass to extract() must match one of the strings in the list returned by namelist() . Optionally, you can pass a second argument to extract() to extract the file into a folder other than the current working directory. If this second argument is a folder that doesn\u2019t yet exist, Python will create the folder. The value that extract() returns is the absolute path to which the file was extracted.\n\nTo create your own compressed ZIP files, you must open the ZipFile object in write mode by passing 'w' as the second argument. (This is similar to opening a text file in write mode by passing 'w' to the open() function.)\n\nWhen you pass a path to the write() method of a ZipFile object, Python will compress the file at that path and add it into the ZIP file. The write() method\u2019s first argument is a string of the filename to add. The second argument is the compression type parameter, which tells the computer what algorithm it should use to compress the files; you can always just set this value to zipfile.ZIP_DEFLATED . (This specifies the deflate compression algorithm, which works well on all types of data.) Enter the following into the interactive shell:\n\n>>> import zipfile >>> newZip = zipfile.ZipFile('new.zip', 'w') >>> newZip.write('spam.txt', compress_type=zipfile.ZIP_DEFLATED) >>> newZip.close()\n\nThis code will create a new ZIP file named new.zip that has the compressed contents of spam.txt .\n\nKeep in mind that, just as with writing to files, write mode will erase all existing contents of a ZIP file. If you want to simply add files to an existing ZIP file, pass 'a' as the second argument to zipfile.ZipFile() to open the ZIP file in append mode .", "source": "https://automatetheboringstuff.com/2e/chapter10/", "category": "10ORGANIZING FILES"}
{"instruction": "Provide a guide on 'Project: Renaming Files with American-Style Dates to European-Style Dates' in Python.", "input": "", "output": "Say your boss emails you thousands of files with American-style dates (MM-DD-YYYY) in their names and needs them renamed to European-style dates (DD-MM-YYYY). This boring task could take all day to do by hand! Let\u2019s write a program to do it instead.\n\nHere\u2019s what the program does:\n\n1. It searches all the filenames in the current working directory for American-style dates.\n2. When one is found, it renames the file with the month and day swapped to make it European-style.\n\nThis means the code will need to do the following:\n\n1. Create a regex that can identify the text pattern of American-style dates.\n2. Call os.listdir() to find all the files in the working directory.\n3. Loop over each filename, using the regex to check whether it has a date.\n4. If it has a date, rename the file with shutil.move() .\n\nFor this project, open a new file editor window and save your code as renameDates.py .\n\nThe first part of the program will need to import the necessary modules and create a regex that can identify MM-DD-YYYY dates. The to-do comments will remind you what\u2019s left to write in this program. Typing them as TODO makes them easy to find using Mu editor\u2019s CTRL-F find feature. Make your code look like the following:\n\n#! python3 # renameDates.py - Renames filenames with American MM-DD-YYYY date format # to European DD-MM-YYYY. \u278a import shutil, os, re # Create a regex that matches files with the American date format. \u278b datePattern = re.compile(r\"\"\"^(.*?) # all text before the date ((0|1)?\\d)-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the month ((0|1|2|3)?\\d)-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the day ((19|20)\\d\\d)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# four digits for the year (.*?)$\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# all text after the date \"\"\", re.VERBOSE \u278c ) # TODO: Loop over the files in the working directory. # TODO: Skip files without a date. # TODO: Get the different parts of the filename. # TODO: Form the European-style filename. # TODO: Get the full, absolute file paths. # TODO: Rename the files.\n\nFrom this chapter, you know the shutil.move() function can be used to rename files: its arguments are the name of the file to rename and the new filename. Because this function exists in the shutil module, you must import that module \u278a .\n\nBut before renaming the files, you need to identify which files you want to rename. Filenames with dates such as spam4-4-1984.txt and 01-03-2014eggs.zip should be renamed, while filenames without dates such as littlebrother.epub can be ignored.\n\nYou can use a regular expression to identify this pattern. After importing the re module at the top, call re.compile() to create a Regex object \u278b . Passing re.VERBOSE for the second argument \u278c will allow whitespace and comments in the regex string to make it more readable.\n\nThe regular expression string begins with ^(.*?) to match any text at the beginning of the filename that might come before the date. The ((0|1)?\\d) group matches the month. The first digit can be either 0 or 1 , so the regex matches 12 for December but also 02 for February. This digit is also optional so that the month can be 04 or 4 for April. The group for the day is ((0|1|2|3)?\\d) and follows similar logic; 3 , 03 , and 31 are all valid numbers for days. (Yes, this regex will accept some invalid dates such as 4-31-2014 , 2-29-2013 , and 0-15-2014 . Dates have a lot of thorny special cases that can be easy to miss. But for simplicity, the regex in this program works well enough.)\n\nWhile 1885 is a valid year, you can just look for years in the 20th or 21st century. This will keep your program from accidentally matching nondate filenames with a date-like format, such as 10-10-1000.txt .\n\nThe (.*?)$ part of the regex will match any text that comes after the date.\n\nNext, the program will have to loop over the list of filename strings returned from os.listdir() and match them against the regex. Any files that do not have a date in them should be skipped. For filenames that have a date, the matched text will be stored in several variables. Fill in the first three TODO s in your program with the following code:\n\n#! python3 # renameDates.py - Renames filenames with American MM-DD-YYYY date format # to European DD-MM-YYYY. -- snip -- # Loop over the files in the working directory. for amerFilename in os.listdir('.'): mo = datePattern.search(amerFilename) # Skip files without a date. \u278a if mo == None: \u278b continue \u278c # Get the different parts of the filename. beforePart = mo.group(1) monthPart\u00a0\u00a0= mo.group(2) dayPart\u00a0\u00a0\u00a0\u00a0= mo.group(4) yearPart\u00a0\u00a0\u00a0= mo.group(6) afterPart\u00a0\u00a0= mo.group(8) -- snip --\n\nIf the Match object returned from the search() method is None \u278a , then the filename in amerFilename does not match the regular expression. The continue statement \u278b will skip the rest of the loop and move on to the next filename.\n\nOtherwise, the various strings matched in the regular expression groups are stored in variables named beforePart , monthPart , dayPart , yearPart , and afterPart \u278c . The strings in these variables will be used to form the European-style filename in the next step.\n\nTo keep the group numbers straight, try reading the regex from the beginning, and count up each time you encounter an opening parenthesis. Without thinking about the code, just write an outline of the regular expression. This can help you visualize the groups. Here\u2019s an example:\n\ndatePattern = re.compile(r\"\"\"^( 1 ) # all text before the date ( 2 ( 3 ) )-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the month ( 4 ( 5 ) )-\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# one or two digits for the day ( 6 ( 7 ) )\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# four digits for the year ( 8 )$\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# all text after the date \"\"\", re.VERBOSE)\n\nHere, the numbers 1 through 8 represent the groups in the regular expression you wrote. Making an outline of the regular expression, with just the parentheses and group numbers, can give you a clearer understanding of your regex before you move on with the rest of the program.\n\nAs the final step, concatenate the strings in the variables made in the previous step with the European-style date: the date comes before the month. Fill in the three remaining TODO s in your program with the following code:\n\n#! python3 # renameDates.py - Renames filenames with American MM-DD-YYYY date format # to European DD-MM-YYYY. -- snip -- # Form the European-style filename. \u278a euroFilename = beforePart + dayPart + '-' + monthPart + '-' + yearPart + afterPart # Get the full, absolute file paths. absWorkingDir = os.path.abspath('.') amerFilename = os.path.join(absWorkingDir, amerFilename) euroFilename = os.path.join(absWorkingDir, euroFilename) # Rename the files. \u278b print(f'Renaming \"{amerFilename}\" to \"{euroFilename}\"...') \u278c #shutil.move(amerFilename, euroFilename)\u00a0\u00a0\u00a0# uncomment after testing\n\nStore the concatenated string in a variable named euroFilename \u278a . Then, pass the original filename in amerFilename and the new euroFilename variable to the shutil.move() function to rename the file \u278c .\n\nThis program has the shutil.move() call commented out and instead prints the filenames that will be renamed \u278b . Running the program like this first can let you double-check that the files are renamed correctly. Then you can uncomment the shutil.move() call and run the program again to actually rename the files.\n\nThere are many other reasons you might want to rename a large number of files.\n\n* To add a prefix to the start of the filename, such as adding spam_ to rename eggs.txt to spam_eggs.txt\n* To change filenames with European-style dates to American-style dates\n* To remove the zeros from files such as spam0042.txt", "source": "https://automatetheboringstuff.com/2e/chapter10/", "category": "10ORGANIZING FILES"}
{"instruction": "Explain the concept of 'Project: Backing Up a Folder into a ZIP File' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Say you\u2019re working on a project whose files you keep in a folder named C:\\AlsPythonBook . You\u2019re worried about losing your work, so you\u2019d like to create ZIP file \u201csnapshots\u201d of the entire folder. You\u2019d like to keep different versions, so you want the ZIP file\u2019s filename to increment each time it is made; for example, AlsPythonBook_1.zip , AlsPythonBook_2.zip , AlsPythonBook_3.zip , and so on. You could do this by hand, but it is rather annoying, and you might accidentally misnumber the ZIP files\u2019 names. It would be much simpler to run a program that does this boring task for you.\n\nFor this project, open a new file editor window and save it as backupToZip.py .\n\nThe code for this program will be placed into a function named backupToZip() . This will make it easy to copy and paste the function into other Python programs that need this functionality. At the end of the program, the function will be called to perform the backup. Make your program look like this:\n\n#! python3 # backupToZip.py - Copies an entire folder and its contents into # a ZIP file whose filename increments. \u278a import zipfile, os def backupToZip(folder): # Back up the entire contents of \"folder\" into a ZIP file. folder = os.path.abspath(folder)\u00a0\u00a0\u00a0# make sure folder is absolute # Figure out the filename this code should use based on # what files already exist. \u278b number = 1 \u278c while True: zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip' if not os.path.exists(zipFilename): break number = number + 1 \u278d # TODO: Create the ZIP file. # TODO: Walk the entire folder tree and compress the files in each folder. print('Done.') backupToZip('C:\\\\delicious')\n\nDo the basics first: add the shebang ( #! ) line, describe what the program does, and import the zipfile and os modules \u278a .\n\nDefine a backupToZip() function that takes just one parameter, folder . This parameter is a string path to the folder whose contents should be backed up. The function will determine what filename to use for the ZIP file it will create; then the function will create the file, walk the folder folder, and add each of the subfolders and files to the ZIP file. Write TODO comments for these steps in the source code to remind yourself to do them later \u278d .\n\nThe first part, naming the ZIP file, uses the base name of the absolute path of folder . If the folder being backed up is C:\\delicious , the ZIP file\u2019s name should be delicious_N.zip , where N = 1 is the first time you run the program, N = 2 is the second time, and so on.\n\nYou can determine what N should be by checking whether delicious_1.zip already exists, then checking whether delicious_2.zip already exists, and so on. Use a variable named number for N \u278b , and keep incrementing it inside the loop that calls os.path.exists() to check whether the file exists \u278c . The first nonexistent filename found will cause the loop to break , since it will have found the filename of the new zip.\n\nNext let\u2019s create the ZIP file. Make your program look like the following:\n\n#! python3 # backupToZip.py - Copies an entire folder and its contents into # a ZIP file whose filename increments. -- snip -- while True: zipFilename = os.path.basename(folder) + '_' + str(number) + '.zip' if not os.path.exists(zipFilename): break number = number + 1 # Create the ZIP file. print(f'Creating {zipFilename}...') \u278a backupZip = zipfile.ZipFile(zipFilename, 'w') # TODO: Walk the entire folder tree and compress the files in each folder. print('Done.') backupToZip('C:\\\\delicious')\n\nNow that the new ZIP file\u2019s name is stored in the zipFilename variable, you can call zipfile.ZipFile() to actually create the ZIP file \u278a . Be sure to pass 'w' as the second argument so that the ZIP file is opened in write mode.\n\nNow you need to use the os.walk() function to do the work of listing every file in the folder and its subfolders. Make your program look like the following:\n\n#! python3 # backupToZip.py - Copies an entire folder and its contents into # a ZIP file whose filename increments. -- snip -- # Walk the entire folder tree and compress the files in each folder. \u278a for foldername, subfolders, filenames in os.walk(folder): print(f'Adding files in {foldername}...') # Add the current folder to the ZIP file. \u278b backupZip.write(foldername) # Add all the files in this folder to the ZIP file. \u278c for filename in filenames: newBase = os.path.basename(folder) + '_' if filename.startswith(newBase) and filename.endswith('.zip'): continue\u00a0\u00a0\u00a0# don't back up the backup ZIP files backupZip.write(os.path.join(foldername, filename)) backupZip.close() print('Done.') backupToZip('C:\\\\delicious')\n\nYou can use os.walk() in a for loop \u278a , and on each iteration it will return the iteration\u2019s current folder name, the subfolders in that folder, and the filenames in that folder.\n\nIn the for loop, the folder is added to the ZIP file \u278b . The nested for loop can go through each filename in the filenames list \u278c . Each of these is added to the ZIP file, except for previously made backup ZIPs.\n\nWhen you run this program, it will produce output that will look something like this:\n\nCreating delicious_1.zip... Adding files in C:\\delicious... Adding files in C:\\delicious\\cats... Adding files in C:\\delicious\\waffles... Adding files in C:\\delicious\\walnut... Adding files in C:\\delicious\\walnut\\waffles... Done.\n\nThe second time you run it, it will put all the files in C:\\delicious into a ZIP file named delicious_2.zip , and so on.\n\nYou can walk a directory tree and add files to compressed ZIP archives in several other programs. For example, you can write programs that do the following:\n\n* Walk a directory tree and archive just files with certain extensions, such as .txt or .py , and nothing else.\n* Walk a directory tree and archive every file except the .txt and .py ones.\n* Find the folder in a directory tree that has the greatest number of files or the folder that uses the most disk space.", "source": "https://automatetheboringstuff.com/2e/chapter10/", "category": "10ORGANIZING FILES"}
{"instruction": "Provide a guide on '11DEBUGGING' in Python.", "input": "", "output": "Now that you know enough to write more complicated programs, you may start finding not-so-simple bugs in them. This chapter covers some tools and techniques for finding the root cause of bugs in your program to help you fix bugs faster and with less effort.\n\nTo paraphrase an old joke among programmers, writing code accounts for 90 percent of programming. Debugging code accounts for the other 90 percent.\n\nYour computer will do only what you tell it to do; it won\u2019t read your mind and do what you intended it to do. Even professional programmers create bugs all the time, so don\u2019t feel discouraged if your program has a problem.\n\nFortunately, there are a few tools and techniques to identify what exactly your code is doing and where it\u2019s going wrong. First, you will look at logging and assertions, two features that can help you detect bugs early. In general, the earlier you catch bugs, the easier they will be to fix.\n\nSecond, you will look at how to use the debugger. The debugger is a feature of Mu that executes a program one instruction at a time, giving you a chance to inspect the values in variables while your code runs, and track how the values change over the course of your program. This is much slower than running the program at full speed, but it is helpful to see the actual values in a program while it runs, rather than deducing what the values might be from the source code.", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "What is 'Raising Exceptions' and how does it work in Python?", "input": "", "output": "Python raises an exception whenever it tries to execute invalid code. In Chapter 3, you read about how to handle Python\u2019s exceptions with try and except statements so that your program can recover from exceptions that you anticipated. But you can also raise your own exceptions in your code. Raising an exception is a way of saying, \u201cStop running the code in this function and move the program execution to the except statement.\u201d\n\nExceptions are raised with a raise statement. In code, a raise statement consists of the following:\n\n* The raise keyword\n* A call to the Exception() function\n* A string with a helpful error message passed to the Exception() function\n\nFor example, enter the following into the interactive shell:\n\n>>> raise Exception('This is the error message.') Traceback (most recent call last): File \"<pyshell#191>\", line 1, in <module> raise Exception('This is the error message.') Exception: This is the error message.\n\nIf there are no try and except statements covering the raise statement that raised the exception, the program simply crashes and displays the exception\u2019s error message.\n\nOften it\u2019s the code that calls the function, rather than the function itself, that knows how to handle an exception. That means you will commonly see a raise statement inside a function and the try and except statements in the code calling the function. For example, open a new file editor tab, enter the following code, and save the program as boxPrint.py :\n\ndef boxPrint(symbol, width, height): if len(symbol) != 1: \u278a raise Exception('Symbol must be a single character string.') if width <= 2: \u278b raise Exception('Width must be greater than 2.') if height <= 2: \u278c raise Exception('Height must be greater than 2.') print(symbol * width) for i in range(height - 2): print(symbol + (' ' * (width - 2)) + symbol) print(symbol * width) for sym, w, h in (('*', 4, 4), ('O', 20, 5), ('x', 1, 3), ('ZZ', 3, 3)): try: boxPrint(sym, w, h) \u278d except Exception as err: \u278e print('An exception happened: ' + str(err))\n\nYou can view the execution of this program at https://autbor.com/boxprint . Here we\u2019ve defined a boxPrint() function that takes a character, a width, and a height, and uses the character to make a little picture of a box with that width and height. This box shape is printed to the screen.\n\nSay we want the character to be a single character, and the width and height to be greater than 2. We add if statements to raise exceptions if these requirements aren\u2019t satisfied. Later, when we call boxPrint() with various arguments, our try / except will handle invalid arguments.\n\nThis program uses the except Exception as err form of the except statement \u278d . If an Exception object is returned from boxPrint() \u278a \u278b \u278c , this except statement will store it in a variable named err . We can then convert the Exception object to a string by passing it to str() to produce a user-friendly error message \u278e . When you run this boxPrint.py , the output will look like this:\n\n**** *\u00a0\u00a0* *\u00a0\u00a0* **** OOOOOOOOOOOOOOOOOOOO O\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0O O\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0O O\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0O OOOOOOOOOOOOOOOOOOOO An exception happened: Width must be greater than 2. An exception happened: Symbol must be a single character string.\n\nUsing the try and except statements, you can handle errors more gracefully instead of letting the entire program crash.", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "How do I use 'Getting the Traceback as a String' in Python?", "input": "", "output": "When Python encounters an error, it produces a treasure trove of error information called the traceback . The traceback includes the error message, the line number of the line that caused the error, and the sequence of the function calls that led to the error. This sequence of calls is called the call stack .\n\nOpen a new file editor tab in Mu, enter the following program, and save it as errorExample.py :\n\ndef spam(): bacon() def bacon(): raise Exception('This is the error message.') spam()\n\nWhen you run errorExample.py , the output will look like this:\n\nTraceback (most recent call last): File \"errorExample.py\", line 7, in <module> spam() File \"errorExample.py\", line 2, in spam bacon() File \"errorExample.py\", line 5, in bacon raise Exception('This is the error message.') Exception: This is the error message.\n\nFrom the traceback, you can see that the error happened on line 5, in the bacon() function. This particular call to bacon() came from line 2, in the spam() function, which in turn was called on line 7. In programs where functions can be called from multiple places, the call stack can help you determine which call led to the error.\n\nPython displays the traceback whenever a raised exception goes unhandled. But you can also obtain it as a string by calling traceback.format_exc() . This function is useful if you want the information from an exception\u2019s traceback but also want an except statement to gracefully handle the exception. You will need to import Python\u2019s traceback module before calling this function.\n\nFor example, instead of crashing your program right when an exception occurs, you can write the traceback information to a text file and keep your program running. You can look at the text file later, when you\u2019re ready to debug your program. Enter the following into the interactive shell:\n\n>>> import traceback >>> try: ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0raise Exception('This is the error message.') except: ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errorFile = open('errorInfo.txt', 'w') ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errorFile.write(traceback.format_exc()) ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0errorFile.close() ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print('The traceback info was written to errorInfo.txt.') 111 The traceback info was written to errorInfo.txt.\n\nThe 111 is the return value from the write() method, since 111 characters were written to the file. The traceback text was written to errorInfo.txt .\n\nTraceback (most recent call last): File \"<pyshell#28>\", line 2, in <module> Exception: This is the error message.\n\nIn \u201cLogging\u201d on page 255, you\u2019ll learn how to use the logging module, which is more effective than simply writing this error information to text files.", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "Provide a guide on 'Assertions' in Python.", "input": "", "output": "An assertion is a sanity check to make sure your code isn\u2019t doing something obviously wrong. These sanity checks are performed by assert statements. If the sanity check fails, then an AssertionError exception is raised. In code, an assert statement consists of the following:\n\n* The assert keyword\n* A condition (that is, an expression that evaluates to True or False )\n* A comma\n* A string to display when the condition is False\n\nIn plain English, an assert statement says, \u201cI assert that the condition holds true, and if not, there is a bug somewhere, so immediately stop the program.\u201d For example, enter the following into the interactive shell:\n\n>>> ages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] >>> ages.sort() >>> ages [15, 17, 22, 26, 47, 54, 57, 73, 80, 92] >>> assert ages[0] <= ages[-1] # Assert that the first age is <= the last age.\n\nThe assert statement here asserts that the first item in ages should be less than or equal to the last one. This is a sanity check; if the code in sort() is bug-free and did its job, then the assertion would be true.\n\nBecause the ages[0] <= ages[-1] expression evaluates to True , the assert statement does nothing.\n\nHowever, let\u2019s pretend we had a bug in our code. Say we accidentally called the reverse() list method instead of the sort() list method. When we enter the following in the interactive shell, the assert statement raises an AssertionError :\n\n>>> ages = [26, 57, 92, 54, 22, 15, 17, 80, 47, 73] >>> ages.reverse() >>> ages [73, 47, 80, 17, 15, 22, 54, 92, 57, 26] >>> assert ages[0] <= ages[-1] # Assert that the first age is <= the last age. Traceback (most recent call last): File \"<stdin>\", line 1, in <module> AssertionError\n\nUnlike exceptions, your code should not handle assert statements with try and except ; if an assert fails, your program should crash. By \u201cfailing fast\u201d like this, you shorten the time between the original cause of the bug and when you first notice the bug. This will reduce the amount of code you will have to check before finding the bug\u2019s cause.\n\nAssertions are for programmer errors, not user errors. Assertions should only fail while the program is under development; a user should never see an assertion error in a finished program. For errors that your program can run into as a normal part of its operation (such as a file not being found or the user entering invalid data), raise an exception instead of detecting it with an assert statement. You shouldn\u2019t use assert statements in place of raising exceptions, because users can choose to turn off assertions. If you run a Python script with python -O myscript.py instead of python myscript.py , Python will skip assert statements. Users might disable assertions when they\u2019re developing a program and need to run it in a production setting that requires peak performance. (Though, in many cases, they\u2019ll leave assertions enabled even then.)\n\nAssertions also aren\u2019t a replacement for comprehensive testing. For instance, if the previous ages example was set to [10, 3, 2, 1, 20] , then the assert ages[0] <= ages[-1] assertion wouldn\u2019t notice that the list was unsorted, because it just happened to have a first age that was less than or equal to the last age, which is the only thing the assertion checked for.\n\nSay you\u2019re building a traffic light simulation program. The data structure representing the stoplights at an intersection is a dictionary with keys 'ns' and 'ew' , for the stoplights facing north-south and east-west, respectively. The values at these keys will be one of the strings 'green' , 'yellow' , or 'red' . The code would look something like this:\n\nmarket_2nd = {'ns': 'green', 'ew': 'red'} mission_16th = {'ns': 'red', 'ew': 'green'}\n\nThese two variables will be for the intersections of Market Street and 2nd Street, and Mission Street and 16th Street. To start the project, you want to write a switchLights() function, which will take an intersection dictionary as an argument and switch the lights.\n\nAt first, you might think that switchLights() should simply switch each light to the next color in the sequence: Any 'green' values should change to 'yellow' , 'yellow' values should change to 'red' , and 'red' values should change to 'green' . The code to implement this idea might look like this:\n\ndef switchLights(stoplight): for key in stoplight.keys(): if stoplight[key] == 'green': stoplight[key] = 'yellow' elif stoplight[key] == 'yellow': stoplight[key] = 'red' elif stoplight[key] == 'red': stoplight[key] = 'green' switchLights(market_2nd)\n\nYou may already see the problem with this code, but let\u2019s pretend you wrote the rest of the simulation code, thousands of lines long, without noticing it. When you finally do run the simulation, the program doesn\u2019t crash\u2014but your virtual cars do!\n\nSince you\u2019ve already written the rest of the program, you have no idea where the bug could be. Maybe it\u2019s in the code simulating the cars or in the code simulating the virtual drivers. It could take hours to trace the bug back to the switchLights() function.\n\nBut if while writing switchLights() you had added an assertion to check that at least one of the lights is always red , you might have included the following at the bottom of the function:\n\nassert 'red' in stoplight.values(), 'Neither light is red! ' + str(stoplight)\n\nWith this assertion in place, your program would crash with this error message:\n\nTraceback (most recent call last): File \"carSim.py\", line 14, in <module> switchLights(market_2nd) File \"carSim.py\", line 13, in switchLights assert 'red' in stoplight.values(), 'Neither light is red! ' + str(stoplight) \u278a AssertionError: Neither light is red! {'ns': 'yellow', 'ew': 'green'}\n\nThe important line here is the AssertionError \u278a . While your program crashing is not ideal, it immediately points out that a sanity check failed: neither direction of traffic has a red light, meaning that traffic could be going both ways. By failing fast early in the program\u2019s execution, you can save yourself a lot of future debugging effort.", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "Explain the concept of 'Logging' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "If you\u2019ve ever put a print() statement in your code to output some variable\u2019s value while your program is running, you\u2019ve used a form of logging to debug your code. Logging is a great way to understand what\u2019s happening in your program and in what order it\u2019s happening. Python\u2019s logging module makes it easy to create a record of custom messages that you write. These log messages will describe when the program execution has reached the logging function call and list any variables you have specified at that point in time. On the other hand, a missing log message indicates a part of the code was skipped and never executed.\n\nTo enable the logging module to display log messages on your screen as your program runs, copy the following to the top of your program (but under the #! python shebang line):\n\nimport logging logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s -\u00a0\u00a0%(levelname) s -\u00a0\u00a0%(message)s')\n\nYou don\u2019t need to worry too much about how this works, but basically, when Python logs an event, it creates a LogRecord object that holds information about that event. The logging module\u2019s basicConfig() function lets you specify what details about the LogRecord object you want to see and how you want those details displayed.\n\nSay you wrote a function to calculate the factorial of a number. In mathematics, factorial 4 is 1 \u00d7 2 \u00d7 3 \u00d7 4, or 24. Factorial 7 is 1 \u00d7 2 \u00d7 3 \u00d7 4 \u00d7 5 \u00d7 6 \u00d7 7, or 5,040. Open a new file editor tab and enter the following code. It has a bug in it, but you will also enter several log messages to help yourself figure out what is going wrong. Save the program as factorialLog.py .\n\nimport logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s -\u00a0\u00a0%(levelname)s -\u00a0\u00a0%(message)s') logging.debug('Start of program') def factorial(n): logging.debug('Start of factorial(%s%%)'\u00a0\u00a0% (n)) total = 1 for i in range(n + 1): total *= i logging.debug('i is ' + str(i) + ', total is ' + str(total)) logging.debug('End of factorial(%s%%)'\u00a0\u00a0% (n)) return total print(factorial(5)) logging.debug('End of program')\n\nHere, we use the logging.debug() function when we want to print log information. This debug() function will call basicConfig() , and a line of information will be printed. This information will be in the format we specified in basicConfig() and will include the messages we passed to debug() . The print(factorial(5)) call is part of the original program, so the result is displayed even if logging messages are disabled.\n\nThe output of this program looks like this:\n\n2019-05-23 16:20:12,664 - DEBUG - Start of program 2019-05-23 16:20:12,664 - DEBUG - Start of factorial(5) 2019-05-23 16:20:12,665 - DEBUG - i is 0, total is 0 2019-05-23 16:20:12,668 - DEBUG - i is 1, total is 0 2019-05-23 16:20:12,670 - DEBUG - i is 2, total is 0 2019-05-23 16:20:12,673 - DEBUG - i is 3, total is 0 2019-05-23 16:20:12,675 - DEBUG - i is 4, total is 0 2019-05-23 16:20:12,678 - DEBUG - i is 5, total is 0 2019-05-23 16:20:12,680 - DEBUG - End of factorial(5) 0 2019-05-23 16:20:12,684 - DEBUG - End of program\n\nThe factorial() function is returning 0 as the factorial of 5 , which isn\u2019t right. The for loop should be multiplying the value in total by the numbers from 1 to 5 . But the log messages displayed by logging.debug() show that the i variable is starting at 0 instead of 1 . Since zero times anything is zero, the rest of the iterations also have the wrong value for total . Logging messages provide a trail of breadcrumbs that can help you figure out when things started to go wrong.\n\nChange the for i in range(n + 1): line to for i in range( 1, n + 1): , and run the program again. The output will look like this:\n\n2019-05-23 17:13:40,650 - DEBUG - Start of program 2019-05-23 17:13:40,651 - DEBUG - Start of factorial(5) 2019-05-23 17:13:40,651 - DEBUG - i is 1, total is 1 2019-05-23 17:13:40,654 - DEBUG - i is 2, total is 2 2019-05-23 17:13:40,656 - DEBUG - i is 3, total is 6 2019-05-23 17:13:40,659 - DEBUG - i is 4, total is 24 2019-05-23 17:13:40,661 - DEBUG - i is 5, total is 120 2019-05-23 17:13:40,661 - DEBUG - End of factorial(5) 120 2019-05-23 17:13:40,666 - DEBUG - End of program\n\nThe factorial(5) call correctly returns 120 . The log messages showed what was going on inside the loop, which led straight to the bug.\n\nYou can see that the logging.debug() calls printed out not just the strings passed to them but also a timestamp and the word DEBUG .\n\nTyping import logging and logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') is somewhat unwieldy. You may want to use print() calls instead, but don\u2019t give in to this temptation! Once you\u2019re done debugging, you\u2019ll end up spending a lot of time removing print() calls from your code for each log message. You might even accidentally remove some print() calls that were being used for nonlog messages. The nice thing about log messages is that you\u2019re free to fill your program with as many as you like, and you can always disable them later by adding a single logging.disable(logging.CRITICAL) call. Unlike print() , the logging module makes it easy to switch between showing and hiding log messages.\n\nLog messages are intended for the programmer, not the user. The user won\u2019t care about the contents of some dictionary value you need to see to help with debugging; use a log message for something like that. For messages that the user will want to see, like File not found or Invalid input, please enter a number , you should use a print() call. You don\u2019t want to deprive the user of useful information after you\u2019ve disabled log messages.\n\nLogging levels provide a way to categorize your log messages by importance. There are five logging levels, described in Table 11-1 from least to most important. Messages can be logged at each level using a different logging function.\n\nTable 11-1: Logging Levels in Python\n\nYour logging message is passed as a string to these functions. The logging levels are suggestions. Ultimately, it is up to you to decide which category your log message falls into. Enter the following into the interactive shell:\n\n>>> import logging >>> logging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s -\u00a0\u00a0%(message)s') >>> logging.debug('Some debugging details.') 2019-05-18 19:04:26,901 - DEBUG - Some debugging details. >>> logging.info('The logging module is working.') 2019-05-18 19:04:35,569 - INFO - The logging module is working. >>> logging.warning('An error message is about to be logged.') 2019-05-18 19:04:56,843 - WARNING - An error message is about to be logged. >>> logging.error('An error has occurred.') 2019-05-18 19:05:07,737 - ERROR - An error has occurred. >>> logging.critical('The program is unable to recover!') 2019-05-18 19:05:45,794 - CRITICAL - The program is unable to recover!\n\nThe benefit of logging levels is that you can change what priority of logging message you want to see. Passing logging.DEBUG to the basicConfig() function\u2019s level keyword argument will show messages from all the logging levels (DEBUG being the lowest level). But after developing your program some more, you may be interested only in errors. In that case, you can set basicConfig() \u2019s level argument to logging.ERROR . This will show only ERROR and CRITICAL messages and skip the DEBUG, INFO, and WARNING messages.\n\nAfter you\u2019ve debugged your program, you probably don\u2019t want all these log messages cluttering the screen. The logging.disable() function disables these so that you don\u2019t have to go into your program and remove all the logging calls by hand. You simply pass logging.disable() a logging level, and it will suppress all log messages at that level or lower. So if you want to disable logging entirely, just add logging.disable(logging.CRITICAL) to your program. For example, enter the following into the interactive shell:\n\n>>> import logging >>> logging.basicConfig(level=logging.INFO, format=' %(asctime)s - %(levelname)s -\u00a0\u00a0%(message)s') >>> logging.critical('Critical error! Critical error!') 2019-05-22 11:10:48,054 - CRITICAL - Critical error! Critical error! >>> logging.disable(logging.CRITICAL) >>> logging.critical('Critical error! Critical error!') >>> logging.error('Error! Error!')\n\nSince logging.disable() will disable all messages after it, you will probably want to add it near the import logging line of code in your program. This way, you can easily find it to comment out or uncomment that call to enable or disable logging messages as needed.\n\nInstead of displaying the log messages to the screen, you can write them to a text file. The logging.basicConfig() function takes a filename keyword argument, like so:\n\nimport logging logging.basicConfig( filename='myProgramLog.txt' , level=logging.DEBUG, format=' %(asctime)s -\u00a0\u00a0%(levelname)s -\u00a0\u00a0%(message)s')\n\nThe log messages will be saved to myProgramLog.txt . While logging messages are helpful, they can clutter your screen and make it hard to read the program\u2019s output. Writing the logging messages to a file will keep your screen clear and store the messages so you can read them after running the program. You can open this text file in any text editor, such as Notepad or TextEdit.", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "Provide a guide on 'Mu\u2019s Debugger' in Python.", "input": "", "output": "The debugger is a feature of the Mu editor, IDLE, and other editor software that allows you to execute your program one line at a time. The debugger will run a single line of code and then wait for you to tell it to continue. By running your program \u201cunder the debugger\u201d like this, you can take as much time as you want to examine the values in the variables at any given point during the program\u2019s lifetime. This is a valuable tool for tracking down bugs.\n\nTo run a program under Mu\u2019s debugger, click the Debug button in the top row of buttons, next to the Run button. Along with the usual output pane at the bottom, the Debug Inspector pane will open along the right side of the window. This pane lists the current value of variables in your program. In Figure 11-1, the debugger has paused the execution of the program just before it would have run the first line of code. You can see this line highlighted in the file editor.\n\nFigure 11-1: Mu running a program under the debugger\n\nDebugging mode also adds the following new buttons to the top of the editor: Continue, Step Over, Step In, and Step Out. The usual Stop button is also available.\n\nClicking the Continue button will cause the program to execute normally until it terminates or reaches a breakpoint . (I will describe breakpoints later in this chapter.) If you are done debugging and want the program to continue normally, click the Continue button.\n\nClicking the Step In button will cause the debugger to execute the next line of code and then pause again. If the next line of code is a function call, the debugger will \u201cstep into\u201d that function and jump to the first line of code of that function.\n\nClicking the Step Over button will execute the next line of code, similar to the Step In button. However, if the next line of code is a function call, the Step Over button will \u201cstep over\u201d the code in the function. The function\u2019s code will be executed at full speed, and the debugger will pause as soon as the function call returns. For example, if the next line of code calls a spam() function but you don\u2019t really care about code inside this function, you can click Step Over to execute the code in the function at normal speed, and then pause when the function returns. For this reason, using the Over button is more common than using the Step In button.\n\nClicking the Step Out button will cause the debugger to execute lines of code at full speed until it returns from the current function. If you have stepped into a function call with the Step In button and now simply want to keep executing instructions until you get back out, click the Out button to \u201cstep out\u201d of the current function call.\n\nIf you want to stop debugging entirely and not bother to continue executing the rest of the program, click the Stop button. The Stop button will immediately terminate the program.\n\nOpen a new file editor tab and enter the following code:\n\nprint('Enter the first number to add:') first = input() print('Enter the second number to add:') second = input() print('Enter the third number to add:') third = input() print('The sum is ' + first + second + third)\n\nSave it as buggyAddingProgram.py and run it first without the debugger enabled. The program will output something like this:\n\nEnter the first number to add: 5 Enter the second number to add: 3 Enter the third number to add: 42 The sum is 5342\n\nThe program hasn\u2019t crashed, but the sum is obviously wrong. Run the program again, this time under the debugger.\n\nWhen you click the Debug button, the program pauses on line 1, which is the line of code it is about to execute. Mu should look like Figure 10-1.\n\nClick the Step Over button once to execute the first print() call. You should use Step Over instead of Step In here, since you don\u2019t want to step into the code for the print() function. (Although Mu should prevent the debugger from entering Python\u2019s built-in functions.) The debugger moves on to line 2, and highlights line 2 in the file editor, as shown in Figure 11-2. This shows you where the program execution currently is.\n\nFigure 11-2: The Mu editor window after clicking Step Over\n\nClick Step Over again to execute the input() function call. The highlighting will go away while Mu waits for you to type something for the input() call into the output pane. Enter 5 and press ENTER . The highlighting will return.\n\nKeep clicking Step Over , and enter 3 and 42 as the next two numbers. When the debugger reaches line 7, the final print() call in the program, the Mu editor window should look like Figure 11-3.\n\nFigure 11-3: The Debug Inspector pane on the right side shows that the variables are set to strings instead of integers, causing the bug.\n\nIn the Debug Inspector pane, you should see that the first , second , and third variables are set to string values '5' , '3' , and '42' instead of integer values 5 , 3 , and 42 . When the last line is executed, Python concatenates these strings instead of adding the numbers together, causing the bug.\n\nStepping through the program with the debugger is helpful but can also be slow. Often you\u2019ll want the program to run normally until it reaches a certain line of code. You can configure the debugger to do this with breakpoints.\n\nA breakpoint can be set on a specific line of code and forces the debugger to pause whenever the program execution reaches that line. Open a new file editor tab and enter the following program, which simulates flipping a coin 1,000 times. Save it as coinFlip.py .\n\nimport random heads = 0 for i in range(1, 1001): \u278a if random.randint(0, 1) == 1: heads = heads + 1 if i == 500: \u278b print('Halfway done!') print('Heads came up ' + str(heads) + ' times.')\n\nThe random.randint(0, 1) call \u278a will return 0 half of the time and 1 the other half of the time. This can be used to simulate a 50/50 coin flip where 1 represents heads. When you run this program without the debugger, it quickly outputs something like the following:\n\nHalfway done! Heads came up 490 times.\n\nIf you ran this program under the debugger, you would have to click the Step Over button thousands of times before the program terminated. If you were interested in the value of heads at the halfway point of the program\u2019s execution, when 500 of 1,000 coin flips have been completed, you could instead just set a breakpoint on the line print('Halfway done!') \u278b . To set a breakpoint, click the line number in the file editor to cause a red dot to appear, marking the breakpoint like in Figure 11-4.\n\nFigure 11-4: Setting a breakpoint causes a red dot (circled) to appear next to the line number.\n\nYou don\u2019t want to set a breakpoint on the if statement line, since the if statement is executed on every single iteration through the loop. When you set the breakpoint on the code in the if statement, the debugger breaks only when the execution enters the if clause.\n\nThe line with the breakpoint will have a red dot next to it. When you run the program under the debugger, it will start in a paused state at the first line, as usual. But if you click Continue, the program will run at full speed until it reaches the line with the breakpoint set on it. You can then click Continue, Step Over, Step In, or Step Out to continue as normal.\n\nIf you want to remove a breakpoint, click the line number again. The red dot will go away, and the debugger will not break on that line in the future.", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "Explain the concept of 'Practice Project' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "For practice, write a program that does the following.\n\nThe following program is meant to be a simple coin toss guessing game. The player gets two guesses (it\u2019s an easy game). However, the program has several bugs in it. Run through the program a few times to find the bugs that keep the program from working correctly.\n\nimport random guess = '' while guess not in ('heads', 'tails'): print('Guess the coin toss! Enter heads or tails:') guess = input() toss = random.randint(0, 1) # 0 is tails, 1 is heads if toss == guess: print('You got it!') else: print('Nope! Guess again!') guesss = input() if toss == guess: print('You got it!') else: print('Nope. You are really bad at this game.')", "source": "https://automatetheboringstuff.com/2e/chapter11/", "category": "11DEBUGGING"}
{"instruction": "What is '12WEB SCRAPING' and how does it work in Python?", "input": "", "output": "In those rare, terrifying moments when I\u2019m without Wi-Fi, I realize just how much of what I do on the computer is really what I do on the internet. Out of sheer habit I\u2019ll find myself trying to check email, read friends\u2019 Twitter feeds, or answer the question, \u201cDid Kurtwood Smith have any major roles before he was in the original 1987 RoboCop ?\u201d 1\n\nSince so much work on a computer involves going on the internet, it\u2019d be great if your programs could get online. Web scraping is the term for using a program to download and process content from the web. For example, Google runs many web scraping programs to index web pages for its search engine. In this chapter, you will learn about several modules that make it easy to scrape web pages in Python.\n\nwebbrowser Comes with Python and opens a browser to a specific page.\n\nrequests Downloads files and web pages from the internet.\n\nbs4 Parses HTML, the format that web pages are written in.\n\nselenium Launches and controls a web browser. The selenium module is able to fill in forms and simulate mouse clicks in this browser.", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "What is 'Project: mapIt.py with the webbrowser Module' and how does it work in Python?", "input": "", "output": "The webbrowser module\u2019s open() function can launch a new browser to a specified URL. Enter the following into the interactive shell:\n\n>>> import webbrowser >>> webbrowser.open('https://inventwithpython.com/')\n\nA web browser tab will open to the URL https://inventwithpython.com/ . This is about the only thing the webbrowser module can do. Even so, the open() function does make some interesting things possible. For example, it\u2019s tedious to copy a street address to the clipboard and bring up a map of it on Google Maps. You could take a few steps out of this task by writing a simple script to automatically launch the map in your browser using the contents of your clipboard. This way, you only have to copy the address to a clipboard and run the script, and the map will be loaded for you.\n\nThis is what your program does:\n\n1. Gets a street address from the command line arguments or clipboard\n2. Opens the web browser to the Google Maps page for the address\n\nThis means your code will need to do the following:\n\n1. Read the command line arguments from sys.argv .\n2. Read the clipboard contents.\n3. Call the webbrowser.open() function to open the web browser.\n\nOpen a new file editor tab and save it as mapIt.py .\n\nBased on the instructions in Appendix B, set up mapIt.py so that when you run it from the command line, like so . . .\n\nC:\\> mapit 870 Valencia St, San Francisco, CA 94110\n\n. . . the script will use the command line arguments instead of the clipboard. If there are no command line arguments, then the program will know to use the contents of the clipboard.\n\nFirst you need to figure out what URL to use for a given street address. When you load https://maps.google.com/ in the browser and search for an address, the URL in the address bar looks something like this: https://www.google.com/maps/place/870+Valencia+St/@37.7590311,-122.4215096,17z/data=!3m1!4b1!4m2!3m1!1s0x808f7e3dadc07a37:0xc86b0b2bb93b73d8 .\n\nThe address is in the URL, but there\u2019s a lot of additional text there as well. Websites often add extra data to URLs to help track visitors or customize sites. But if you try just going to https://www.google.com/maps/place/870+Valencia+St+San+Francisco+CA/ , you\u2019ll find that it still brings up the correct page. So your program can be set to open a web browser to 'https://www.google.com/maps/place/ your_address_string ' (where your_address_string is the address you want to map).\n\nMake your code look like this:\n\n#! python3 # mapIt.py - Launches a map in the browser using an address from the # command line or clipboard. import webbrowser, sys if len(sys.argv) > 1: # Get address from command line. address = ' '.join(sys.argv[1:]) # TODO: Get address from clipboard.\n\nAfter the program\u2019s #! shebang line, you need to import the webbrowser module for launching the browser and import the sys module for reading the potential command line arguments. The sys.argv variable stores a list of the program\u2019s filename and command line arguments. If this list has more than just the filename in it, then len(sys.argv) evaluates to an integer greater than 1 , meaning that command line arguments have indeed been provided.\n\nCommand line arguments are usually separated by spaces, but in this case, you want to interpret all of the arguments as a single string. Since sys.argv is a list of strings, you can pass it to the join() method, which returns a single string value. You don\u2019t want the program name in this string, so instead of sys.argv , you should pass sys.argv[1:] to chop off the first element of the array. The final string that this expression evaluates to is stored in the address variable.\n\nIf you run the program by entering this into the command line . . .\n\nmapit 870 Valencia St, San Francisco, CA 94110\n\n. . . the sys.argv variable will contain this list value:\n\n['mapIt.py', '870', 'Valencia', 'St, ', 'San', 'Francisco, ', 'CA', '94110']\n\nThe address variable will contain the string '870 Valencia St, San Francisco, CA 94110' .\n\nMake your code look like the following:\n\n#! python3 # mapIt.py - Launches a map in the browser using an address from the # command line or clipboard. import webbrowser, sys , pyperclip if len(sys.argv) > 1: # Get address from command line. address = ' '.join(sys.argv[1:]) else: # Get address from clipboard. address = pyperclip.paste() webbrowser.open('https://www.google.com/maps/place/' + address)\n\nIf there are no command line arguments, the program will assume the address is stored on the clipboard. You can get the clipboard content with pyperclip.paste() and store it in a variable named address . Finally, to launch a web browser with the Google Maps URL, call webbrowser.open() .\n\nWhile some of the programs you write will perform huge tasks that save you hours, it can be just as satisfying to use a program that conveniently saves you a few seconds each time you perform a common task, such as getting a map of an address. Table 12-1 compares the steps needed to display a map with and without mapIt.py .\n\nTable 12-1: Getting a Map with and Without mapIt.py\n\nSee how mapIt.py makes this task less tedious?\n\nAs long as you have a URL, the webbrowser module lets users cut out the step of opening the browser and directing themselves to a website. Other programs could use this functionality to do the following:\n\n* Open all links on a page in separate browser tabs.\n* Open the browser to the URL for your local weather.\n* Open several social network sites that you regularly check.", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "Explain the concept of 'Downloading Files from the Web with the requests Module' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "The requests module lets you easily download files from the web without having to worry about complicated issues such as network errors, connection problems, and data compression. The requests module doesn\u2019t come with Python, so you\u2019ll have to install it first. From the command line, run pip install --user requests . (Appendix A has additional details on how to install third-party modules.)\n\nThe requests module was written because Python\u2019s urllib2 module is too complicated to use. In fact, take a permanent marker and black out this entire paragraph. Forget I ever mentioned urllib2 . If you need to download things from the web, just use the requests module.\n\nNext, do a simple test to make sure the requests module installed itself correctly. Enter the following into the interactive shell:\n\n>>> import requests\n\nIf no error messages show up, then the requests module has been successfully installed.\n\nThe requests.get() function takes a string of a URL to download. By calling type() on requests.get() \u2019s return value, you can see that it returns a Response object, which contains the response that the web server gave for your request. I\u2019ll explain the Response object in more detail later, but for now, enter the following into the interactive shell while your computer is connected to the internet:\n\n>>> import requests \u278a >>> res = requests.get('https://automatetheboringstuff.com/files/rj.txt') >>> type(res) <class 'requests.models.Response'> \u278b >>> res.status_code == requests.codes.ok True >>> len(res.text) 178981 >>> print(res.text[:250]) The Project Gutenberg EBook of Romeo and Juliet, by William Shakespeare This eBook is for the use of anyone anywhere at no cost and with almost no restrictions whatsoever.\u00a0\u00a0You may copy it, give it away or re-use it under the terms of the Proje\n\nThe URL goes to a text web page for the entire play of Romeo and Juliet , provided on this book\u2019s site \u278a . You can tell that the request for this web page succeeded by checking the status_code attribute of the Response object. If it is equal to the value of requests.codes.ok , then everything went fine \u278b . (Incidentally, the status code for \u201cOK\u201d in the HTTP protocol is 200. You may already be familiar with the 404 status code for \u201cNot Found.\u201d) You can find a complete list of HTTP status codes and their meanings at https://en.wikipedia.org/wiki/List_of_HTTP_status_codes .\n\nIf the request succeeded, the downloaded web page is stored as a string in the Response object\u2019s text variable. This variable holds a large string of the entire play; the call to len(res.text) shows you that it is more than 178,000 characters long. Finally, calling print(res.text[:250]) displays only the first 250 characters.\n\nIf the request failed and displayed an error message, like \u201cFailed to establish a new connection\u201d or \u201cMax retries exceeded,\u201d then check your internet connection. Connecting to servers can be quite complicated, and I can\u2019t give a full list of possible problems here. You can find common causes of your error by doing a web search of the error message in quotes.\n\nAs you\u2019ve seen, the Response object has a status_code attribute that can be checked against requests.codes.ok (a variable that has the integer value 200 ) to see whether the download succeeded. A simpler way to check for success is to call the raise_for_status() method on the Response object. This will raise an exception if there was an error downloading the file and will do nothing if the download succeeded. Enter the following into the interactive shell:\n\n>>> res = requests.get('https://inventwithpython.com/page_that_does_not_exist') >>> res.raise_for_status() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\requests\\models .py\", line 940, in raise_for_status raise HTTPError(http_error_msg, response=self) requests.exceptions.HTTPError: 404 Client Error: Not Found for url: https://inventwithpython .com/page_that_does_not_exist.html\n\nThe raise_for_status() method is a good way to ensure that a program halts if a bad download occurs. This is a good thing: You want your program to stop as soon as some unexpected error happens. If a failed download isn\u2019t a deal breaker for your program, you can wrap the raise_for_status() line with try and except statements to handle this error case without crashing.\n\nimport requests res = requests.get('https://inventwithpython.com/page_that_does_not_exist') try: res.raise_for_status() except Exception as exc: print('There was a problem: %s' % (exc))\n\nThis raise_for_status() method call causes the program to output the following:\n\nThere was a problem: 404 Client Error: Not Found for url: https:// inventwithpython.com/page_that_does_not_exist.html\n\nAlways call raise_for_status() after calling requests.get() . You want to be sure that the download has actually worked before your program continues.", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "Explain the concept of 'Saving Downloaded Files to the Hard Drive' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "From here, you can save the web page to a file on your hard drive with the standard open() function and write() method. There are some slight differences, though. First, you must open the file in write binary mode by passing the string 'wb' as the second argument to open() . Even if the page is in plaintext (such as the Romeo and Juliet text you downloaded earlier), you need to write binary data instead of text data in order to maintain the Unicode encoding of the text.\n\nTo write the web page to a file, you can use a for loop with the Response object\u2019s iter_content() method.\n\n>>> import requests >>> res = requests.get('https://automatetheboringstuff.com/files/rj.txt') >>> res.raise_for_status() >>> playFile = open('RomeoAndJuliet.txt', 'wb') >>> for chunk in res.iter_content(100000): playFile.write(chunk) 100000 78981 >>> playFile.close()\n\nThe iter_content() method returns \u201cchunks\u201d of the content on each iteration through the loop. Each chunk is of the bytes data type, and you get to specify how many bytes each chunk will contain. One hundred thousand bytes is generally a good size, so pass 100000 as the argument to iter_content() .\n\nThe file RomeoAndJuliet.txt will now exist in the current working directory. Note that while the filename on the website was rj.txt , the file on your hard drive has a different filename. The requests module simply handles downloading the contents of web pages. Once the page is downloaded, it is simply data in your program. Even if you were to lose your internet connection after downloading the web page, all the page data would still be on your computer.\n\nThe write() method returns the number of bytes written to the file. In the previous example, there were 100,000 bytes in the first chunk, and the remaining part of the file needed only 78,981 bytes.\n\nTo review, here\u2019s the complete process for downloading and saving a file:\n\n1. Call requests.get() to download the file.\n2. Call open() with 'wb' to create a new file in write binary mode.\n3. Loop over the Response object\u2019s iter_content() method.\n4. Call write() on each iteration to write the content to the file.\n5. Call close() to close the file.\n\nThat\u2019s all there is to the requests module! The for loop and iter_content() stuff may seem complicated compared to the open() / write() / close() workflow you\u2019ve been using to write text files, but it\u2019s to ensure that the requests module doesn\u2019t eat up too much memory even if you download massive files. You can learn about the requests module\u2019s other features from https://requests.readthedocs.org/ .", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "Explain the concept of 'HTML' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Before you pick apart web pages, you\u2019ll learn some HTML basics. You\u2019ll also see how to access your web browser\u2019s powerful developer tools, which will make scraping information from the web much easier.\n\nHypertext Markup Language (HTML) is the format that web pages are written in. This chapter assumes you have some basic experience with HTML, but if you need a beginner tutorial, I suggest one of the following sites:\n\n* https://developer.mozilla.org/en-US/learn/html/\n* https://htmldog.com/guides/html/beginner/\n* https://www.codecademy.com/learn/learn-html\n\nIn case it\u2019s been a while since you\u2019ve looked at any HTML, here\u2019s a quick overview of the basics. An HTML file is a plaintext file with the .html file extension. The text in these files is surrounded by tags , which are words enclosed in angle brackets. The tags tell the browser how to format the web page. A starting tag and closing tag can enclose some text to form an element . The text (or inner HTML ) is the content between the starting and closing tags. For example, the following HTML will display Hello, world! in the browser, with Hello in bold:\n\n<strong>Hello</strong>, world!\n\nThis HTML will look like Figure 12-1 in a browser.\n\nFigure 12-1: Hello, world! rendered in the browser\n\nThe opening <strong> tag says that the enclosed text will appear in bold. The closing </strong> tags tells the browser where the end of the bold text is.\n\nThere are many different tags in HTML. Some of these tags have extra properties in the form of attributes within the angle brackets. For example, the <a> tag encloses text that should be a link. The URL that the text links to is determined by the href attribute. Here\u2019s an example:\n\nAl's free <a href=\"https://inventwithpython.com\">Python books</a>.\n\nThis HTML will look like Figure 12-2 in a browser.\n\nFigure 12-2: The link rendered in the browser\n\nSome elements have an id attribute that is used to uniquely identify the element in the page. You will often instruct your programs to seek out an element by its id attribute, so figuring out an element\u2019s id attribute using the browser\u2019s developer tools is a common task in writing web scraping programs.\n\nYou\u2019ll need to look at the HTML source of the web pages that your programs will work with. To do this, right-click (or CTRL -click on macOS) any web page in your web browser, and select View Source or View page source to see the HTML text of the page (see Figure 12-3). This is the text your browser actually receives. The browser knows how to display, or render , the web page from this HTML.\n\nFigure 12-3: Viewing the source of a web page\n\nI highly recommend viewing the source HTML of some of your favorite sites. It\u2019s fine if you don\u2019t fully understand what you are seeing when you look at the source. You won\u2019t need HTML mastery to write simple web scraping programs\u2014after all, you won\u2019t be writing your own websites. You just need enough knowledge to pick out data from an existing site.\n\nIn addition to viewing a web page\u2019s source, you can look through a page\u2019s HTML using your browser\u2019s developer tools. In Chrome and Internet Explorer for Windows, the developer tools are already installed, and you can press F12 to make them appear (see Figure 12-4). Pressing F12 again will make the developer tools disappear. In Chrome, you can also bring up the developer tools by selecting View \u25b8 Developer \u25b8 Developer Tools . In macOS, pressing - OPTION -I will open Chrome\u2019s Developer Tools.\n\nFigure 12-4: The Developer Tools window in the Chrome browser\n\nIn Firefox, you can bring up the Web Developer Tools Inspector by pressing CTRL-SHIFT-C on Windows and Linux or by pressing -OPTION-C on macOS. The layout is almost identical to Chrome\u2019s developer tools.\n\nIn Safari, open the Preferences window, and on the Advanced pane check the Show Develop menu in the menu bar option. After it has been enabled, you can bring up the developer tools by pressing -OPTION-I .\n\nAfter enabling or installing the developer tools in your browser, you can right-click any part of the web page and select Inspect Element from the context menu to bring up the HTML responsible for that part of the page. This will be helpful when you begin to parse HTML for your web scraping programs.\n\nOnce your program has downloaded a web page using the requests module, you will have the page\u2019s HTML content as a single string value. Now you need to figure out which part of the HTML corresponds to the information on the web page you\u2019re interested in.\n\nThis is where the browser\u2019s developer tools can help. Say you want to write a program to pull weather forecast data from https://weather.gov/ . Before writing any code, do a little research. If you visit the site and search for the 94105 ZIP code, the site will take you to a page showing the forecast for that area.\n\nWhat if you\u2019re interested in scraping the weather information for that ZIP code? Right-click where it is on the page (or CONTROL -click on macOS) and select Inspect Element from the context menu that appears. This will bring up the Developer Tools window, which shows you the HTML that produces this particular part of the web page. Figure 12-5 shows the developer tools open to the HTML of the nearest forecast. Note that if the https://weather.gov/ site changes the design of its web pages, you\u2019ll need to repeat this process to inspect the new elements.\n\nFigure 12-5: Inspecting the element that holds forecast text with the developer tools\n\nFrom the developer tools, you can see that the HTML responsible for the forecast part of the web page is <div class=\"col-sm-10 forecast-text\">Sunny, with a high near 64. West wind 11 to 16 mph, with gusts as high as 21 mph.</div> . This is exactly what you were looking for! It seems that the forecast information is contained inside a <div> element with the forecast-text CSS class. Right-click on this element in the browser\u2019s developer console, and from the context menu that appears, select Copy \u25b8 CSS Selector . This will copy a string such as 'div.row-odd:nth-child(1) > div:nth-child(2)' to the clipboard. You can use this string for Beautiful Soup\u2019s select() or Selenium\u2019s find_element_by_css_selector() methods, as explained later in this chapter. Now that you know what you\u2019re looking for, the Beautiful Soup module will help you find it in the string.", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "What is 'Parsing HTML with the bs4 Module' and how does it work in Python?", "input": "", "output": "Beautiful Soup is a module for extracting information from an HTML page (and is much better for this purpose than regular expressions). The Beautiful Soup module\u2019s name is bs4 (for Beautiful Soup, version 4). To install it, you will need to run pip install --user beautifulsoup4 from the command line. (Check out Appendix A for instructions on installing third-party modules.) While beautifulsoup4 is the name used for installation, to import Beautiful Soup you run import bs4 .\n\nFor this chapter, the Beautiful Soup examples will parse (that is, analyze and identify the parts of) an HTML file on the hard drive. Open a new file editor tab in Mu, enter the following, and save it as example.html . Alternatively, download it from https://nostarch.com/automatestuff2/ .\n\n<!-- This is the example.html example file. --> <html><head><title>The Website Title</title></head> <body> <p>Download my <strong>Python</strong> book from <a href=\"https:// inventwithpython.com\">my website</a>.</p> <p class=\"slogan\">Learn Python the easy way!</p> <p>By <span id=\"author\">Al Sweigart</span></p> </body></html>\n\nAs you can see, even a simple HTML file involves many different tags and attributes, and matters quickly get confusing with complex websites. Thankfully, Beautiful Soup makes working with HTML much easier.\n\nThe bs4.BeautifulSoup() function needs to be called with a string containing the HTML it will parse. The bs4.BeautifulSoup() function returns a BeautifulSoup object. Enter the following into the interactive shell while your computer is connected to the internet:\n\n>>> import requests, bs4 >>> res = requests.get('https://nostarch.com') >>> res.raise_for_status() >>> noStarchSoup = bs4.BeautifulSoup(res.text, 'html.parser') >>> type(noStarchSoup) <class 'bs4.BeautifulSoup'>\n\nThis code uses requests.get() to download the main page from the No Starch Press website and then passes the text attribute of the response to bs4.BeautifulSoup() . The BeautifulSoup object that it returns is stored in a variable named noStarchSoup .\n\nYou can also load an HTML file from your hard drive by passing a File object to bs4.BeautifulSoup() along with a second argument that tells Beautiful Soup which parser to use to analyze the HTML.\n\nEnter the following into the interactive shell (after making sure the example.html file is in the working directory):\n\n>>> exampleFile = open('example.html') >>> exampleSoup = bs4.BeautifulSoup(exampleFile, 'html.parser') >>> type(exampleSoup) <class 'bs4.BeautifulSoup'>\n\nThe 'html.parser' parser used here comes with Python. However, you can use the faster 'lxml' parser if you install the third-party lxml module. Follow the instructions in Appendix A to install this module by running pip install --user lxml . Forgetting to include this second argument will result in a UserWarning: No parser was explicitly specified warning.\n\nOnce you have a BeautifulSoup object, you can use its methods to locate specific parts of an HTML document.\n\nYou can retrieve a web page element from a BeautifulSoup object by calling the select() method and passing a string of a CSS selector for the element you are looking for. Selectors are like regular expressions: they specify a pattern to look for\u2014in this case, in HTML pages instead of general text strings.\n\nA full discussion of CSS selector syntax is beyond the scope of this book (there\u2019s a good selector tutorial in the resources at https://nostarch.com/automatestuff2/ ), but here\u2019s a short introduction to selectors. Table 12-2 shows examples of the most common CSS selector patterns.\n\nTable 12-2: Examples of CSS Selectors\n\nThe various selector patterns can be combined to make sophisticated matches. For example, soup.select('p #author') will match any element that has an id attribute of author , as long as it is also inside a <p> element. Instead of writing the selector yourself, you can also right-click on the element in your browser and select Inspect Element . When the browser\u2019s developer console opens, right-click on the element\u2019s HTML and select Copy \u25b8 CSS Selector to copy the selector string to the clipboard and paste it into your source code.\n\nThe select() method will return a list of Tag objects, which is how Beautiful Soup represents an HTML element. The list will contain one Tag object for every match in the BeautifulSoup object\u2019s HTML. Tag values can be passed to the str() function to show the HTML tags they represent. Tag values also have an attrs attribute that shows all the HTML attributes of the tag as a dictionary. Using the example.html file from earlier, enter the following into the interactive shell:\n\n>>> import bs4 >>> exampleFile = open('example.html') >>> exampleSoup = bs4.BeautifulSoup(exampleFile.read(), 'html.parser') >>> elems = exampleSoup.select('#author') >>> type(elems) # elems is a list of Tag objects. <class 'list'> >>> len(elems) 1 >>> type(elems[0]) <class 'bs4.element.Tag'> >>> str(elems[0]) # The Tag object as a string. '<span id=\"author\">Al Sweigart</span>' >>> elems[0].getText() 'Al Sweigart' >>> elems[0].attrs {'id': 'author'}\n\nThis code will pull the element with id=\"author\" out of our example HTML. We use select('#author') to return a list of all the elements with id=\"author\" . We store this list of Tag objects in the variable elems , and len(elems) tells us there is one Tag object in the list; there was one match. Calling getText() on the element returns the element\u2019s text, or inner HTML. The text of an element is the content between the opening and closing tags: in this case, 'Al Sweigart' .\n\nPassing the element to str() returns a string with the starting and closing tags and the element\u2019s text. Finally, attrs gives us a dictionary with the element\u2019s attribute, 'id' , and the value of the id attribute, 'author' .\n\nYou can also pull all the <p> elements from the BeautifulSoup object. Enter this into the interactive shell:\n\n>>> pElems = exampleSoup.select('p') >>> str(pElems[0]) '<p>Download my <strong>Python</strong> book from <a href=\"https:// inventwithpython.com\">my website</a>.</p>' >>> pElems[0].getText() 'Download my Python book from my website.' >>> str(pElems[1]) '<p class=\"slogan\">Learn Python the easy way!</p>' >>> pElems[1].getText() 'Learn Python the easy way!' >>> str(pElems[2]) '<p>By <span id=\"author\">Al Sweigart</span></p>' >>> pElems[2].getText() 'By Al Sweigart'\n\nThis time, select() gives us a list of three matches, which we store in pElems . Using str() on pElems[0] , pElems[1] , and pElems[2] shows you each element as a string, and using getText() on each element shows you its text.\n\nThe get() method for Tag objects makes it simple to access attribute values from an element. The method is passed a string of an attribute name and returns that attribute\u2019s value. Using example.html , enter the following into the interactive shell:\n\n>>> import bs4 >>> soup = bs4.BeautifulSoup(open('example.html'), 'html.parser') >>> spanElem = soup.select('span')[0] >>> str(spanElem) '<span id=\"author\">Al Sweigart</span>' >>> spanElem.get('id') 'author' >>> spanElem.get('some_nonexistent_addr') == None True >>> spanElem.attrs {'id': 'author'}\n\nHere we use select() to find any <span> elements and then store the first matched element in spanElem . Passing the attribute name 'id' to get() returns the attribute\u2019s value, 'author' .", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "Explain the concept of 'Project: Opening All Search Results' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Whenever I search a topic on Google, I don\u2019t look at just one search result at a time. By middle-clicking a search result link (or clicking while holding CTRL ), I open the first several links in a bunch of new tabs to read later. I search Google often enough that this workflow\u2014opening my browser, searching for a topic, and middle-clicking several links one by one\u2014is tedious. It would be nice if I could simply type a search term on the command line and have my computer automatically open a browser with all the top search results in new tabs. Let\u2019s write a script to do this with the search results page for the Python Package Index at https://pypi.org/ . A program like this can be adapted to many other websites, although the Google and DuckDuckGo often employ measures that make scraping their search results pages difficult.\n\nThis is what your program does:\n\n1. Gets search keywords from the command line arguments\n2. Retrieves the search results page\n3. Opens a browser tab for each result\n\nThis means your code will need to do the following:\n\n1. Read the command line arguments from sys.argv .\n2. Fetch the search result page with the requests module.\n3. Find the links to each search result.\n4. Call the webbrowser.open() function to open the web browser.\n\nOpen a new file editor tab and save it as searchpypi.py .\n\nBefore coding anything, you first need to know the URL of the search result page. By looking at the browser\u2019s address bar after doing a search, you can see that the result page has a URL like https://pypi.org/search/?q=<SEARCH_TERM_HERE> . The requests module can download this page and then you can use Beautiful Soup to find the search result links in the HTML. Finally, you\u2019ll use the webbrowser module to open those links in browser tabs.\n\nMake your code look like the following:\n\n#! python3 # searchpypi.py\u00a0\u00a0- Opens several search results. import requests, sys, webbrowser, bs4 print('Searching...')\u00a0\u00a0\u00a0\u00a0# display text while downloading the search result page res = requests.get('https://google.com/search?q=' 'https://pypi.org/search/?q=' + ' '.join(sys.argv[1:])) res.raise_for_status() # TODO: Retrieve top search result links. # TODO: Open a browser tab for each result.\n\nThe user will specify the search terms using command line arguments when they launch the program. These arguments will be stored as strings in a list in sys.argv .\n\nNow you need to use Beautiful Soup to extract the top search result links from your downloaded HTML. But how do you figure out the right selector for the job? For example, you can\u2019t just search for all <a> tags, because there are lots of links you don\u2019t care about in the HTML. Instead, you must inspect the search result page with the browser\u2019s developer tools to try to find a selector that will pick out only the links you want.\n\nAfter doing a search for Beautiful Soup , you can open the browser\u2019s developer tools and inspect some of the link elements on the page. They can look complicated, something like pages of this: <a class=\"package-snippet\" href=\"/project/pyautogui/\"> .\n\nIt doesn\u2019t matter that the element looks incredibly complicated. You just need to find the pattern that all the search result links have.\n\nMake your code look like the following:\n\n#! python3 # searchpypi.py - Opens several google results. import requests, sys, webbrowser, bs4 -- snip -- # Retrieve top search result links. soup = bs4.BeautifulSoup(res.text, 'html.parser') # Open a browser tab for each result. linkElems = soup.select('.package-snippet')\n\nIf you look at the <a> elements, though, the search result links all have class=\"package-snippet\" . Looking through the rest of the HTML source, it looks like the package-snippet class is used only for search result links. You don\u2019t have to know what the CSS class package-snippet is or what it does. You\u2019re just going to use it as a marker for the <a> element you are looking for. You can create a BeautifulSoup object from the downloaded page\u2019s HTML text and then use the selector '.package-snippet' to find all <a> elements that are within an element that has the package-snippet CSS class. Note that if the PyPI website changes its layout, you may need to update this program with a new CSS selector string to pass to soup.select() . The rest of the program will still be up to date.\n\nFinally, we\u2019ll tell the program to open web browser tabs for our results. Add the following to the end of your program:\n\n#! python3 # searchpypi.py - Opens several search results. import requests, sys, webbrowser, bs4 -- snip -- # Open a browser tab for each result. linkElems = soup.select('.package-snippet') numOpen = min(5, len(linkElems)) for i in range(numOpen): urlToOpen = 'https://pypi.org' + linkElems[i].get('href') print('Opening', urlToOpen) webbrowser.open(urlToOpen)\n\nBy default, you open the first five search results in new tabs using the webbrowser module. However, the user may have searched for something that turned up fewer than five results. The soup.select() call returns a list of all the elements that matched your '.package-snippet' selector, so the number of tabs you want to open is either 5 or the length of this list (whichever is smaller).\n\nThe built-in Python function min() returns the smallest of the integer or float arguments it is passed. (There is also a built-in max() function that returns the largest argument it is passed.) You can use min() to find out whether there are fewer than five links in the list and store the number of links to open in a variable named numOpen . Then you can run through a for loop by calling range(numOpen) .\n\nOn each iteration of the loop, you use webbrowser.open() to open a new tab in the web browser. Note that the href attribute\u2019s value in the returned <a> elements do not have the initial https://pypi.org part, so you have to concatenate that to the href attribute\u2019s string value.\n\nNow you can instantly open the first five PyPI search results for, say, boring stuff by running searchpypi boring stuff on the command line! (See Appendix B for how to easily run programs on your operating system.)\n\nThe benefit of tabbed browsing is that you can easily open links in new tabs to peruse later. A program that automatically opens several links at once can be a nice shortcut to do the following:\n\n* Open all the product pages after searching a shopping site such as Amazon.\n* Open all the links to reviews for a single product.\n* Open the result links to photos after performing a search on a photo site such as Flickr or Imgur.", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "How do I use 'Project: Downloading All XKCD Comics' in Python?", "input": "", "output": "Blogs and other regularly updating websites usually have a front page with the most recent post as well as a Previous button on the page that takes you to the previous post. Then that post will also have a Previous button, and so on, creating a trail from the most recent page to the first post on the site. If you wanted a copy of the site\u2019s content to read when you\u2019re not online, you could manually navigate over every page and save each one. But this is pretty boring work, so let\u2019s write a program to do it instead.\n\nXKCD is a popular geek webcomic with a website that fits this structure (see Figure 12-6). The front page at https://xkcd.com/ has a Prev button that guides the user back through prior comics. Downloading each comic by hand would take forever, but you can write a script to do this in a couple of minutes.\n\nFigure 12-6: XKCD, \u201ca webcomic of romance, sarcasm, math, and language\u201d\n\nHere\u2019s what your program does:\n\n1. Loads the XKCD home page\n2. Saves the comic image on that page\n3. Follows the Previous Comic link\n4. Repeats until it reaches the first comic\n\nThis means your code will need to do the following:\n\n1. Download pages with the requests module.\n2. Find the URL of the comic image for a page using Beautiful Soup.\n3. Download and save the comic image to the hard drive with iter_content() .\n4. Find the URL of the Previous Comic link, and repeat.\n\nOpen a new file editor tab and save it as downloadXkcd.py .\n\nIf you open the browser\u2019s developer tools and inspect the elements on the page, you\u2019ll find the following:\n\n* The URL of the comic\u2019s image file is given by the href attribute of an <img> element.\n* The <img> element is inside a <div id=\"comic\"> element.\n* The Prev button has a rel HTML attribute with the value prev .\n* The first comic\u2019s Prev button links to the https://xkcd.com/# URL, indicating that there are no more previous pages.\n\nMake your code look like the following:\n\n#! python3 # downloadXkcd.py - Downloads every single XKCD comic. import requests, os, bs4 url = 'https://xkcd.com'\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# starting url os.makedirs('xkcd', exist_ok=True)\u00a0\u00a0\u00a0\u00a0# store comics in ./xkcd while not url.endswith('#'): # TODO: Download the page. # TODO: Find the URL of the comic image. # TODO: Download the image. # TODO: Save the image to ./xkcd. # TODO: Get the Prev button's url. print('Done.')\n\nYou\u2019ll have a url variable that starts with the value 'https://xkcd.com' and repeatedly update it (in a for loop) with the URL of the current page\u2019s Prev link. At every step in the loop, you\u2019ll download the comic at url . You\u2019ll know to end the loop when url ends with '#' .\n\nYou will download the image files to a folder in the current working directory named xkcd . The call os.makedirs() ensures that this folder exists, and the exist_ok=True keyword argument prevents the function from throwing an exception if this folder already exists. The remaining code is just comments that outline the rest of your program.\n\nLet\u2019s implement the code for downloading the page. Make your code look like the following:\n\n#! python3 # downloadXkcd.py - Downloads every single XKCD comic. import requests, os, bs4 url = 'https://xkcd.com'\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# starting url os.makedirs('xkcd', exist_ok=True)\u00a0\u00a0\u00a0\u00a0# store comics in ./xkcd while not url.endswith('#'): # Download the page. print('Downloading page %s...' % url) res = requests.get(url) res.raise_for_status() soup = bs4.BeautifulSoup(res.text, 'html.parser') # TODO: Find the URL of the comic image. # TODO: Download the image. # TODO: Save the image to ./xkcd. # TODO: Get the Prev button's url. print('Done.')\n\nFirst, print url so that the user knows which URL the program is about to download; then use the requests module\u2019s request.get() function to download it. As always, you immediately call the Response object\u2019s raise_for_status() method to throw an exception and end the program if something went wrong with the download. Otherwise, you create a BeautifulSoup object from the text of the downloaded page.\n\nMake your code look like the following:\n\n#! python3 # downloadXkcd.py - Downloads every single XKCD comic. import requests, os, bs4 -- snip -- # Find the URL of the comic image. comicElem = soup.select('#comic img') if comicElem == []: print('Could not find comic image.') else: comicUrl = 'https:' + comicElem[0].get('src') # Download the image. print('Downloading image %s...' % (comicUrl)) res = requests.get(comicUrl) res.raise_for_status() # TODO: Save the image to ./xkcd. # TODO: Get the Prev button's url. print('Done.')\n\nFrom inspecting the XKCD home page with your developer tools, you know that the <img> element for the comic image is inside a <div> element with the id attribute set to comic , so the selector '#comic img' will get you the correct <img> element from the BeautifulSoup object.\n\nA few XKCD pages have special content that isn\u2019t a simple image file. That\u2019s fine; you\u2019ll just skip those. If your selector doesn\u2019t find any elements, then soup.select('#comic img') will return a blank list. When that happens, the program can just print an error message and move on without downloading the image.\n\nOtherwise, the selector will return a list containing one <img> element. You can get the src attribute from this <img> element and pass it to requests.get() to download the comic\u2019s image file.\n\nMake your code look like the following:\n\n#! python3 # downloadXkcd.py - Downloads every single XKCD comic. import requests, os, bs4 -- snip -- # Save the image to ./xkcd. imageFile = open(os.path.join('xkcd', os.path.basename(comicUrl)), 'wb') for chunk in res.iter_content(100000): imageFile.write(chunk) imageFile.close() # Get the Prev button's url. prevLink = soup.select('a[rel=\"prev\"]')[0] url = 'https://xkcd.com' + prevLink.get('href') print('Done.')\n\nAt this point, the image file of the comic is stored in the res variable. You need to write this image data to a file on the hard drive.\n\nYou\u2019ll need a filename for the local image file to pass to open() . The comicUrl will have a value like 'https://imgs.xkcd.com/comics/heartbleed_explanation.png' \u2014which you might have noticed looks a lot like a file path. And in fact, you can call os.path.basename() with comicUrl , and it will return just the last part of the URL, 'heartbleed_explanation.png' . You can use this as the filename when saving the image to your hard drive. You join this name with the name of your xkcd folder using os.path.join() so that your program uses backslashes ( \\ ) on Windows and forward slashes ( / ) on macOS and Linux. Now that you finally have the filename, you can call open() to open a new file in 'wb' \u201cwrite binary\u201d mode.\n\nRemember from earlier in this chapter that to save files you\u2019ve downloaded using requests , you need to loop over the return value of the iter_content() method. The code in the for loop writes out chunks of the image data (at most 100,000 bytes each) to the file and then you close the file. The image is now saved to your hard drive.\n\nAfterward, the selector 'a[rel=\"prev\"]' identifies the <a> element with the rel attribute set to prev , and you can use this <a> element\u2019s href attribute to get the previous comic\u2019s URL, which gets stored in url . Then the while loop begins the entire download process again for this comic.\n\nThe output of this program will look like this:\n\nDownloading page https://xkcd.com... Downloading image https://imgs.xkcd.com/comics/phone_alarm.png... Downloading page https://xkcd.com/1358/... Downloading image https://imgs.xkcd.com/comics/nro.png... Downloading page https://xkcd.com/1357/... Downloading image https://imgs.xkcd.com/comics/free_speech.png... Downloading page https://xkcd.com/1356/... Downloading image https://imgs.xkcd.com/comics/orbital_mechanics.png... Downloading page https://xkcd.com/1355/... Downloading image https://imgs.xkcd.com/comics/airplane_message.png... Downloading page https://xkcd.com/1354/... Downloading image https://imgs.xkcd.com/comics/heartbleed_explanation.png... -- snip --\n\nThis project is a good example of a program that can automatically follow links in order to scrape large amounts of data from the web. You can learn about Beautiful Soup\u2019s other features from its documentation at https://www.crummy.com/software/BeautifulSoup/bs4/doc/ .\n\nDownloading pages and following links are the basis of many web crawling programs. Similar programs could also do the following:\n\n* Back up an entire site by following all of its links.\n* Copy all the messages off a web forum.\n* Duplicate the catalog of items for sale on an online store.\n\nThe requests and bs4 modules are great as long as you can figure out the URL you need to pass to requests.get() . However, sometimes this isn\u2019t so easy to find. Or perhaps the website you want your program to navigate requires you to log in first. The selenium module will give your programs the power to perform such sophisticated tasks.", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "Provide a guide on 'Controlling the Browser with the selenium Module' in Python.", "input": "", "output": "The selenium module lets Python directly control the browser by programmatically clicking links and filling in login information, almost as though there were a human user interacting with the page. Using selenium , you can interact with web pages in a much more advanced way than with requests and bs4 ; but because it launches a web browser, it is a bit slower and hard to run in the background if, say, you just need to download some files from the web.\n\nStill, if you need to interact with a web page in a way that, say, depends on the JavaScript code that updates the page, you\u2019ll need to use selenium instead of requests . That\u2019s because major ecommerce websites such as Amazon almost certainly have software systems to recognize traffic that they suspect is a script harvesting their info or signing up for multiple free accounts. These sites may refuse to serve pages to you after a while, breaking any scripts you\u2019ve made. The selenium module is much more likely to function on these sites long-term than requests .\n\nA major \u201ctell\u201d to websites that you\u2019re using a script is the user-agent string, which identifies the web browser and is included in all HTTP requests. For example, the user-agent string for the requests module is something like 'python-requests/2.21.0' . You can visit a site such as https://www.whatsmyua.info/ to see your user-agent string. Using selenium , you\u2019re much more likely to \u201cpass for human\u201d because not only is Selenium\u2019s user-agent is the same as a regular browser (for instance, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0' ), but it has the same traffic patterns: a selenium -controlled browser will download images, advertisements, cookies, and privacy-invading trackers just like a regular browser. However, selenium can still be detected by websites, and major ticketing and ecommerce websites often block browsers controlled by selenium to prevent web scraping of their pages.\n\nThe following examples will show you how to control Firefox\u2019s web browser. If you don\u2019t already have Firefox, you can download it for free from https://getfirefox.com/ . You can install selenium by running pip install --user selenium from a command line terminal. More information is available in Appendix A.\n\nImporting the modules for selenium is slightly tricky. Instead of import selenium , you need to run from selenium import webdriver . (The exact reason why the selenium module is set up this way is beyond the scope of this book.) After that, you can launch the Firefox browser with selenium . Enter the following into the interactive shell:\n\n>>> from selenium import webdriver >>> browser = webdriver.Firefox() >>> type(browser) <class 'selenium.webdriver.firefox.webdriver.WebDriver'> >>> browser.get('https://inventwithpython.com')\n\nYou\u2019ll notice when webdriver.Firefox() is called, the Firefox web browser starts up. Calling type() on the value webdriver.Firefox() reveals it\u2019s of the WebDriver data type. And calling browser.get('https://inventwithpython.com') directs the browser to https://inventwithpython.com/ . Your browser should look something like Figure 12-7.\n\nFigure 12-7: After we call webdriver.Firefox() and get() in Mu, the Firefox browser appears.\n\nIf you encounter the error message \u201c'geckodriver' executable needs to be in PATH .\u201d, then you need to manually download the webdriver for Firefox before you can use selenium to control it. You can also control browsers other than Firefox if you install the webdriver for them.\n\nFor Firefox, go to https://github.com/mozilla/geckodriver/releases and download the geckodriver for your operating system. (\u201cGecko\u201d is the name of the browser engine used in Firefox.) For example, on Windows you\u2019ll want to download the geckodriver-v0.24.0-win64.zip link, and on macOS, you\u2019ll want the geckodriver-v0.24.0-macos.tar.gz link. Newer versions will have slightly different links. The downloaded ZIP file will contain a geckodriver.exe (on Windows) or geckodriver (on macOS and Linux) file that you can put on your system PATH . Appendix B has information about the system PATH , or you can learn more at https://stackoverflow.com/q/40208051/1893164 .\n\nFor Chrome, go to https://sites.google.com/a/chromium.org/chromedriver/downloads and download the ZIP file for your operating system. This ZIP file will contain a chromedriver.exe (on Windows) or chromedriver (on macOS or Linux) file that you can put on your system PATH .\n\nOther major web browsers also have webdrivers available, and you can often find these by performing an internet search for \u201c<browser name> webdriver\u201d.\n\nIf you still have problems opening up a new browser under the control of selenium , it may be because the current version of the browser is incompatible with the selenium module. One workaround is to install an older version of the web browser\u2014or, more simply, an older version of the selenium module. You can find the list of selenium version numbers at https://pypi.org/project/selenium/#history . Unfortunately, the compatibility between versions of selenium and a browser sometimes breaks, and you may need to search the web for possible solutions. Appendix A has more information about running pip to install a specific version of selenium . (For example, you might run pip install --user -U selenium==3.14.1 .)\n\nWebDriver objects have quite a few methods for finding elements on a page. They are divided into the find_element_* and find_elements_* methods. The find_element_* methods return a single WebElement object, representing the first element on the page that matches your query. The find_elements_* methods return a list of WebElement_* objects for every matching element on the page.\n\nTable 12-3 shows several examples of find_element_* and find_elements_* methods being called on a WebDriver object that\u2019s stored in the variable browser .\n\nTable 12-3: Selenium\u2019s WebDriver Methods for Finding Elements\n\nExcept for the *_by_tag_name() methods, the arguments to all the methods are case sensitive. If no elements exist on the page that match what the method is looking for, the selenium module raises a NoSuchElement exception. If you do not want this exception to crash your program, add try and except statements to your code.\n\nOnce you have the WebElement object, you can find out more about it by reading the attributes or calling the methods in Table 12-4.\n\nTable 12-4: WebElement Attributes and Methods\n\nFor example, open a new file editor tab and enter the following program:\n\nfrom selenium import webdriver browser = webdriver.Firefox() browser.get('https://inventwithpython.com') try: elem = browser.find_element_by_class_name(' cover-thumb') print('Found <%s> element with that class name!' % (elem.tag_name)) except: print('Was not able to find an element with that name.')\n\nHere we open Firefox and direct it to a URL. On this page, we try to find elements with the class name 'bookcover' , and if such an element is found, we print its tag name using the tag_name attribute. If no such element was found, we print a different message.\n\nThis program will output the following:\n\nFound <img> element with that class name!\n\nWe found an element with the class name 'bookcover' and the tag name 'img' .\n\nWebElement objects returned from the find_element_* and find_elements_* methods have a click() method that simulates a mouse click on that element. This method can be used to follow a link, make a selection on a radio button, click a Submit button, or trigger whatever else might happen when the element is clicked by the mouse. For example, enter the following into the interactive shell:\n\n>>> from selenium import webdriver >>> browser = webdriver.Firefox() >>> browser.get('https://inventwithpython.com') >>> linkElem = browser.find_element_by_link_text('Read Online for Free') >>> type(linkElem) <class 'selenium.webdriver.remote.webelement.FirefoxWebElement'> >>> linkElem.click() # follows the \"Read Online for Free\" link\n\nThis opens Firefox to https://inventwithpython.com/ , gets the WebElement object for the <a> element with the text Read It Online , and then simulates clicking that <a> element. It\u2019s just like if you clicked the link yourself; the browser then follows that link.\n\nSending keystrokes to text fields on a web page is a matter of finding the <input> or <textarea> element for that text field and then calling the send_keys() method. For example, enter the following into the interactive shell:\n\n>>> from selenium import webdriver >>> browser = webdriver.Firefox() >>> browser.get('https://login.metafilter.com') >>> userElem = browser.find_element_by_id('user_name) >>> userElem.send_keys(' your_real_username_here ') >>> passwordElem = browser.find_element_by_id('user_pass') >>> passwordElem.send_keys(' your_real_password_here ') >>> passwordElem.submit()\n\nAs long as login page for MetaFilter hasn\u2019t changed the id of the Username and Password text fields since this book was published, the previous code will fill in those text fields with the provided text. (You can always use the browser\u2019s inspector to verify the id .) Calling the submit() method on any element will have the same result as clicking the Submit button for the form that element is in. (You could have just as easily called emailElem.submit() , and the code would have done the same thing.)\n\nThe selenium module has a module for keyboard keys that are impossible to type into a string value, which function much like escape characters. These values are stored in attributes in the selenium.webdriver.common.keys module. Since that is such a long module name, it\u2019s much easier to run from selenium.webdriver.common.keys import Keys at the top of your program; if you do, then you can simply write Keys anywhere you\u2019d normally have to write selenium.webdriver.common.keys . Table 12-5 lists the commonly used Keys variables.\n\nTable 12-5: Commonly Used Variables in the selenium.webdriver.common.keys Module\n\nFor example, if the cursor is not currently in a text field, pressing the HOME and END keys will scroll the browser to the top and bottom of the page, respectively. Enter the following into the interactive shell, and notice how the send_keys() calls scroll the page:\n\n>>> from selenium import webdriver >>> from selenium.webdriver.common.keys import Keys >>> browser = webdriver.Firefox() >>> browser.get('https://nostarch.com') >>> htmlElem = browser.find_element_by_tag_name('html') >>> htmlElem.send_keys(Keys.END) # scrolls to bottom >>> htmlElem.send_keys(Keys.HOME) # scrolls to top\n\nThe <html > tag is the base tag in HTML files: the full content of the HTML file is enclosed within the <html> and </html> tags. Calling browser.find_element_by_tag_name('html') is a good place to send keys to the general web page. This would be useful if, for example, new content is loaded once you\u2019ve scrolled to the bottom of the page.\n\nThe selenium module can simulate clicks on various browser buttons as well through the following methods:\n\nbrowser.back() Clicks the Back button.\n\nbrowser.forward() Clicks the Forward button.\n\nbrowser.refresh() Clicks the Refresh/Reload button.\n\nbrowser.quit() Clicks the Close Window button.\n\nSelenium can do much more beyond the functions described here. It can modify your browser\u2019s cookies, take screenshots of web pages, and run custom JavaScript. To learn more about these features, you can visit the selenium documentation at https://selenium-python.readthedocs.org/ .", "source": "https://automatetheboringstuff.com/2e/chapter12/", "category": "12WEB SCRAPING"}
{"instruction": "Explain the concept of '13WORKING WITH EXCEL SPREADSHEETS' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Although we don\u2019t often think of spreadsheets as programming tools, almost everyone uses them to organize information into two-dimensional data structures, perform calculations with formulas, and produce output as charts. In the next two chapters, we\u2019ll integrate Python into two popular spreadsheet applications: Microsoft Excel and Google Sheets.\n\nExcel is a popular and powerful spreadsheet application for Windows. The openpyxl module allows your Python programs to read and modify Excel spreadsheet files. For example, you might have the boring task of copying certain data from one spreadsheet and pasting it into another one. Or you might have to go through thousands of rows and pick out just a handful of them to make small edits based on some criteria. Or you might have to look through hundreds of spreadsheets of department budgets, searching for any that are in the red. These are exactly the sort of boring, mindless spreadsheet tasks that Python can do for you.\n\nAlthough Excel is proprietary software from Microsoft, there are free alternatives that run on Windows, macOS, and Linux. Both LibreOffice Calc and OpenOffice Calc work with Excel\u2019s .xlsx file format for spreadsheets, which means the openpyxl module can work on spreadsheets from these applications as well. You can download the software from https://www.libreoffice.org/ and https://www.openoffice.org/ , respectively. Even if you already have Excel installed on your computer, you may find these programs easier to use. The screenshots in this chapter, however, are all from Excel 2010 on Windows 10.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "What is 'Excel Documents' and how does it work in Python?", "input": "", "output": "First, let\u2019s go over some basic definitions: an Excel spreadsheet document is called a workbook . A single workbook is saved in a file with the .xlsx extension. Each workbook can contain multiple sheets (also called worksheets ). The sheet the user is currently viewing (or last viewed before closing Excel) is called the active sheet .\n\nEach sheet has columns (addressed by letters starting at A ) and rows (addressed by numbers starting at 1). A box at a particular column and row is called a cell . Each cell can contain a number or text value. The grid of cells with data makes up a sheet.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "How do I use 'Installing the openpyxl Module' in Python?", "input": "", "output": "Python does not come with OpenPyXL, so you\u2019ll have to install it. Follow the instructions for installing third-party modules in Appendix A; the name of the module is openpyxl .\n\nThis book uses version 2.6.2 of OpenPyXL. It\u2019s important that you install this version by running pip install --user -U openpyxl==2.6.2 because newer versions of OpenPyXL are incompatible with the information in this book. To test whether it is installed correctly, enter the following into the interactive shell:\n\n>>> import openpyxl\n\nIf the module was correctly installed, this should produce no error messages. Remember to import the openpyxl module before running the interactive shell examples in this chapter, or you\u2019ll get a NameError: name 'openpyxl' is not defined error.\n\nYou can find the full documentation for OpenPyXL at https://openpyxl.readthedocs.org/ .", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "How do I use 'Reading Excel Documents' in Python?", "input": "", "output": "The examples in this chapter will use a spreadsheet named example.xlsx stored in the root folder. You can either create the spreadsheet yourself or download it from https://nostarch.com/automatestuff2/ . Figure 13-1 shows the tabs for the three default sheets named Sheet1 , Sheet2 , and Sheet3 that Excel automatically provides for new workbooks. (The number of default sheets created may vary between operating systems and spreadsheet programs.)\n\nFigure 13-1: The tabs for a workbook\u2019s sheets are in the lower-left corner of Excel.\n\nSheet 1 in the example file should look like Table 13-1. (If you didn\u2019t download example.xlsx from the website, you should enter this data into the sheet yourself.)\n\nTable 13-1: The example.xlsx Spreadsheet\n\nNow that we have our example spreadsheet, let\u2019s see how we can manipulate it with the openpyxl module.\n\nOnce you\u2019ve imported the openpyxl module, you\u2019ll be able to use the openpyxl.load_workbook() function. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> type(wb) <class 'openpyxl.workbook.workbook.Workbook'>\n\nThe openpyxl.load_workbook() function takes in the filename and returns a value of the workbook data type. This Workbook object represents the Excel file, a bit like how a File object represents an opened text file.\n\nRemember that example.xlsx needs to be in the current working directory in order for you to work with it. You can find out what the current working directory is by importing os and using os.getcwd() , and you can change the current working directory using os.chdir() .\n\nYou can get a list of all the sheet names in the workbook by accessing the sheetnames attribute. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> wb.sheetnames # The workbook's sheets' names. ['Sheet1', 'Sheet2', 'Sheet3'] >>> sheet = wb['Sheet3'] # Get a sheet from the workbook. >>> sheet <Worksheet \"Sheet3\"> >>> type(sheet) <class 'openpyxl.worksheet.worksheet.Worksheet'> >>> sheet.title # Get the sheet's title as a string. 'Sheet3' >>> anotherSheet = wb.active # Get the active sheet. >>> anotherSheet <Worksheet \"Sheet1\">\n\nEach sheet is represented by a Worksheet object, which you can obtain by using the square brackets with the sheet name string like a dictionary key. Finally, you can use the active attribute of a Workbook object to get the workbook\u2019s active sheet. The active sheet is the sheet that\u2019s on top when the workbook is opened in Excel. Once you have the Worksheet object, you can get its name from the title attribute.\n\nOnce you have a Worksheet object, you can access a Cell object by its name. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> sheet = wb['Sheet1'] # Get a sheet from the workbook. >>> sheet['A1'] # Get a cell from the sheet. <Cell 'Sheet1'.A1> >>> sheet['A1'].value # Get the value from the cell. datetime.datetime(2015, 4, 5, 13, 34, 2) >>> c = sheet['B1'] # Get another cell from the sheet. >>> c.value 'Apples' >>> # Get the row, column, and value from the cell. >>> 'Row %s, Column %s is %s' % (c.row, c.column, c.value) 'Row 1, Column B is Apples' >>> 'Cell %s is %s' % (c.coordinate, c.value) 'Cell B1 is Apples' >>> sheet['C1'].value 73\n\nThe Cell object has a value attribute that contains, unsurprisingly, the value stored in that cell. Cell objects also have row , column , and coordinate attributes that provide location information for the cell.\n\nHere, accessing the value attribute of our Cell object for cell B1 gives us the string 'Apples' . The row attribute gives us the integer 1 , the column attribute gives us 'B' , and the coordinate attribute gives us 'B1' .\n\nOpenPyXL will automatically interpret the dates in column A and return them as datetime values rather than strings. The datetime data type is explained further in Chapter 17.\n\nSpecifying a column by letter can be tricky to program, especially because after column Z, the columns start by using two letters: AA, AB, AC, and so on. As an alternative, you can also get a cell using the sheet\u2019s cell() method and passing integers for its row and column keyword arguments. The first row or column integer is 1 , not 0 . Continue the interactive shell example by entering the following:\n\n>>> sheet.cell(row=1, column=2) <Cell 'Sheet1'.B1> >>> sheet.cell(row=1, column=2).value 'Apples' >>> for i in range(1, 8, 2): # Go through every other row: ...\u00a0\u00a0\u00a0\u00a0\u00a0print(i, sheet.cell(row=i, column=2).value) ... 1 Apples 3 Pears 5 Apples 7 Strawberries\n\nAs you can see, using the sheet\u2019s cell() method and passing it row=1 and column=2 gets you a Cell object for cell B1 , just like specifying sheet['B1'] did. Then, using the cell() method and its keyword arguments, you can write a for loop to print the values of a series of cells.\n\nSay you want to go down column B and print the value in every cell with an odd row number. By passing 2 for the range() function\u2019s \u201cstep\u201d parameter, you can get cells from every second row (in this case, all the odd-numbered rows). The for loop\u2019s i variable is passed for the row keyword argument to the cell() method, while 2 is always passed for the column keyword argument. Note that the integer 2 , not the string 'B' , is passed.\n\nYou can determine the size of the sheet with the Worksheet object\u2019s max_row and max_column attributes. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> sheet = wb['Sheet1'] >>> sheet.max_row # Get the highest row number. 7 >>> sheet.max_column # Get the highest column number. 3\n\nNote that the max_column attribute is an integer rather than the letter that appears in Excel.\n\nTo convert from letters to numbers, call the openpyxl.utils.column_index_from_string() function. To convert from numbers to letters, call the openpyxl.utils.get_column_letter() function. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> from openpyxl.utils import get_column_letter, column_index_from_string >>> get_column_letter(1) # Translate column 1 to a letter. 'A' >>> get_column_letter(2 ) 'B' >>> get_column_letter(27) 'AA' >>> get_column_letter(900) 'AHP' >>> wb = openpyxl.load_workbook('example.xlsx') >>> sheet = wb['Sheet1'] >>> get_column_letter(sheet.max_column) 'C' >>> column_index_from_string('A') # Get A's number. 1 >>> column_index_from_string('AA') 27\n\nAfter you import these two functions from the openpyxl.utils module, you can call get_column_letter() and pass it an integer like 27 to figure out what the letter name of the 27th column is. The function column_index_string() does the reverse: you pass it the letter name of a column, and it tells you what number that column is. You don\u2019t need to have a workbook loaded to use these functions. If you want, you can load a workbook, get a Worksheet object, and use a Worksheet attribute like max_column to get an integer. Then, you can pass that integer to get_column_letter() .\n\nYou can slice Worksheet objects to get all the Cell objects in a row, column, or rectangular area of the spreadsheet. Then you can loop over all the cells in the slice. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> sheet = wb['Sheet1'] >>> tuple(sheet['A1':'C3']) # Get all cells from A1 to C3. ((<Cell 'Sheet1'.A1>, <Cell 'Sheet1'.B1>, <Cell 'Sheet1'.C1>), (<Cell 'Sheet1'.A2>, <Cell 'Sheet1'.B2>, <Cell 'Sheet1'.C2>), (<Cell 'Sheet1'.A3>, <Cell 'Sheet1'.B3>, <Cell 'Sheet1'.C3>)) \u278a >>> for rowOfCellObjects in sheet['A1':'C3']: \u278b ...\u00a0\u00a0\u00a0\u00a0\u00a0for cellObj in rowOfCellObjects: ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print(cellObj.coordinate, cellObj.value) ...\u00a0\u00a0\u00a0\u00a0\u00a0print('--- END OF ROW ---') A1 2015-04-05 13:34:02 B1 Apples C1 73 --- END OF ROW --- A2 2015-04-05 03:41:23 B2 Cherries C2 85 --- END OF ROW --- A3 2015-04-06 12:46:51 B3 Pears C3 14 --- END OF ROW ---\n\nHere, we specify that we want the Cell objects in the rectangular area from A1 to C3, and we get a Generator object containing the Cell objects in that area. To help us visualize this Generator object, we can use tuple() on it to display its Cell objects in a tuple.\n\nThis tuple contains three tuples: one for each row, from the top of the desired area to the bottom. Each of these three inner tuples contains the Cell objects in one row of our desired area, from the leftmost cell to the right. So overall, our slice of the sheet contains all the Cell objects in the area from A1 to C3, starting from the top-left cell and ending with the bottom-right cell.\n\nTo print the values of each cell in the area, we use two for loops. The outer for loop goes over each row in the slice \u278a . Then, for each row, the nested for loop goes through each cell in that row \u278b .\n\nTo access the values of cells in a particular row or column, you can also use a Worksheet object\u2019s rows and columns attribute. These attributes must be converted to lists with the list() function before you can use the square brackets and an index with them. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> sheet = wb.active >>> list(sheet.columns)[1] # Get second column's cells. (<Cell 'Sheet1'.B1>, <Cell 'Sheet1'.B2>, <Cell 'Sheet1'.B3>, <Cell 'Sheet1'. B4>, <Cell 'Sheet1'.B5>, <Cell 'Sheet1'.B6>, <Cell 'Sheet1'.B7>) >>> for cellObj in list(sheet.columns)[1]: print(cellObj.value) Apples Cherries Pears Oranges Apples Bananas Strawberries\n\nUsing the rows attribute on a Worksheet object will give you a tuple of tuples. Each of these inner tuples represents a row, and contains the Cell objects in that row. The columns attribute also gives you a tuple of tuples, with each of the inner tuples containing the Cell objects in a particular column. For example.xlsx , since there are 7 rows and 3 columns, rows gives us a tuple of 7 tuples (each containing 3 Cell objects), and columns gives us a tuple of 3 tuples (each containing 7 Cell objects).\n\nTo access one particular tuple, you can refer to it by its index in the larger tuple. For example, to get the tuple that represents column B, you use list(sheet.columns)[1] . To get the tuple containing the Cell objects in column A, you\u2019d use list(sheet.columns)[0] . Once you have a tuple representing one row or column, you can loop through its Cell objects and print their values.\n\nAs a quick review, here\u2019s a rundown of all the functions, methods, and data types involved in reading a cell out of a spreadsheet file:\n\n1. Import the openpyxl module.\n2. Call the openpyxl.load_workbook() function.\n3. Get a Workbook object.\n4. Use the active or sheetnames attributes.\n5. Get a Worksheet object.\n6. Use indexing or the cell() sheet method with row and column keyword arguments.\n7. Get a Cell object.\n8. Read the Cell object\u2019s value attribute.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "How do I use 'Project: Reading Data from a Spreadsheet' in Python?", "input": "", "output": "Say you have a spreadsheet of data from the 2010 US Census and you have the boring task of going through its thousands of rows to count both the total population and the number of census tracts for each county. (A census tract is simply a geographic area defined for the purposes of the census.) Each row represents a single census tract. We\u2019ll name the spreadsheet file censuspopdata.xlsx , and you can download it from https://nostarch.com/automatestuff2/ . Its contents look like Figure 13-2.\n\nFigure 13-2: The censuspopdata.xlsx spreadsheet\n\nEven though Excel can calculate the sum of multiple selected cells, you\u2019d still have to select the cells for each of the 3,000-plus counties. Even if it takes just a few seconds to calculate a county\u2019s population by hand, this would take hours to do for the whole spreadsheet.\n\nIn this project, you\u2019ll write a script that can read from the census spreadsheet file and calculate statistics for each county in a matter of seconds.\n\nThis is what your program does:\n\n1. Reads the data from the Excel spreadsheet\n2. Counts the number of census tracts in each county\n3. Counts the total population of each county\n4. Prints the results\n\nThis means your code will need to do the following:\n\n1. Open and read the cells of an Excel document with the openpyxl module.\n2. Calculate all the tract and population data and store it in a data structure.\n3. Write the data structure to a text file with the .py extension using the pprint module.\n\nThere is just one sheet in the censuspopdata.xlsx spreadsheet, named 'Population by Census Tract' , and each row holds the data for a single census tract. The columns are the tract number (A), the state abbreviation (B), the county name (C), and the population of the tract (D).\n\nOpen a new file editor tab and enter the following code. Save the file as readCensusExcel.py .\n\n#! python3 # readCensusExcel.py - Tabulates population and number of census tracts for # each county. \u278a import openpyxl, pprint print('Opening workbook...') \u278b wb = openpyxl.load_workbook('censuspopdata.xlsx') \u278c sheet = wb['Population by Census Tract'] countyData = {} # TODO: Fill in countyData with each county's population and tracts. print('Reading rows...') \u278d for row in range(2, sheet.max_row + 1): # Each row in the spreadsheet has data for one census tract. state\u00a0\u00a0= sheet['B' + str(row)].value county = sheet['C' + str(row)].value pop\u00a0\u00a0\u00a0\u00a0= sheet['D' + str(row)].value # TODO: Open a new text file and write the contents of countyData to it.\n\nThis code imports the openpyxl module, as well as the pprint module that you\u2019ll use to print the final county data \u278a . Then it opens the censuspopdata.xlsx file \u278b , gets the sheet with the census data \u278c , and begins iterating over its rows \u278d .\n\nNote that you\u2019ve also created a variable named countyData , which will contain the populations and number of tracts you calculate for each county. Before you can store anything in it, though, you should determine exactly how you\u2019ll structure the data inside it.\n\nThe data structure stored in countyData will be a dictionary with state abbreviations as its keys. Each state abbreviation will map to another dictionary, whose keys are strings of the county names in that state. Each county name will in turn map to a dictionary with just two keys, 'tracts' and 'pop' . These keys map to the number of census tracts and population for the county. For example, the dictionary will look similar to this:\n\n{'AK': {'Aleutians East': {'pop': 3141, 'tracts': 1}, 'Aleutians West': {'pop': 5561, 'tracts': 2}, 'Anchorage': {'pop': 291826, 'tracts': 55}, 'Bethel': {'pop': 17013, 'tracts': 3}, 'Bristol Bay': {'pop': 997, 'tracts': 1}, -- snip --\n\nIf the previous dictionary were stored in countyData , the following expressions would evaluate like this:\n\n>>> countyData['AK']['Anchorage']['pop'] 291826 >>> countyData['AK']['Anchorage']['tracts'] 55\n\nMore generally, the countyData dictionary\u2019s keys will look like this:\n\ncountyData[ state abbrev ][ county ]['tracts'] countyData[ state abbrev ][ county ]['pop']\n\nNow that you know how countyData will be structured, you can write the code that will fill it with the county data. Add the following code to the bottom of your program:\n\n#! python 3 # readCensusExcel.py - Tabulates population and number of census tracts for # each county. -- snip -- for row in range(2, sheet.max_row + 1): # Each row in the spreadsheet has data for one census tract. state\u00a0\u00a0= sheet['B' + str(row)].value county = sheet['C' + str(row)].value pop\u00a0\u00a0\u00a0\u00a0= sheet['D' + str(row)].value # Make sure the key for this state exists. \u278a countyData.setdefault(state, {}) # Make sure the key for this county in this state exists. \u278b countyData[state].setdefault(county, {'tracts': 0, 'pop': 0}) # Each row represents one census tract, so increment by one. \u278c countyData[state][county]['tracts'] += 1 # Increase the county pop by the pop in this census tract. \u278d countyData[state][county]['pop'] += int(pop) # TODO: Open a new text file and write the contents of countyData to it.\n\nThe last two lines of code perform the actual calculation work, incrementing the value for tracts \u278c and increasing the value for pop \u278d for the current county on each iteration of the for loop.\n\nThe other code is there because you cannot add a county dictionary as the value for a state abbreviation key until the key itself exists in countyData . (That is, countyData['AK']['Anchorage']['tracts'] += 1 will cause an error if the ' AK' key doesn\u2019t exist yet.) To make sure the state abbreviation key exists in your data structure, you need to call the setdefault() method to set a value if one does not already exist for state \u278a .\n\nJust as the countyData dictionary needs a dictionary as the value for each state abbreviation key, each of those dictionaries will need its own dictionary as the value for each county key \u278b . And each of those dictionaries in turn will need keys 'tracts' and 'pop' that start with the integer value 0 . (If you ever lose track of the dictionary structure, look back at the example dictionary at the start of this section.)\n\nSince setdefault() will do nothing if the key already exists, you can call it on every iteration of the for loop without a problem.\n\nAfter the for loop has finished, the countyData dictionary will contain all of the population and tract information keyed by county and state. At this point, you could program more code to write this to a text file or another Excel spreadsheet. For now, let\u2019s just use the pprint.pformat() function to write the countyData dictionary value as a massive string to a file named census2010.py . Add the following code to the bottom of your program (making sure to keep it unindented so that it stays outside the for loop):\n\n#! python 3 # readCensusExcel.py - Tabulates population and number of census tracts for # each county. -- snip -- for row in range(2, sheet.max_row + 1): -- snip -- # Open a new text file and write the contents of countyData to it. print('Writing results...') resultFile = open('census2010.py', 'w') resultFile.write('allData = ' + pprint.pformat(countyData)) resultFile.close() print('Done.')\n\nThe pprint.pformat() function produces a string that itself is formatted as valid Python code. By outputting it to a text file named census2010.py , you\u2019ve generated a Python program from your Python program! This may seem complicated, but the advantage is that you can now import census2010.py just like any other Python module. In the interactive shell, change the current working directory to the folder with your newly created census2010.py file and then import it:\n\n>>> import os >>> import census2010 >>> census2010.allData['AK']['Anchorage'] {'pop': 291826, 'tracts': 55} >>> anchoragePop = census2010.allData['AK']['Anchorage']['pop'] >>> print('The 2010 population of Anchorage was ' + str(anchoragePop)) The 2010 population of Anchorage was 291826\n\nThe readCensusExcel.py program was throwaway code: once you have its results saved to census2010.py , you won\u2019t need to run the program again. Whenever you need the county data, you can just run import census2010 .\n\nCalculating this data by hand would have taken hours; this program did it in a few seconds. Using OpenPyXL, you will have no trouble extracting information that is saved to an Excel spreadsheet and performing calculations on it. You can download the complete program from https://nostarch.com/automatestuff2/ .\n\nMany businesses and offices use Excel to store various types of data, and it\u2019s not uncommon for spreadsheets to become large and unwieldy. Any program that parses an Excel spreadsheet has a similar structure: it loads the spreadsheet file, preps some variables or data structures, and then loops through each of the rows in the spreadsheet. Such a program could do the following:\n\n* Compare data across multiple rows in a spreadsheet.\n* Open multiple Excel files and compare data between spreadsheets.\n* Check whether a spreadsheet has blank rows or invalid data in any cells and alert the user if it does.\n* Read data from a spreadsheet and use it as the input for your Python programs.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "Explain the concept of 'Writing Excel Documents' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "OpenPyXL also provides ways of writing data, meaning that your programs can create and edit spreadsheet files. With Python, it\u2019s simple to create spreadsheets with thousands of rows of data.\n\nCall the openpyxl.Workbook() function to create a new, blank Workbook object. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() # Create a blank workbook. >>> wb.sheetnames # It starts with one sheet. ['Sheet'] >>> sheet = wb.active >>> sheet.title 'Sheet' >>> sheet.title = 'Spam Bacon Eggs Sheet' # Change title. >>> wb.sheetnames ['Spam Bacon Eggs Sheet']\n\nThe workbook will start off with a single sheet named Sheet . You can change the name of the sheet by storing a new string in its title attribute.\n\nAny time you modify the Workbook object or its sheets and cells, the spreadsheet file will not be saved until you call the save() workbook method. Enter the following into the interactive shell (with example.xlsx in the current working directory):\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('example.xlsx') >>> sheet = wb.active >>> sheet.title = 'Spam Spam Spam' >>> wb.save('example_copy.xlsx') # Save the workbook.\n\nHere, we change the name of our sheet. To save our changes, we pass a filename as a string to the save() method. Passing a different filename than the original, such as 'example_copy.xlsx' , saves the changes to a copy of the spreadsheet.\n\nWhenever you edit a spreadsheet you\u2019ve loaded from a file, you should always save the new, edited spreadsheet to a different filename than the original. That way, you\u2019ll still have the original spreadsheet file to work with in case a bug in your code caused the new, saved file to have incorrect or corrupt data.\n\nSheets can be added to and removed from a workbook with the create_sheet() method and del operator. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() >>> wb.sheetnames ['Sheet'] >>> wb.create_sheet() # Add a new sheet. <Worksheet \"Sheet1\"> >>> wb.sheetnames ['Sheet', 'Sheet1'] >>> # Create a new sheet at index 0. >>> wb.create_sheet(index=0, title='First Sheet') <Worksheet \"First Sheet\"> >>> wb.sheetnames ['First Sheet', 'Sheet', 'Sheet1'] >>> wb.create_sheet(index=2, title='Middle Sheet') <Worksheet \"Middle Sheet\"> >>> wb.sheetnames ['First Sheet', 'Sheet', 'Middle Sheet', 'Sheet1']\n\nThe create_sheet() method returns a new Worksheet object named Sheet X , which by default is set to be the last sheet in the workbook. Optionally, the index and name of the new sheet can be specified with the index and title keyword arguments.\n\nContinue the previous example by entering the following:\n\n>>> wb.sheetnames ['First Sheet', 'Sheet', 'Middle Sheet', 'Sheet1'] >>> del wb['Middle Sheet'] >>> del wb['Sheet1'] >>> wb.sheetnames ['First Sheet', 'Sheet']\n\nYou can use the del operator to delete a sheet from a workbook, just like you can use it to delete a key-value pair from a dictionary.\n\nRemember to call the save() method to save the changes after adding sheets to or removing sheets from the workbook.\n\nWriting values to cells is much like writing values to keys in a dictionary. Enter this into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() >>> sheet = wb['Sheet'] >>> sheet['A1'] = 'Hello, world!' # Edit the cell's value. >>> sheet['A1'].value 'Hello, world!'\n\nIf you have the cell\u2019s coordinate as a string, you can use it just like a dictionary key on the Worksheet object to specify which cell to write to.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "Provide a guide on 'Project: Updating a Spreadsheet' in Python.", "input": "", "output": "In this project, you\u2019ll write a program to update cells in a spreadsheet of produce sales. Your program will look through the spreadsheet, find specific kinds of produce, and update their prices. Download this spreadsheet from https://nostarch.com/automatestuff2/ . Figure 13-3 shows what the spreadsheet looks like.\n\nFigure 13-3: A spreadsheet of produce sales\n\nEach row represents an individual sale. The columns are the type of produce sold (A), the cost per pound of that produce (B), the number of pounds sold (C), and the total revenue from the sale (D). The TOTAL column is set to the Excel formula =ROUND(B3*C3, 2) , which multiplies the cost per pound by the number of pounds sold and rounds the result to the nearest cent. With this formula, the cells in the TOTAL column will automatically update themselves if there is a change in column B or C.\n\nNow imagine that the prices of garlic, celery, and lemons were entered incorrectly, leaving you with the boring task of going through thousands of rows in this spreadsheet to update the cost per pound for any garlic, celery, and lemon rows. You can\u2019t do a simple find-and-replace for the price, because there might be other items with the same price that you don\u2019t want to mistakenly \u201ccorrect.\u201d For thousands of rows, this would take hours to do by hand. But you can write a program that can accomplish this in seconds.\n\nYour program does the following:\n\n1. Loops over all the rows\n2. If the row is for garlic, celery, or lemons, changes the price\n\nThis means your code will need to do the following:\n\n1. Open the spreadsheet file.\n2. For each row, check whether the value in column A is Celery , Garlic , or Lemon .\n3. If it is, update the price in column B.\n4. Save the spreadsheet to a new file (so that you don\u2019t lose the old spreadsheet, just in case).\n\nThe prices that you need to update are as follows:\n\nCelery\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.19\n\nGarlic\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.07\n\nLemon\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.27\n\nYou could write code like this:\n\nif produceName == 'Celery': cellObj = 1.19 if produceName == 'Garlic': cellObj = 3.07 if produceName == 'Lemon': cellObj = 1.27\n\nHaving the produce and updated price data hardcoded like this is a bit inelegant. If you needed to update the spreadsheet again with different prices or different produce, you would have to change a lot of the code. Every time you change code, you risk introducing bugs.\n\nA more flexible solution is to store the corrected price information in a dictionary and write your code to use this data structure. In a new file editor tab, enter the following code:\n\n#! python3 # updateProduce.py - Corrects costs in produce sales spreadsheet. import openpyxl wb = openpyxl.load_workbook('produceSales.xlsx') sheet = wb['Sheet'] # The produce types and their updated prices PRICE_UPDATES = {'Garlic': 3.07, 'Celery': 1.19, 'Lemon': 1.27} # TODO: Loop through the rows and update the prices.\n\nSave this as updateProduce.py . If you need to update the spreadsheet again, you\u2019ll need to update only the PRICE_UPDATES dictionary, not any other code.\n\nThe next part of the program will loop through all the rows in the spreadsheet. Add the following code to the bottom of updateProduce.py :\n\n#! python3 # updateProduce.py - Corrects costs in produce sales spreadsheet. -- snip -- # Loop through the rows and update the prices. \u278a for rowNum in range(2, sheet.max_row):\u00a0\u00a0\u00a0\u00a0# skip the first row \u278b produceName = sheet.cell(row=rowNum, column=1).value \u278c if produceName in PRICE_UPDATES: sheet.cell(row=rowNum, column=2).value = PRICE_UPDATES[produceName] \u278d wb.save('updatedProduceSales.xlsx')\n\nWe loop through the rows starting at row 2, since row 1 is just the header \u278a . The cell in column 1 (that is, column A) will be stored in the variable produceName \u278b . If produceName exists as a key in the PRICE_UPDATES dictionary \u278c , then you know this is a row that must have its price corrected. The correct price will be in PRICE_UPDATES[produceName] .\n\nNotice how clean using PRICE_UPDATES makes the code. Only one if statement, rather than code like if produceName == 'Garlic': , is necessary for every type of produce to update. And since the code uses the PRICE_UPDATES dictionary instead of hardcoding the produce names and updated costs into the for loop, you modify only the PRICE_UPDATES dictionary and not the code if the produce sales spreadsheet needs additional changes.\n\nAfter going through the entire spreadsheet and making changes, the code saves the Workbook object to updatedProduceSales.xlsx \u278d . It doesn\u2019t overwrite the old spreadsheet just in case there\u2019s a bug in your program and the updated spreadsheet is wrong. After checking that the updated spreadsheet looks right, you can delete the old spreadsheet.\n\nYou can download the complete source code for this program from https://nostarch.com/automatestuff2/ .\n\nSince many office workers use Excel spreadsheets all the time, a program that can automatically edit and write Excel files could be really useful. Such a program could do the following:\n\n* Read data from one spreadsheet and write it to parts of other spreadsheets.\n* Read data from websites, text files, or the clipboard and write it to a spreadsheet.\n* Automatically \u201cclean up\u201d data in spreadsheets. For example, it could use regular expressions to read multiple formats of phone numbers and edit them to a single, standard format.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "How do I use 'Setting the Font Style of Cells' in Python?", "input": "", "output": "Styling certain cells, rows, or columns can help you emphasize important areas in your spreadsheet. In the produce spreadsheet, for example, your program could apply bold text to the potato, garlic, and parsnip rows. Or perhaps you want to italicize every row with a cost per pound greater than $5. Styling parts of a large spreadsheet by hand would be tedious, but your programs can do it instantly.\n\nTo customize font styles in cells, important, import the Font() function from the openpyxl.styles module.\n\nfrom openpyxl.styles import Font\n\nThis allows you to type Font() instead of openpyxl.styles.Font() . (See \u201cImporting Modules\u201d on page 47 to review this style of import statement.)\n\nHere\u2019s an example that creates a new workbook and sets cell A1 to have a 24-point, italicized font. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> from openpyxl.styles import Font >>> wb = openpyxl.Workbook() >>> sheet = wb['Sheet'] \u278a >>> italic24Font = Font(size=24, italic=True) # Create a font. \u278b >>> sheet['A1'].font = italic24Font # Apply the font to A1. >>> sheet['A1'] = 'Hello, world!' >>> wb.save('styles.xlsx')\n\nIn this example, Font(size=24, italic=True) returns a Font object, which is stored in italic24Font \u278a . The keyword arguments to Font() , size and italic , configure the Font object\u2019s styling information. And when sheet['A1'].font is assigned the italic24Font object \u278b , all that font styling information gets applied to cell A1.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "Explain the concept of 'Font Objects' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "To set font attributes, you pass keyword arguments to Font() . Table 13-2 shows the possible keyword arguments for the Font() function.\n\nTable 13-2: Keyword Arguments for Font Objects\n\nYou can call Font() to create a Font object and store that Font object in a variable. You then assign that variable to a Cell object\u2019s font attribute. For example, this code creates various font styles:\n\n>>> import openpyxl >>> from openpyxl.styles import Font >>> wb = openpyxl.Workbook() >>> sheet = wb['Sheet'] >>> fontObj1 = Font(name='Times New Roman', bold=True) >>> sheet['A1'].font = fontObj1 >>> sheet['A1'] = 'Bold Times New Roman' >>> fontObj2 = Font(size=24, italic=True) >>> sheet['B3'].font = fontObj2 >>> sheet['B3'] = '24 pt Italic' >>> wb.save('styles.xlsx')\n\nHere, we store a Font object in fontObj1 and then set the A1 Cell object\u2019s font attribute to fontObj1 . We repeat the process with another Font object to set the font of a second cell. After you run this code, the styles of the A1 and B3 cells in the spreadsheet will be set to custom font styles, as shown in Figure 13-4.\n\nFigure 13-4: A spreadsheet with custom font styles\n\nFor cell A1, we set the font name to 'Times New Roman' and set bold to true , so our text appears in bold Times New Roman. We didn\u2019t specify a size, so the openpyxl default, 11, is used. In cell B3, our text is italic, with a size of 24; we didn\u2019t specify a font name, so the openpyxl default, Calibri, is used.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "Explain the concept of 'Formulas' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Excel formulas, which begin with an equal sign, can configure cells to contain values calculated from other cells. In this section, you\u2019ll use the openpyxl module to programmatically add formulas to cells, just like any normal value. For example:\n\n>>> sheet['B9'] = '=SUM(B1:B8)'\n\nThis will store =SUM(B1:B8) as the value in cell B9. This sets the B9 cell to a formula that calculates the sum of values in cells B1 to B8. You can see this in action in Figure 13-5.\n\nFigure 13-5: Cell B9 contains the formula =SUM(B1:B8), which adds the cells B1 to B8.\n\nAn Excel formula is set just like any other text value in a cell. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() >>> sheet = wb.active >>> sheet['A1'] = 200 >>> sheet['A2'] = 300 >>> sheet['A3'] = '=SUM(A1:A2)' # Set the formula. >>> wb.save('writeFormula.xlsx')\n\nThe cells in A1 and A2 are set to 200 and 300, respectively. The value in cell A3 is set to a formula that sums the values in A1 and A2. When the spreadsheet is opened in Excel, A3 will display its value as 500.\n\nExcel formulas offer a level of programmability for spreadsheets but can quickly become unmanageable for complicated tasks. For example, even if you\u2019re deeply familiar with Excel formulas, it\u2019s a headache to try to decipher what =IFERROR(TRIM(IF(LEN(VLOOKUP(F7, Sheet2!$A$1:$B$10000, 2, FALSE))>0,SUBSTITUTE(VLOOKUP(F7, Sheet2!$A$1:$B$10000, 2, FALSE), \" \", \"\"),\"\")), \"\") actually does. Python code is much more readable.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "How do I use 'Adjusting Rows and Columns' in Python?", "input": "", "output": "In Excel, adjusting the sizes of rows and columns is as easy as clicking and dragging the edges of a row or column header. But if you need to set a row or column\u2019s size based on its cells\u2019 contents or if you want to set sizes in a large number of spreadsheet files, it will be much quicker to write a Python program to do it.\n\nRows and columns can also be hidden entirely from view. Or they can be \u201cfrozen\u201d in place so that they are always visible on the screen and appear on every page when the spreadsheet is printed (which is handy for headers).\n\nWorksheet objects have row_dimensions and column_dimensions attributes that control row heights and column widths. Enter this into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() >>> sheet = wb.active >>> sheet['A1'] = 'Tall row' >>> sheet['B2'] = 'Wide column' >>> # Set the height and width: >>> sheet.row_dimensions[1].height = 70 >>> sheet.column_dimensions['B'].width = 20 >>> wb.save('dimensions.xlsx')\n\nA sheet\u2019s row_dimensions and column_dimensions are dictionary-like values; row_dimensions contains RowDimension objects and column_dimensions contains ColumnDimension objects. In row_dimensions , you can access one of the objects using the number of the row (in this case, 1 or 2). In column_dimensions , you can access one of the objects using the letter of the column (in this case, A or B).\n\nThe dimensions.xlsx spreadsheet looks like Figure 13-6.\n\nFigure 13-6: Row 1 and column B set to larger heights and widths\n\nOnce you have the RowDimension object, you can set its height. Once you have the ColumnDimension object, you can set its width. The row height can be set to an integer or float value between 0 and 409 . This value represents the height measured in points , where one point equals 1/72 of an inch. The default row height is 12.75. The column width can be set to an integer or float value between 0 and 255 . This value represents the number of characters at the default font size (11 point) that can be displayed in the cell. The default column width is 8.43 characters. Columns with widths of 0 or rows with heights of 0 are hidden from the user.\n\nA rectangular area of cells can be merged into a single cell with the merge_cells() sheet method. Enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() >>> sheet = wb.active >>> sheet.merge_cells('A1:D3') # Merge all these cells. >>> sheet['A1'] = 'Twelve cells merged together.' >>> sheet.merge_cells('C5:D5') # Merge these two cells. >>> sheet['C5'] = 'Two merged cells.' >>> wb.save('merged.xlsx')\n\nThe argument to merge_cells() is a single string of the top-left and bottom-right cells of the rectangular area to be merged: 'A1:D3' merges 12 cells into a single cell. To set the value of these merged cells, simply set the value of the top-left cell of the merged group.\n\nWhen you run this code, merged.xlsx will look like Figure 13-7.\n\nFigure 13-7: Merged cells in a spreadsheet\n\nTo unmerge cells, call the unmerge_cells() sheet method. Enter this into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('merged.xlsx') >>> sheet = wb.active >>> sheet.unmerge_cells('A1:D3') # Split these cells up. >>> sheet.unmerge_cells('C5:D5') >>> wb.save('merged.xlsx')\n\nIf you save your changes and then take a look at the spreadsheet, you\u2019ll see that the merged cells have gone back to being individual cells.\n\nFor spreadsheets too large to be displayed all at once, it\u2019s helpful to \u201cfreeze\u201d a few of the top rows or leftmost columns onscreen. Frozen column or row headers, for example, are always visible to the user even as they scroll through the spreadsheet. These are known as freeze panes . In OpenPyXL, each Worksheet object has a freeze_panes attribute that can be set to a Cell object or a string of a cell\u2019s coordinates. Note that all rows above and all columns to the left of this cell will be frozen, but the row and column of the cell itself will not be frozen.\n\nTo unfreeze all panes, set freeze_panes to None or 'A1' . Table 13-3 shows which rows and columns will be frozen for some example settings of freeze_panes .\n\nTable 13-3: Frozen Pane Examples\n\nMake sure you have the produce sales spreadsheet from https://nostarch.com/automatestuff2/ . Then enter the following into the interactive shell:\n\n>>> import openpyxl >>> wb = openpyxl.load_workbook('produceSales.xlsx') >>> sheet = wb.active >>> sheet.freeze_panes = 'A2' # Freeze the rows above A2. >>> wb.save('freezeExample.xlsx')\n\nIf you set the freeze_panes attribute to 'A2' , row 1 will always be viewable, no matter where the user scrolls in the spreadsheet. You can see this in Figure 13-8.\n\nFigure 13-8: With freeze_panes set to 'A2' , row 1 is always visible, even as the user scrolls down.", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "How do I use 'Charts' in Python?", "input": "", "output": "OpenPyXL supports creating bar, line, scatter, and pie charts using the data in a sheet\u2019s cells. To make a chart, you need to do the following:\n\n1. Create a Reference object from a rectangular selection of cells.\n2. Create a Series object by passing in the Reference object.\n3. Create a Chart object.\n4. Append the Series object to the Chart object.\n5. Add the Chart object to the Worksheet object, optionally specifying which cell should be the top-left corner of the chart.\n\nThe Reference object requires some explaining. You create Reference objects by calling the openpyxl.chart.Reference() function and passing three arguments:\n\n1. The Worksheet object containing your chart data.\n2. A tuple of two integers, representing the top-left cell of the rectangular selection of cells containing your chart data: the first integer in the tuple is the row, and the second is the column. Note that 1 is the first row, not 0 .\n3. A tuple of two integers, representing the bottom-right cell of the rectangular selection of cells containing your chart data: the first integer in the tuple is the row, and the second is the column.\n\nFigure 13-9 shows some sample coordinate arguments.\n\nFigure 13-9: From left to right: (1, 1), (10, 1) ; (3, 2), (6, 4) ; (5, 3), (5, 3)\n\nEnter this interactive shell example to create a bar chart and add it to the spreadsheet:\n\n>>> import openpyxl >>> wb = openpyxl.Workbook() >>> sheet = wb.active >>> for i in range(1, 11): # create some data in column A ...\u00a0\u00a0\u00a0\u00a0\u00a0sheet['A' + str(i)] = i ... >>> refObj = openpyxl.chart.Reference(sheet, min_col=1, min_row=1, max_col=1, max_row=10) >>> seriesObj = openpyxl.chart.Series(refObj, title='First series') >>> chartObj = openpyxl.chart.BarChart() >>> chartObj.title = 'My Chart' >>> chartObj.append(seriesObj) >>> sheet.add_chart(chartObj, 'C5') >>> wb.save('sampleChart.xlsx')\n\nThis produces a spreadsheet that looks like Figure 13-10.\n\nFigure 13-10: A spreadsheet with a chart added\n\nWe\u2019ve created a bar chart by calling openpyxl.chart.BarChart() . You can also create line charts, scatter charts, and pie charts by calling openpyxl.charts.LineChart() , openpyxl.chart.ScatterChart() , and openpyxl.chart.PieChart() .", "source": "https://automatetheboringstuff.com/2e/chapter13/", "category": "13WORKING WITH EXCEL SPREADSHEETS"}
{"instruction": "Explain the concept of '14WORKING WITH GOOGLE SHEETS' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Google Sheets, the free, web-based spreadsheet application available to anyone with a Google account or Gmail address, has become a useful, feature-rich competitor to Excel. Google Sheets has its own API, but this API can be confusing to learn and use. This chapter covers the EZSheets third-party module, documented at https://ezsheets.readthedocs.io/ . While not as full featured as the official Google Sheets API, EZSheets makes common spreadsheet tasks easy to perform.", "source": "https://automatetheboringstuff.com/2e/chapter14/", "category": "14WORKING WITH GOOGLE SHEETS"}
{"instruction": "What is 'Installing and Setting Up EZSheets' and how does it work in Python?", "input": "", "output": "You can install EZSheets by opening a new terminal window and running pip install --user ezsheets . As part of this installation, EZSheets will also install the google-api-python-client , google-auth-httplib2 , and google-auth-oauthlib modules. These modules allow your program to log in to Google\u2019s servers and make API requests. EZSheets handles the interaction with these modules, so you don\u2019t need to concern yourself with how they work.\n\nBefore you can use EZSheets, you need to enable the Google Sheets and Google Drive APIs for your Google account. Visit the following web pages and click the Enable API buttons at the top of each:\n\n* https://console.developers.google.com/apis/library/sheets.googleapis.com/\n* https://console.developers.google.com/apis/library/drive.googleapis.com/\n\nYou\u2019ll also need to obtain three files, which you should save in the same folder as your .py Python script that uses EZSheets:\n\n* A credentials file named credentials-sheets.json\n* A token for Google Sheets named token-sheets.pickle\n* A token for Google Drive named token-drive.pickle\n\nThe credentials file will generate the token files. The easiest way to obtain a credentials file is to go to the Google Sheets Python Quickstart page at https://developers.google.com/sheets/api/quickstart/python/ and click the blue Enable the Google Sheets API button, as shown in Figure 14-1. You\u2019ll need to log in to your Google account to view this page.\n\nFigure 14-1: Obtaining a credentials.json file.\n\nClicking this button will bring up a window with a Download Client Configuration link that lets you download a credentials.json file. Rename this file to credentials-sheets.json and place it in the same folder as your Python scripts.\n\nOnce you have a credentials-sheets.json file, run the import ezsheets module. The first time you import the EZSheets module, it will open a new browser window for you to log in to your Google account. Click Allow , as shown in Figure 14-2.\n\nFigure 14-2: Allowing Quickstart to access your Google account\n\nThe message about Quickstart comes from the fact that you downloaded the credentials file from the Google Sheets Python Quickstart page. Note that this window will open twice : first for Google Sheets access and second for Google Drive access. EZSheets uses Google Drive access to upload, download, and delete spreadsheets.\n\nAfter you log in, the browser window will prompt you to close it, and the token-sheets.pickle and token-drive.pickle files will appear in the same folder as credentials-sheets.json . You only need to go through this process the first time you run import ezsheets .\n\nIf you encounter an error after clicking Allow and the page seems to hang, make sure you have first enabled the Google Sheets and Drive APIs from the links at the start of this section. It may take a few minutes for Google\u2019s servers to register this change, so you may have to wait before you can use EZSheets.\n\nDon\u2019t share the credential or token files with anyone\u2014treat them like passwords.\n\nIf you accidentally share the credential or token files with someone, they won\u2019t be able to change your Google account password, but they will have access to your spreadsheets. You can revoke these files by going to the Google Cloud Platform developer\u2019s console page at https://console.developers.google.com/ . You\u2019ll need to log in to your Google account to view this page. Click the Credentials link on the sidebar. Then click the trash can icon next to the credentials file you\u2019ve accidentally shared, as shown in Figure 14-3.\n\nFigure 14-3: The Credentials page in the Google Cloud Platform developer\u2019s console\n\nTo generate a new credentials file from this page, click the Create Credentials button and select OAuth client ID , also shown in Figure 14-3. Next, for Application Type, select Other and give the file any name you like. This new credentials file will then be listed on the page, and you can click on the download icon to download it. The downloaded file will have a long, complicated filename, so you should rename it to the default filename that EZSheets attempts to load: credentials-sheets.json . You can also generate a new credential file by clicking the Enable the Google Sheets API button mentioned in the previous section.", "source": "https://automatetheboringstuff.com/2e/chapter14/", "category": "14WORKING WITH GOOGLE SHEETS"}
{"instruction": "How do I use 'Spreadsheet Objects' in Python?", "input": "", "output": "In Google Sheets, a spreadsheet can contain multiple sheets (also called worksheets ), and each sheet contains columns and rows of values. Figure 14-4 shows a spreadsheet titled \u201cEducation Data\u201d containing three sheets titled \u201cStudents,\u201d \u201cClasses,\u201d and \u201cResources.\u201d The first column of each sheet is labeled A, and the first row is labeled 1.\n\nFigure 14-4: A spreadsheet titled \u201cEducation Data\u201d with three sheets\n\nWhile most of your work will involve modifying the Sheet objects, you can also modify Spreadsheet objects, as you\u2019ll see in the next section.\n\nYou can make a new Spreadsheet object from an existing spreadsheet, a blank spreadsheet, or an uploaded spreadsheet. To make a Spreadsheet object from an existing Google Sheets spreadsheet, you\u2019ll need the spreadsheet\u2019s ID string. The unique ID for a Google Sheets spreadsheet can be found in the URL, after the spreadsheets/d/ part and before the /edit part. For example, the spreadsheet featured in Figure 14-4 is located at the URL https://docs.google.com/spreadsheets/d/1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU/edit#gid=151537240/ , so its ID is 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU .\n\nPass your spreadsheet\u2019s ID as a string to the ezsheets.Spreadsheet() function to obtain a Spreadsheet object for its spreadsheet:\n\n>>> import ezsheets >>> ss = ezsheets.Spreadsheet(' 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU ') >>> ss Spreadsheet(spreadsheetId=' 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU ') >>> ss.title 'Education Data'\n\nFor convenience, you can also obtain a Spreadsheet object of an existing spreadsheet by passing the spreadsheet\u2019s full URL to the function. Or, if there is only one spreadsheet in your Google account with that title, you can pass the title of the spreadsheet as a string.\n\nTo make a new, blank spreadsheet, call the ezsheets.createSpreadsheet() function and pass it a string for the new spreadsheet\u2019s title. For example, enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss = ezsheets.createSpreadsheet(' Title of My New Spreadsheet ') >>> ss.title ' Title of My New Spreadsheet '\n\nTo upload an existing Excel, OpenOffice, CSV, or TSV spreadsheet to Google Sheets, pass the filename of the spreadsheet to ezsheets.upload() . Enter the following into the interactive shell, replacing my_spreadsheet.xlsx with a spreadsheet file of your own:\n\n>>> import ezsheets >>> ss = ezsheets.upload(' my_spreadsheet.xlsx ') >>> ss.title ' my_spreadsheet '\n\nYou can list the spreadsheets in your Google account by calling the listSpreadsheets() function. Enter the following into the interactive shell after uploading a spreadsheet:\n\n>>> ezsheets.listSpreadsheets() {' 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU ': 'Education Data'}\n\nThe listSpreadsheets() function returns a dictionary where the keys are spreadsheet IDs and the values are the titles of each spreadsheet.\n\nOnce you\u2019ve obtained a Spreadsheet object, you can use its attributes and methods to manipulate the online spreadsheet hosted on Google Sheets.\n\nWhile the actual data lives in a spreadsheet\u2019s individual sheets, the Spreadsheet object has the following attributes for manipulating the spreadsheet itself: title , spreadsheetId , url , sheetTitles , and sheets . Enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss = ezsheets.Spreadsheet(' 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU ') >>> ss.title # The title of the spreadsheet. 'Education Data' >>> ss.title = 'Class Data' # Change the title. >>> ss.spreadsheetId # The unique ID (this is a read-only attribute). '1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU' >>> ss.url # The original URL (this is a read-only attribute). 'https://docs.google.com/spreadsheets/d/ 1J-Jx6Ne2K_vqI9J2SO- TAXOFbxx_9tUjwnkPC22LjeU/ ' >>> ss.sheetTitles # The titles of all the Sheet objects ('Students', 'Classes', 'Resources') >>> ss.sheets # The Sheet objects in this Spreadsheet, in order. (<Sheet sheetId=0, title='Students', rowCount=1000, columnCount=26>, <Sheet sheetId=1669384683, title='Classes', rowCount=1000, columnCount=26>, <Sheet sheetId=151537240, title='Resources', rowCount=1000, columnCount=26>) >>> ss[0] # The first Sheet object in this Spreadsheet. <Sheet sheetId=0, title='Students', rowCount=1000, columnCount=26> >>> ss['Students'] # Sheets can also be accessed by title. <Sheet sheetId=0, title='Students', rowCount=1000, columnCount=26> >>> del ss[0] # Delete the first Sheet object in this Spreadsheet. >>> ss.sheetTitles # The \"Students\" Sheet object has been deleted: ('Classes', 'Resources')\n\nIf someone changes the spreadsheet through the Google Sheets website, your script can update the Spreadsheet object to match the online data by calling the refresh() method:\n\n>>> ss.refresh()\n\nThis will refresh not only the Spreadsheet object\u2019s attributes but also the data in the Sheet objects it contains. The changes you make to the Spreadsheet object will be reflected in the online spreadsheet in real time.\n\nYou can download a Google Sheets spreadsheet in a number of formats: Excel, OpenOffice, CSV, TSV, and PDF. You can also download it as a ZIP file containing HTML files of the spreadsheet\u2019s data. EZSheets contains functions for each of these options:\n\n>>> import ezsheets >>> ss = ezsheets.Spreadsheet(' 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU ') >>> ss.title 'Class Data' >>> ss.downloadAsExcel() # Downloads the spreadsheet as an Excel file. 'Class_Data.xlsx' >>> ss.downloadAsODS() # Downloads the spreadsheet as an OpenOffice file. 'Class_Data.ods' >>> ss.downloadAsCSV() # Only downloads the first sheet as a CSV file. 'Class_Data.csv' >>> ss.downloadAsTSV() # Only downloads the first sheet as a TSV file. 'Class_Data.tsv' >>> ss.downloadAsPDF() # Downloads the spreadsheet as a PDF. 'Class_Data.pdf' >>> ss.downloadAsHTML() # Downloads the spreadsheet as a ZIP of HTML files. 'Class_Data.zip'\n\nNote that files in the CSV and TSV formats can contain only one sheet; therefore, if you download a Google Sheets spreadsheet in this format, you will get the first sheet only. To download other sheets, you\u2019ll need to change the Sheet object\u2019s index attribute to 0 . See \u201cCreating and Deleting Sheets\u201d on page 341 for information on how to do this.\n\nThe download functions all return a string of the downloaded file\u2019s filename. You can also specify your own filename for the spreadsheet by passing the new filename to the download function:\n\n>>> ss.downloadAsExcel(' a_different_filename .xlsx') ' a_different_filename .xlsx'\n\nThe function should return the updated filename.\n\nTo delete a spreadsheet, call the delete() method:\n\n>>> import ezsheets >>> ss = ezsheets.createSpreadsheet('Delete me') # Create the spreadsheet. >>> ezsheets.listSpreadsheets() # Confirm that we've created a spreadsheet. {'1aCw2NNJSZblDbhygVv77kPsL3djmgV5zJZllSOZ_mRk': 'Delete me'} >>> ss.delete() # Delete the spreadsheet. >>> ezsheets.listSpreadsheets() {}\n\nThe delete() method will move your spreadsheet to the Trash folder on your Google Drive. You can view the contents of your Trash folder at https://drive.google.com/drive/trash . To permanently delete your spreadsheet, pass True for the permanent keyword argument:\n\n>>> ss.delete(permanent=True)\n\nIn general, permanently deleting your spreadsheets is not a good idea, because it would be impossible to recover a spreadsheet that a bug in your script accidentally deleted. Even free Google Drive accounts have gigabytes of storage available, so you most likely don\u2019t need to worry about freeing up space.", "source": "https://automatetheboringstuff.com/2e/chapter14/", "category": "14WORKING WITH GOOGLE SHEETS"}
{"instruction": "Explain the concept of 'Sheet Objects' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "A Spreadsheet object will have one or more Sheet objects. The Sheet objects represent the rows and columns of data in each sheet. You can access these sheets using the square brackets operator and an integer index. The Spreadsheet object\u2019s sheets attribute holds a tuple of Sheet objects in the order in which they appear in the spreadsheet. To access the Sheet objects in a spreadsheet, enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss = ezsheets.Spreadsheet(' 1J-Jx6Ne2K_vqI9J2SO-TAXOFbxx_9tUjwnkPC22LjeU ') >>> ss.sheets # The Sheet objects in this Spreadsheet, in order. (<Sheet sheetId=1669384683, title='Classes', rowCount=1000, columnCount=26>, <Sheet sheetId=151537240, title='Resources', rowCount=1000, columnCount=26>) >>> ss.sheets[0] # Gets the first Sheet object in this Spreadsheet. <Sheet sheetId=1669384683, title='Classes', rowCount=1000, columnCount=26> >>> ss[0] # Also gets the first Sheet object in this Spreadsheet. <Sheet sheetId=1669384683, title='Classes', rowCount=1000, columnCount=26>\n\nYou can also obtain a Sheet object with the square brackets operator and a string of the sheet\u2019s name. The Spreadsheet object\u2019s sheetTitles attribute holds a tuple of all the sheet titles. For example, enter the following into the interactive shell:\n\n>>> ss.sheetTitles # The titles of all the Sheet objects in this Spreadsheet. ('Classes', 'Resources') >>> ss['Classes'] # Sheets can also be accessed by title. <Sheet sheetId=1669384683, title='Classes', rowCount=1000, columnCount=26>\n\nOnce you have a Sheet object, you can read data from and write data to it using the Sheet object\u2019s methods, as explained in the next section.\n\nJust as in Excel, Google Sheets worksheets have columns and rows of cells containing data. You can use the square brackets operator to read and write data from and to these cells. For example, to create a new spreadsheet and add data to it, enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss = ezsheets.createSpreadsheet('My Spreadsheet') >>> sheet = ss[0] # Get the first sheet in this spreadsheet. >>> sheet.title 'Sheet1' >>> sheet = ss[0] >>> sheet['A1'] = 'Name' # Set the value in cell A1. >>> sheet['B1'] = 'Age' >>> sheet['C1'] = 'Favorite Movie' >>> sheet['A1'] # Read the value in cell A1. 'Name' >>> sheet['A2'] # Empty cells return a blank string. '' >>> sheet[2, 1] # Column 2, Row 1 is the same address as B1. 'Age' >>> sheet['A2'] = 'Alice' >>> sheet['B2'] = 30 >>> sheet['C2'] = 'RoboCop'\n\nThese instructions should produce a Google Sheets spreadsheet that looks like Figure 14-5.\n\nFigure 14-5: The spreadsheet created with the example instructions\n\nMultiple users can update a sheet simultaneously. To refresh the local data in the Sheet object, call its refresh() method:\n\n>>> sheet.refresh()\n\nAll of the data in the Sheet object is loaded when the Spreadsheet object is first loaded, so the data is read instantly. However, writing values to the online spreadsheet requires a network connection and can take about a second. If you have thousands of cells to update, updating them one at a time might be quite slow.\n\nCell addressing works in Google Sheets just like in Excel. The only difference is that, unlike Python\u2019s 0-based list indexes, Google Sheets have 1-based columns and rows: the first column or row is at index 1, not 0. You can convert the 'A2' string-style address to the (column, row) tuple-style address (and vice versa) with the convertAddress() function. The getColumnLetterOf() and getColumnNumberOf() functions will also convert a column address between letters and numbers. Enter the following into the interactive shell:\n\n>>> import ezsheets >>> ezsheets.convertAddress('A2') # Converts addresses... (1, 2) >>> ezsheets.convertAddress(1, 2) # ...and converts them back, too. 'A2' >>> ezsheets.getColumnLetterOf(2) 'B' >>> ezsheets.getColumnNumberOf('B') 2 >>> ezsheets.getColumnLetterOf(999) 'ALK' >>> ezsheets.getColumnNumberOf('ZZZ') 18278\n\nThe 'A2' string-style addresses are convenient if you\u2019re typing addresses into your source code. But the (column, row) tuple-style addresses are convenient if you\u2019re looping over a range of addresses and need a numeric form for the column. The convertAddress() , getColumnLetterOf() , and getColumnNumberOf() functions are helpful when you need to convert between the two formats.\n\nAs mentioned, writing data one cell at a time can often take too long. Fortunately, EZSheets has Sheet methods for reading and writing entire columns and rows at the same time. The getColumn() , getRow() , updateColumn() , and updateRow() methods will, respectively, read and write columns and rows. These methods make requests to the Google Sheets servers to update the spreadsheet, so they require that you be connected to the internet. In this section\u2019s example, we\u2019ll upload produceSales.xlsx from the last chapter to Google Sheets. The first eight rows look like Table 14-1.\n\nTable 14-1: The First Eight Rows of the produceSales.xlsx Spreadsheet\n\nTo upload this spreadsheet, enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss = ezsheets.upload('produceSales.xlsx') >>> sheet = ss[0] >>> sheet.getRow(1) # The first row is row 1, not row 0. ['PRODUCE', 'COST PER POUND', 'POUNDS SOLD', 'TOTAL', '', ''] >>> sheet.getRow(2) ['Potatoes', '0.86', '21.6', '18.58', '', ''] >>> columnOne = sheet.getColumn(1) >>> sheet.getColumn(1) ['PRODUCE', 'Potatoes', 'Okra', 'Fava beans', 'Watermelon', 'Garlic', --snip-- >>> sheet.getColumn('A') # Same result as getColumn(1) ['PRODUCE', 'Potatoes', 'Okra', 'Fava beans', 'Watermelon', 'Garlic', --snip-- >>> sheet.getRow(3) ['Okra', '2.26', '38.6', '87.24', '', ''] >>> sheet.updateRow(3, ['Pumpkin', '11.50', '20', '230']) >>> sheet.getRow(3) ['Pumpkin', '11.50', '20', '230', '', ''] >>> columnOne = sheet.getColumn(1) >>> for i, value in enumerate(columnOne): ...\u00a0\u00a0\u00a0\u00a0\u00a0# Make the Python list contain uppercase strings: ... columnOne[i] = value.upper() ... >>> sheet.updateColumn(1, columnOne) # Update the entire column in one request.\n\nThe getRow() and getColumn() functions retrieve the data from every cell in a specific row or column as a list of values. Note that empty cells become blank string values in the list. You can pass getColumn() either a column number or letter to tell it to retrieve a specific column\u2019s data. The previous example shows that getColumn(1) and getColumn('A') return the same list.\n\nThe updateRow() and updateColumn() functions will overwrite all the data in the row or column, respectively, with the list of values passed to the function. In this example, the third row initially contains information about okra, but the updateRow() call replaces it with data about pumpkin. Call sheet.getRow(3) again to view the new values in the third row.\n\nNext, let\u2019s update the \u201cproduceSales\u201d spreadsheet. Updating cells one at a time is slow if you have many cells to update. Getting a column or row as a list, updating the list, and then updating the entire column or row with the list is much faster, since all the changes can be made in one request.\n\nTo get all of the rows at once, call the getRows() method to return a list of lists. The inner lists inside the outer list each represent a single row of the sheet. You can modify the values in this data structure to change the produce name, pounds sold, and total cost of some of the rows. Then you pass it to the updateRows() method by entering the following into the interactive shell:\n\n>>> rows = sheet.getRows() # Get every row in the spreadsheet. >>> rows[0] # Examine the values in the first row. ['PRODUCE', 'COST PER POUND', 'POUNDS SOLD', 'TOTAL', '', ''] >>> rows[1] ['POTATOES', '0.86', '21.6', '18.58', '', ''] >>> rows[1][0] = 'PUMPKIN' # Change the produce name. >>> rows[1] ['PUMPKIN', '0.86', '21.6', '18.58', '', ''] >>> rows[10] ['OKRA', '2.26', '40', '90.4', '', ''] >>> rows[10][2] = '400' # Change the pounds sold. >>> rows[10][3] = '904' # Change the total. >>> rows[10] ['OKRA', '2.26', '400', '904', '', ''] >>> sheet.updateRows(rows) # Update the online spreadsheet with the changes.\n\nYou can update the entire sheet in a single request by passing updateRows() the list of lists returned from getRows() , amended with the changes made to rows 1 and 10.\n\nNote that the rows in the Google Sheet have empty strings at the end. This is because the uploaded sheet has a column count of 6 , but we have only 4 columns of data. You can read the number of rows and columns in a sheet with the rowCount and columnCount attributes. Then by setting these values, you can change the size of the sheet.\n\n>>> sheet.rowCount # The number of rows in the sheet. 23758 >>> sheet.columnCount # The number of columns in the sheet. 6 >>> sheet.columnCount = 4 # Change the number of columns to 4. >>> sheet.columnCount # Now the number of columns in the sheet is 4. 4\n\nThese instructions should delete the fifth and sixth columns of the \u201cproduceSales\u201d spreadsheet, as shown in Figure 14-6.\n\nFigure 14-6: The sheet before (left) and after (right) changing the column count to 4\n\nAccording to https://support.google.com/drive/answer/37603?hl=en/ , Google Sheets spreadsheets can have up to 5 million cells in them. However, it\u2019s a good idea to make sheets only as big as you need to minimize the time it takes to update and refresh the data.\n\nAll Google Sheets spreadsheets start with a single sheet named \u201cSheet1.\u201d You can add additional sheets to the end of the list of sheets with the createSheet() method, to which you pass a string to use as the new sheet\u2019s title. An optional second argument can specify the integer index of the new sheet. To create a spreadsheet and then add new sheets to it, enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss = ezsheets.createSpreadsheet('Multiple Sheets') >>> ss.sheetTitles ('Sheet1',) >>> ss.createSheet('Spam') # Create a new sheet at the end of the list of sheets. <Sheet sheetId=2032744541, title='Spam', rowCount=1000, columnCount=26> >>> ss.createSheet('Eggs') # Create another new sheet. <Sheet sheetId=417452987, title='Eggs', rowCount=1000, columnCount=26> >>> ss.sheetTitles ('Sheet1', 'Spam', 'Eggs') >>> ss.createSheet('Bacon', 0) code># Create a sheet at index 0 in the list of sheets. <Sheet sheetId=814694991, title='Bacon', rowCount=1000, columnCount=26> >>> ss.sheetTitles ('Bacon', 'Sheet1', 'Spam', 'Eggs')\n\nThese instructions add three new sheets to the spreadsheet: \u201cBacon,\u201d \u201cSpam,\u201d and \u201cEggs\u201d (in addition to the default \u201cSheet1\u201d). The sheets in a spreadsheet are ordered, and new sheets go to the end of the list unless you pass a second argument to createSheet() specifying the sheet\u2019s index. Here, you create the sheet titled \u201cBacon\u201d at index 0 , making \u201cBacon\u201d the first sheet in the spreadsheet and displacing the other three sheets by one position. This is similar to the behavior of the insert() list method.\n\nYou can see the new sheets on the tabs at the bottom of the screen, as shown in Figure 14-7.\n\nFigure 14-7: The \u201cMultiple Sheets\u201d spreadsheet after adding sheets \u201cSpam,\u201d \u201cEggs,\u201d and \u201cBacon\u201d\n\nThe Sheet object\u2019s delete() method will delete the sheet from the spreadsheet. If you want to keep the sheet but delete the data it contains, call the clear() method to clear all the cells and make it a blank sheet. Enter the following into the interactive shell:\n\n>>> ss.sheetTitles ('Bacon', 'Sheet1', 'Spam', 'Eggs') >>> ss[0].delete() # Delete the sheet at index 0: the \"Bacon\" sheet. >>> ss.sheetTitles ('Sheet1', 'Spam', 'Eggs') >>> ss['Spam'].delete() # Delete the \"Spam\" sheet. >>> ss.sheetTitles ('Sheet1', 'Eggs') >>> sheet = ss['Eggs'] # Assign a variable to the \"Eggs\" sheet. >>> sheet.delete() # Delete the \"Eggs\" sheet. >>> ss.sheetTitles ('Sheet1',) >>> ss[0].clear() # Clear all the cells on the \"Sheet1\" sheet. >>> ss.sheetTitles # The \"Sheet1\" sheet is empty but still exists. ('Sheet1',)\n\nDeleting sheets is permanent; there\u2019s no way to recover the data. However, you can back up sheets by copying them to another spreadsheet with the copyTo() method, as explained in the next section.\n\nEvery Spreadsheet object has an ordered list of the Sheet objects it contains, and you can use this list to reorder the sheets (as shown in the previous section) or copy them to other spreadsheets. To copy a Sheet object to another Spreadsheet object, call the copyTo() method. Pass it the destination Spreadsheet object as an argument. To create two spreadsheets and copy the first spreadsheet\u2019s data to the other sheet, enter the following into the interactive shell:\n\n>>> import ezsheets >>> ss1 = ezsheets.createSpreadsheet('First Spreadsheet') >>> ss2 = ezsheets.createSpreadsheet('Second Spreadsheet') >>> ss1[0] <Sheet sheetId=0, title='Sheet1', rowCount=1000, columnCount=26> >>> ss1[0].updateRow(1, ['Some', 'data', 'in', 'the', 'first', 'row']) >>> ss1[0].copyTo(ss2) # Copy the ss1's Sheet1 to the ss2 spreadsheet. >>> ss2.sheetTitles # ss2 now contains a copy of ss1's Sheet1. ('Sheet1', 'Copy of Sheet1')\n\nNote that since the destination spreadsheet ( ss2 in the previous example) already had a sheet named Sheet1 , the copied sheet will be named Copy of Sheet1 . Copied sheets appear at the end of the list of the destination spreadsheet\u2019s sheets. If you wish, you can change their index attribute to reorder them in the new spreadsheet.", "source": "https://automatetheboringstuff.com/2e/chapter14/", "category": "14WORKING WITH GOOGLE SHEETS"}
{"instruction": "How do I use 'Working with Google Sheets Quotas' in Python?", "input": "", "output": "Because Google Sheets is online, it\u2019s easy to share sheets among multiple users who can all access the sheets simultaneously. However, this also means that reading and updating the sheets will be slower than reading and updating Excel files stored locally on your hard drive. In addition, Google Sheets has limits on how many read and write operations you can perform.\n\nAccording to Google\u2019s developer guidelines, users are restricted to creating 250 new spreadsheets a day, and free Google accounts can perform 100 read and 100 write requests per 100 seconds. Attempting to exceed this quota will raise the googleapiclient.errors.HttpError \u201cQuota exceeded for quota group\u201d exception. EZSheets will automatically catch this exception and retry the request. When this happens, the function calls to read or write data will take several seconds (or even a full minute or two) before they return. If the request continues to fail (which is possible if another script using the same credentials is also making requests), EZSheets will re-raise this exception.\n\nThis means that, on occasion, your EZSheets method calls may take several seconds before they return. If you want to view your API usage or increase your quota, go to the IAM & Admin Quotas page at https://console.developers.google.com/quotas/ to learn about paying for increased usage. If you\u2019d rather just deal with the HttpError exceptions yourself, you can set ezsheets.IGNORE_QUOTA to True , and EZSheet\u2019s methods will raise these exceptions when it encounters them.", "source": "https://automatetheboringstuff.com/2e/chapter14/", "category": "14WORKING WITH GOOGLE SHEETS"}
{"instruction": "How do I use '15WORKING WITH PDF AND WORD DOCUMENTS' in Python?", "input": "", "output": "PDF and Word documents are binary files, which makes them much more complex than plaintext files. In addition to text, they store lots of font, color, and layout information. If you want your programs to read or write to PDFs or Word documents, you\u2019ll need to do more than simply pass their filenames to open() .\n\nFortunately, there are Python modules that make it easy for you to interact with PDFs and Word documents. This chapter will cover two such modules: PyPDF2 and Python-Docx.", "source": "https://automatetheboringstuff.com/2e/chapter15/", "category": "15WORKING WITH PDF AND WORD DOCUMENTS"}
{"instruction": "What is 'PDF Documents' and how does it work in Python?", "input": "", "output": "PDF stands for Portable Document Format and uses the .pdf file extension. Although PDFs support many features, this chapter will focus on the two things you\u2019ll be doing most often with them: reading text content from PDFs and crafting new PDFs from existing documents.\n\nThe module you\u2019ll use to work with PDFs is PyPDF2 version 1.26.0. It\u2019s important that you install this version because future versions of PyPDF2 may be incompatible with the code. To install it, run pip install --user PyPDF2==1.26.0 from the command line. This module name is case sensitive, so make sure the y is lowercase and everything else is uppercase. (Check out Appendix A for full details about installing third-party modules.) If the module was installed correctly, running import PyPDF2 in the interactive shell shouldn\u2019t display any errors.\n\nPyPDF2 does not have a way to extract images, charts, or other media from PDF documents, but it can extract text and return it as a Python string. To start learning how PyPDF2 works, we\u2019ll use it on the example PDF shown in Figure 15-1.\n\nFigure 15-1: The PDF page that we will be extracting text from\n\nDownload this PDF from https://nostarch.com/automatestuff2/ and enter the following into the interactive shell:\n\n>>> import PyPDF2 >>> pdfFileObj = open('meetingminutes.pdf', 'rb') >>> pdfReader = PyPDF2.PdfFileReader(pdfFileObj) \u278a >>> pdfReader.numPages 19 \u278b >>> pageObj = pdfReader.getPage(0) \u278c >>> pageObj.extractText() 'OOFFFFIICCIIAALL\u00a0\u00a0BBOOAARRDD\u00a0\u00a0MMIINNUUTTEESS\u00a0\u00a0\u00a0Meeting of March 7, 2015\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\n\u00a0\u00a0\u00a0\u00a0\u00a0The Board of Elementary and Secondary Education shall provide leadership and create policies for education that expand opportunities for children, empower families and communities, and advance Louisiana in an increasingly competitive global market. BOARD\u00a0\u00a0of ELEMENTARY and\u00a0\u00a0SECONDARY EDUCATION\u00a0\u00a0' >>> pdfFileObj.close()\n\nFirst, import the PyPDF2 module. Then open meetingminutes.pdf in read binary mode and store it in pdfFileObj . To get a PdfFileReader object that represents this PDF, call PyPDF2.PdfFileReader() and pass it pdfFileObj . Store this PdfFileReader object in pdfReader .\n\nThe total number of pages in the document is stored in the numPages attribute of a PdfFileReader object \u278a . The example PDF has 19 pages, but let\u2019s extract text from only the first page.\n\nTo extract text from a page, you need to get a Page object, which represents a single page of a PDF, from a PdfFileReader object. You can get a Page object by calling the getPage() method \u278b on a PdfFileReader object and passing it the page number of the page you\u2019re interested in\u2014in our case, 0.\n\nPyPDF2 uses a zero-based index for getting pages: The first page is page 0, the second is page 1, and so on. This is always the case, even if pages are numbered differently within the document. For example, say your PDF is a three-page excerpt from a longer report, and its pages are numbered 42, 43, and 44. To get the first page of this document, you would want to call pdfReader.getPage(0) , not getPage(42) or getPage(1) .\n\nOnce you have your Page object, call its extractText() method to return a string of the page\u2019s text \u278c . The text extraction isn\u2019t perfect: The text Charles E. \u201cChas\u201d Roemer, President from the PDF is absent from the string returned by extractText() , and the spacing is sometimes off. Still, this approximation of the PDF text content may be good enough for your program.\n\nSome PDF documents have an encryption feature that will keep them from being read until whoever is opening the document provides a password. Enter the following into the interactive shell with the PDF you downloaded, which has been encrypted with the password rosebud :\n\n>>> import PyPDF2 >>> pdfReader = PyPDF2.PdfFileReader(open('encrypted.pdf', 'rb')) \u278a >>> pdfReader.isEncrypted True >>> pdfReader.getPage(0) \u278b Traceback (most recent call last): File \"<pyshell#173>\", line 1, in <module> pdfReader.getPage() -- snip -- File \"C:\\Python34\\lib\\site-packages\\PyPDF2\\pdf.py\", line 1173, in getObject raise utils.PdfReadError(\"file has not been decrypted\") PyPDF2.utils.PdfReadError: file has not been decrypted >>> pdfReader = PyPDF2.PdfFileReader(open('encrypted.pdf', 'rb')) \u278c >>> pdfReader.decrypt('rosebud') 1 >>> pageObj = pdfReader.getPage(0)\n\nAll PdfFileReader objects have an isEncrypted attribute that is True if the PDF is encrypted and False if it isn\u2019t \u278a . Any attempt to call a function that reads the file before it has been decrypted with the correct password will result in an error \u278b .\n\nTo read an encrypted PDF, call the decrypt() function and pass the password as a string \u278c . After you call decrypt() with the correct password, you\u2019ll see that calling getPage() no longer causes an error. If given the wrong password, the decrypt() function will return 0 and getPage() will continue to fail. Note that the decrypt() method decrypts only the PdfFileReader object, not the actual PDF file. After your program terminates, the file on your hard drive remains encrypted. Your program will have to call decrypt() again the next time it is run.\n\nPyPDF2\u2019s counterpart to PdfFileReader is PdfFileWriter , which can create new PDF files. But PyPDF2 cannot write arbitrary text to a PDF like Python can do with plaintext files. Instead, PyPDF2\u2019s PDF-writing capabilities are limited to copying pages from other PDFs, rotating pages, overlaying pages, and encrypting files.\n\nPyPDF2 doesn\u2019t allow you to directly edit a PDF. Instead, you have to create a new PDF and then copy content over from an existing document. The examples in this section will follow this general approach:\n\n1. Open one or more existing PDFs (the source PDFs) into PdfFileReader objects.\n2. Create a new PdfFileWriter object.\n3. Copy pages from the PdfFileReader objects into the PdfFileWriter object.\n4. Finally, use the PdfFileWriter object to write the output PDF.\n\nCreating a PdfFileWriter object creates only a value that represents a PDF document in Python. It doesn\u2019t create the actual PDF file. For that, you must call the PdfFileWriter \u2019s write() method.\n\nThe write() method takes a regular File object that has been opened in write-binary mode. You can get such a File object by calling Python\u2019s open() function with two arguments: the string of what you want the PDF\u2019s filename to be and 'wb' to indicate the file should be opened in write-binary mode.\n\nIf this sounds a little confusing, don\u2019t worry\u2014you\u2019ll see how this works in the following code examples.\n\nYou can use PyPDF2 to copy pages from one PDF document to another. This allows you to combine multiple PDF files, cut unwanted pages, or reorder pages.\n\nDownload meetingminutes.pdf and meetingminutes2.pdf from https://nostarch.com/automatestuff2/ and place the PDFs in the current working directory. Enter the following into the interactive shell:\n\n>>> import PyPDF2 >>> pdf1File = open('meetingminutes.pdf', 'rb') >>> pdf2File = open('meetingminutes2.pdf', 'rb') \u278a >>> pdf1Reader = PyPDF2.PdfFileReader(pdf1File) \u278b >>> pdf2Reader = PyPDF2.PdfFileReader(pdf2File) \u278c >>> pdfWriter = PyPDF2.PdfFileWriter() >>> for pageNum in range(pdf1Reader.numPages): \u278d pageObj = pdf1Reader.getPage(pageNum) \u278e pdfWriter.addPage(pageObj) >>> for pageNum in range(pdf2Reader.numPages): \u278d pageObj = pdf2Reader.getPage(pageNum) \u278e pdfWriter.addPage(pageObj) \u278f >>> pdfOutputFile = open('combinedminutes.pdf', 'wb') >>> pdfWriter.write(pdfOutputFile) >>> pdfOutputFile.close() >>> pdf1File.close() >>> pdf2File.close()\n\nOpen both PDF files in read binary mode and store the two resulting File objects in pdf1File and pdf2File . Call PyPDF2.PdfFileReader() and pass it pdf1File to get a PdfFileReader object for meetingminutes.pdf \u278a . Call it again and pass it pdf2File to get a PdfFileReader object for meetingminutes2.pdf \u278b . Then create a new PdfFileWriter object, which represents a blank PDF document \u278c .\n\nNext, copy all the pages from the two source PDFs and add them to the PdfFileWriter object. Get the Page object by calling getPage() on a PdfFileReader object \u278d . Then pass that Page object to your PdfFileWriter\u2019s addPage() method \u278e . These steps are done first for pdf1Reader and then again for pdf2Reader . When you\u2019re done copying pages, write a new PDF called combinedminutes.pdf by passing a File object to the PdfFileWriter\u2019s write() method \u278f .\n\nYou have now created a new PDF file that combines the pages from meetingminutes.pdf and meetingminutes2.pdf into a single document. Remember that the File object passed to PyPDF2.PdfFileReader() needs to be opened in read-binary mode by passing 'rb' as the second argument to open() . Likewise, the File object passed to PyPDF2.PdfFileWriter() needs to be opened in write-binary mode with 'wb' .\n\nThe pages of a PDF can also be rotated in 90-degree increments with the rotateClockwise() and rotateCounterClockwise() methods. Pass one of the integers 90 , 180 , or 270 to these methods. Enter the following into the interactive shell, with the meetingminutes.pdf file in the current working directory:\n\n>>> import PyPDF2 >>> minutesFile = open('meetingminutes.pdf', 'rb') >>> pdfReader = PyPDF2.PdfFileReader(minutesFile) \u278a >>> page = pdfReader.getPage(0) \u278b >>> page.rotateClockwise(90) {'/Contents': [IndirectObject(961, 0), IndirectObject(962, 0), -- snip -- } >>> pdfWriter = PyPDF2.PdfFileWriter() >>> pdfWriter.addPage(page) \u278c >>> resultPdfFile = open('rotatedPage.pdf', 'wb') >>> pdfWriter.write(resultPdfFile) >>> resultPdfFile.close() >>> minutesFile.close()\n\nHere we use getPage(0) to select the first page of the PDF \u278a , and then we call rotateClockwise(90) on that page \u278b . We write a new PDF with the rotated page and save it as rotatedPage.pdf \u278c .\n\nThe resulting PDF will have one page, rotated 90 degrees clockwise, as shown in Figure 15-2. The return values from rotateClockwise() and rotateCounterClockwise() contain a lot of information that you can ignore.\n\nFigure 15-2: The rotatedPage.pdf file with the page rotated 90 degrees clockwise\n\nPyPDF2 can also overlay the contents of one page over another, which is useful for adding a logo, timestamp, or watermark to a page. With Python, it\u2019s easy to add watermarks to multiple files and only to pages your program specifies.\n\nDownload watermark.pdf from https://nostarch.com/automatestuff2/ and place the PDF in the current working directory along with meetingminutes.pdf . Then enter the following into the interactive shell:\n\n>>> import PyPDF2 >>> minutesFile = open('meetingminutes.pdf', 'rb') \u278a >>> pdfReader = PyPDF2.PdfFileReader(minutesFile) \u278b >>> minutesFirstPage = pdfReader.getPage(0) \u278c >>> pdfWatermarkReader = PyPDF2.PdfFileReader(open('watermark.pdf', 'rb')) \u278d >>> minutesFirstPage.mergePage(pdfWatermarkReader.getPage(0)) \u278e >>> pdfWriter = PyPDF2.PdfFileWriter() \u278f >>> pdfWriter.addPage(minutesFirstPage) \u2790 >>> for pageNum in range(1, pdfReader.numPages): pageObj = pdfReader.getPage(pageNum) pdfWriter.addPage(pageObj) >>> resultPdfFile = open('watermarkedCover.pdf', 'wb') >>> pdfWriter.write(resultPdfFile) >>> minutesFile.close() >>> resultPdfFile.close()\n\nHere we make a PdfFileReader object of meetingminutes.pdf \u278a . We call getPage(0) to get a Page object for the first page and store this object in minutesFirstPage \u278b . We then make a PdfFileReader object for watermark.pdf \u278c and call mergePage() on minutesFirstPage \u278d . The argument we pass to mergePage() is a Page object for the first page of watermark.pdf .\n\nNow that we\u2019ve called mergePage() on minutesFirstPage , minutesFirstPage represents the watermarked first page. We make a PdfFileWriter object \u278e and add the watermarked first page \u278f . Then we loop through the rest of the pages in meetingminutes.pdf and add them to the PdfFileWriter object \u2790 . Finally, we open a new PDF called watermarkedCover.pdf and write the contents of the PdfFileWriter to the new PDF.\n\nFigure 15-3 shows the results. Our new PDF, watermarkedCover.pdf , has all the contents of the meetingminutes.pdf , and the first page is watermarked.\n\nFigure 15-3: The original PDF (left), the watermark PDF (center), and the merged PDF (right)\n\nA PdfFileWriter object can also add encryption to a PDF document. Enter the following into the interactive shell:\n\n>>> import PyPDF2 >>> pdfFile = open('meetingminutes.pdf', 'rb') >>> pdfReader = PyPDF2.PdfFileReader(pdfFile) >>> pdfWriter = PyPDF2.PdfFileWriter() >>> for pageNum in range(pdfReader.numPages): pdfWriter.addPage(pdfReader.getPage(pageNum)) \u278a >>> pdfWriter.encrypt('swordfish') >>> resultPdf = open('encryptedminutes.pdf', 'wb') >>> pdfWriter.write(resultPdf) >>> resultPdf.close()\n\nBefore calling the write() method to save to a file, call the encrypt() method and pass it a password string \u278a . PDFs can have a user password (allowing you to view the PDF) and an owner password (allowing you to set permissions for printing, commenting, extracting text, and other features). The user password and owner password are the first and second arguments to encrypt() , respectively. If only one string argument is passed to encrypt() , it will be used for both passwords.\n\nIn this example, we copied the pages of meetingminutes.pdf to a PdfFileWriter object. We encrypted the PdfFileWriter with the password swordfish , opened a new PDF called encryptedminutes.pdf , and wrote the contents of the PdfFileWriter to the new PDF. Before anyone can view encryptedminutes.pdf , they\u2019ll have to enter this password. You may want to delete the original, unencrypted meetingminutes.pdf file after ensuring its copy was correctly encrypted.", "source": "https://automatetheboringstuff.com/2e/chapter15/", "category": "15WORKING WITH PDF AND WORD DOCUMENTS"}
{"instruction": "How do I use 'Project: Combining Select Pages from Many PDFs' in Python?", "input": "", "output": "Say you have the boring job of merging several dozen PDF documents into a single PDF file. Each of them has a cover sheet as the first page, but you don\u2019t want the cover sheet repeated in the final result. Even though there are lots of free programs for combining PDFs, many of them simply merge entire files together. Let\u2019s write a Python program to customize which pages you want in the combined PDF.\n\nAt a high level, here\u2019s what the program will do:\n\n1. Find all PDF files in the current working directory.\n2. Sort the filenames so the PDFs are added in order.\n3. Write each page, excluding the first page, of each PDF to the output file.\n\nIn terms of implementation, your code will need to do the following:\n\n1. Call os.listdir() to find all the files in the working directory and remove any non-PDF files.\n2. Call Python\u2019s sort() list method to alphabetize the filenames.\n3. Create a PdfFileWriter object for the output PDF.\n4. Loop over each PDF file, creating a PdfFileReader object for it.\n5. Loop over each page (except the first) in each PDF file.\n6. Add the pages to the output PDF.\n7. Write the output PDF to a file named allminutes.pdf .\n\nFor this project, open a new file editor tab and save it as combinePdfs.py .\n\nFirst, your program needs to get a list of all files with the .pdf extension in the current working directory and sort them. Make your code look like the following:\n\n#! python3 # combinePdfs.py - Combines all the PDFs in the current working directory into # into a single PDF. \u278a import PyPDF2, os # Get all the PDF filenames. pdfFiles = [] for filename in os.listdir('.'): if filename.endswith('.pdf'): \u278b pdfFiles.append(filename) \u278c pdfFiles.sort(key = str.lower) \u278d pdfWriter = PyPDF2.PdfFileWriter() # TODO: Loop through all the PDF files. # TODO: Loop through all the pages (except the first) and add them. # TODO: Save the resulting PDF to a file.\n\nAfter the shebang line and the descriptive comment about what the program does, this code imports the os and PyPDF2 modules \u278a . The os.listdir('.') call will return a list of every file in the current working directory. The code loops over this list and adds only those files with the .pdf extension to pdfFiles \u278b . Afterward, this list is sorted in alphabetical order with the key = str.lower keyword argument to sort() \u278c .\n\nA PdfFileWriter object is created to hold the combined PDF pages \u278d . Finally, a few comments outline the rest of the program.\n\nNow the program must read each PDF file in pdfFiles . Add the following to your program:\n\n#! python3 # combinePdfs.py - Combines all the PDFs in the current working directory into # a single PDF. import PyPDF2, os # Get all the PDF filenames. pdfFiles = [] -- snip -- # Loop through all the PDF files. for filename in pdfFiles: pdfFileObj = open(filename, 'rb') pdfReader = PyPDF2.PdfFileReader(pdfFileObj) # TODO: Loop through all the pages (except the first) and add them. # TODO: Save the resulting PDF to a file.\n\nFor each PDF, the loop opens a filename in read-binary mode by calling open() with 'rb' as the second argument. The open() call returns a File object, which gets passed to PyPDF2.PdfFileReader() to create a PdfFileReader object for that PDF file.\n\nFor each PDF, you\u2019ll want to loop over every page except the first. Add this code to your program:\n\n#! python3 # combinePdfs.py - Combines all the PDFs in the current working directory into # a single PDF. import PyPDF2, os -- snip -- # Loop through all the PDF files. for filename in pdfFiles: -- snip -- # Loop through all the pages (except the first) and add them. \u278a for pageNum in range(1, pdfReader.numPages): pageObj = pdfReader.getPage(pageNum) pdfWriter.addPage(pageObj) # TODO: Save the resulting PDF to a file.\n\nThe code inside the for loop copies each Page object individually to the PdfFileWriter object. Remember, you want to skip the first page. Since PyPDF2 considers 0 to be the first page, your loop should start at 1 \u278a and then go up to, but not include, the integer in pdfReader.numPages .\n\nAfter these nested for loops are done looping, the pdfWriter variable will contain a PdfFileWriter object with the pages for all the PDFs combined. The last step is to write this content to a file on the hard drive. Add this code to your program:\n\n#! python3 # combinePdfs.py - Combines all the PDFs in the current working directory into # a single PDF. import PyPDF2, os -- snip -- # Loop through all the PDF files. for filename in pdfFiles: -- snip -- # Loop through all the pages (except the first) and add them. for pageNum in range(1, pdfReader.numPages): -- snip -- # Save the resulting PDF to a file. pdfOutput = open('allminutes.pdf', 'wb') pdfWriter.write(pdfOutput) pdfOutput.close()\n\nPassing 'wb' to open() opens the output PDF file, allminutes.pdf , in write-binary mode. Then, passing the resulting File object to the write() method creates the actual PDF file. A call to the close() method finishes the program.\n\nBeing able to create PDFs from the pages of other PDFs will let you make programs that can do the following:\n\n* Cut out specific pages from PDFs.\n* Reorder pages in a PDF.\n* Create a PDF from only those pages that have some specific text, identified by extractText() .", "source": "https://automatetheboringstuff.com/2e/chapter15/", "category": "15WORKING WITH PDF AND WORD DOCUMENTS"}
{"instruction": "What is 'Word Documents' and how does it work in Python?", "input": "", "output": "Python can create and modify Word documents, which have the .docx file extension, with the docx module. You can install the module by running pip install --user -U python-docx==0.8.10 . (Appendix A has full details on installing third-party modules.)\n\nIf you don\u2019t have Word, LibreOffice Writer and OpenOffice Writer are free alternative applications for Windows, macOS, and Linux that can be used to open .docx files. You can download them from https://www.libreoffice.org/ and https://openoffice.org/ , respectively. The full documentation for Python-Docx is available at https://python-docx.readthedocs.io/ . Although there is a version of Word for macOS, this chapter will focus on Word for Windows.\n\nCompared to plaintext, .docx files have a lot of structure. This structure is represented by three different data types in Python-Docx. At the highest level, a Document object represents the entire document. The Document object contains a list of Paragraph objects for the paragraphs in the document. (A new paragraph begins whenever the user presses ENTER or RETURN while typing in a Word document.) Each of these Paragraph objects contains a list of one or more Run objects. The single-sentence paragraph in Figure 15-4 has four runs.\n\nFigure 15-4: The Run objects identified in a Paragraph object\n\nThe text in a Word document is more than just a string. It has font, size, color, and other styling information associated with it. A style in Word is a collection of these attributes. A Run object is a contiguous run of text with the same style. A new Run object is needed whenever the text style changes.\n\nLet\u2019s experiment with the docx module. Download demo.docx from https://nostarch.com/automatestuff2/ and save the document to the working directory. Then enter the following into the interactive shell:\n\n>>> import docx \u278a >>> doc = docx.Document('demo.docx') \u278b >>> len(doc.paragraphs) 7 \u278c >>> doc.paragraphs[0].text 'Document Title' \u278d >>> doc.paragraphs[1].text 'A plain paragraph with some bold and some italic' \u278e >>> len(doc.paragraphs[1].runs) 4 \u278f >>> doc.paragraphs[1].runs[0].text 'A plain paragraph with some ' \u2790 >>> doc.paragraphs[1].runs[1].text 'bold' \u2791 >>> doc.paragraphs[1].runs[2].text ' and some ' \u2792 >>> doc.paragraphs[1].runs[3].text 'italic'\n\nAt \u278a , we open a .docx file in Python, call docx.Document() , and pass the filename demo.docx . This will return a Document object, which has a paragraphs attribute that is a list of Paragraph objects. When we call len() on doc.paragraphs , it returns 7 , which tells us that there are seven Paragraph objects in this document \u278b . Each of these Paragraph objects has a text attribute that contains a string of the text in that paragraph (without the style information). Here, the first text attribute contains 'DocumentTitle' \u278c , and the second contains 'A plain paragraph with some bold and some italic' \u278d .\n\nEach Paragraph object also has a runs attribute that is a list of Run objects. Run objects also have a text attribute, containing just the text in that particular run. Let\u2019s look at the text attributes in the second Paragraph object, 'A plain paragraph with some bold and some italic' . Calling len() on this Paragraph object tells us that there are four Run objects \u278e . The first run object contains 'A plain paragraph with some ' \u278f . Then, the text changes to a bold style, so 'bold' starts a new Run object \u2790 . The text returns to an unbolded style after that, which results in a third Run object, ' and some ' \u2791 . Finally, the fourth and last Run object contains 'italic' in an italic style \u2792 .\n\nWith Python-Docx, your Python programs will now be able to read the text from a .docx file and use it just like any other string value.\n\nIf you care only about the text, not the styling information, in the Word document, you can use the getText() function. It accepts a filename of a .docx file and returns a single string value of its text. Open a new file editor tab and enter the following code, saving it as readDocx.py :\n\n#! python3 import docx def getText(filename): doc = docx.Document(filename) fullText = [] for para in doc.paragraphs: fullText.append(para.text) return '\\n'.join(fullText)\n\nThe getText() function opens the Word document, loops over all the Paragraph objects in the paragraphs list, and then appends their text to the list in fullText . After the loop, the strings in fullText are joined together with newline characters.\n\nThe readDocx.py program can be imported like any other module. Now if you just need the text from a Word document, you can enter the following:\n\n>>> import readDocx >>> print(readDocx.getText('demo.docx')) Document Title A plain paragraph with some bold and some italic Heading, level 1 Intense quote first item in unordered list first item in ordered list\n\nYou can also adjust getText() to modify the string before returning it. For example, to indent each paragraph, replace the append() call in readDocx.py with this:\n\nfullText.append( '\u00a0\u00a0' + para.text)\n\nTo add a double space between paragraphs, change the join() call code to this:\n\nreturn '\\n \\n '.join(fullText)\n\nAs you can see, it takes only a few lines of code to write functions that will read a .docx file and return a string of its content to your liking.\n\nIn Word for Windows, you can see the styles by pressing CTRL - ALT - SHIFT -S to display the Styles pane, which looks like Figure 15-5. On macOS, you can view the Styles pane by clicking the View \u25b8 Styles menu item.\n\nFigure 15-5: Display the Styles pane by pressing CTRL-ALT-SHIFT -S on Windows.\n\nWord and other word processors use styles to keep the visual presentation of similar types of text consistent and easy to change. For example, perhaps you want to set body paragraphs in 11-point, Times New Roman, left-justified, ragged-right text. You can create a style with these settings and assign it to all body paragraphs. Then, if you later want to change the presentation of all body paragraphs in the document, you can just change the style, and all those paragraphs will be automatically updated.\n\nFor Word documents, there are three types of styles: paragraph styles can be applied to Paragraph objects, character styles can be applied to Run objects, and linked styles can be applied to both kinds of objects. You can give both Paragraph and Run objects styles by setting their style attribute to a string. This string should be the name of a style. If style is set to None , then there will be no style associated with the Paragraph or Run object.\n\nThe string values for the default Word styles are as follows:\n\nWhen using a linked style for a Run object, you will need to add ' Char' to the end of its name. For example, to set the Quote linked style for a Paragraph object, you would use paragraphObj.style = 'Quote' , but for a Run object, you would use runObj.style = 'Quote Char' .\n\nIn the current version of Python-Docx (0.8.10), the only styles that can be used are the default Word styles and the styles in the opened .docx . New styles cannot be created\u2014though this may change in future versions of Python-Docx.\n\nIf you want to create Word documents that use styles beyond the default ones, you will need to open Word to a blank Word document and create the styles yourself by clicking the New Style button at the bottom of the Styles pane (Figure 15-6 shows this on Windows).\n\nThis will open the Create New Style from Formatting dialog, where you can enter the new style. Then, go back into the interactive shell and open this blank Word document with docx.Document() , using it as the base for your Word document. The name you gave this style will now be available to use with Python-Docx.\n\nFigure 15-6: The New Style button (left) and the Create New Style from Formatting dialog (right)\n\nRuns can be further styled using text attributes. Each attribute can be set to one of three values: True (the attribute is always enabled, no matter what other styles are applied to the run), False (the attribute is always disabled), or None (defaults to whatever the run\u2019s style is set to).\n\nTable 15-1 lists the text attributes that can be set on Run objects.\n\nTable 15-1: Run Object text Attributes\n\nFor example, to change the styles of demo.docx , enter the following into the interactive shell:\n\n>>> import docx >>> doc = docx.Document('demo.docx') >>> doc.paragraphs[0].text 'Document Title' >>> doc.paragraphs[0].style # The exact id may be different: _ParagraphStyle('Title') id: 3095631007984 >>> doc.paragraphs[0].style = 'Normal' >>> doc.paragraphs[1].text 'A plain paragraph with some bold and some italic' >>> (doc.paragraphs[1].runs[0].text, doc.paragraphs[1].runs[1].text, doc. paragraphs[1].runs[2].text, doc.paragraphs[1].runs[3].text) ('A plain paragraph with some ', 'bold', ' and some ', 'italic') >>> doc.paragraphs[1].runs[0].style = 'QuoteChar' >>> doc.paragraphs[1].runs[1].underline = True >>> doc.paragraphs[1].runs[3].underline = True >>> doc.save('restyled.docx')\n\nHere, we use the text and style attributes to easily see what\u2019s in the paragraphs in our document. We can see that it\u2019s simple to divide a paragraph into runs and access each run individually. So we get the first, second, and fourth runs in the second paragraph; style each run; and save the results to a new document.\n\nThe words Document Title at the top of restyled.docx will have the Normal style instead of the Title style, the Run object for the text A plain paragraph with some will have the QuoteChar style, and the two Run objects for the words bold and italic will have their underline attributes set to True . Figure 15-7 shows how the styles of paragraphs and runs look in restyled.docx .\n\nFigure 15-7: The restyled.docx file\n\nYou can find more complete documentation on Python-Docx\u2019s use of styles at https://python-docx.readthedocs.io/en/latest/user/styles.html .\n\nEnter the following into the interactive shell:\n\n>>> import docx >>> doc = docx.Document() >>> doc.add_paragraph('Hello, world!') <docx.text.Paragraph object at 0x0000000003B56F60> >>> doc.save('helloworld.docx')\n\nTo create your own .docx file, call docx.Document() to return a new, blank Word Document object. The add_paragraph() document method adds a new paragraph of text to the document and returns a reference to the Paragraph object that was added. When you\u2019re done adding text, pass a filename string to the save() document method to save the Document object to a file.\n\nThis will create a file named helloworld.docx in the current working directory that, when opened, looks like Figure 15-8.\n\nFigure 15-8: The Word document created using add_paragraph('Hello, world!')\n\nYou can add paragraphs by calling the add_paragraph() method again with the new paragraph\u2019s text. Or to add text to the end of an existing paragraph, you can call the paragraph\u2019s add_run() method and pass it a string. Enter the following into the interactive shell:\n\n>>> import docx >>> doc = docx.Document() >>> doc.add_paragraph('Hello world!') <docx.text.Paragraph object at 0x000000000366AD30> >>> paraObj1 = doc.add_paragraph('This is a second paragraph.') >>> paraObj2 = doc.add_paragraph('This is a yet another paragraph.') >>> paraObj1.add_run(' This text is being added to the second paragraph.') <docx.text.Run object at 0x0000000003A2C860> >>> doc.save('multipleParagraphs.docx')\n\nThe resulting document will look like Figure 15-9. Note that the text This text is being added to the second paragraph. was added to the Paragraph object in paraObj1 , which was the second paragraph added to doc . The add_paragraph() and add_run() functions return paragraph and Run objects, respectively, to save you the trouble of extracting them as a separate step.\n\nKeep in mind that as of Python-Docx version 0.8.10, new Paragraph objects can be added only to the end of the document, and new Run objects can be added only to the end of a Paragraph object.\n\nThe save() method can be called again to save the additional changes you\u2019ve made.\n\nFigure 15-9: The document with multiple Paragraph and Run objects added\n\nBoth add_paragraph() and add_run() accept an optional second argument that is a string of the Paragraph or Run object\u2019s style. Here\u2019s an example:\n\n>>> doc.add_paragraph('Hello, world!', 'Title')\n\nThis line adds a paragraph with the text Hello, world! in the Title style.\n\nCalling add_heading() adds a paragraph with one of the heading styles. Enter the following into the interactive shell:\n\n>>> doc = docx.Document() >>> doc.add_heading('Header 0', 0) <docx.text.Paragraph object at 0x00000000036CB3C8> >>> doc.add_heading('Header 1', 1) <docx.text.Paragraph object at 0x00000000036CB630> >>> doc.add_heading('Header 2', 2) <docx.text.Paragraph object at 0x00000000036CB828> >>> doc.add_heading('Header 3', 3) <docx.text.Paragraph object at 0x00000000036CB2E8> >>> doc.add_heading('Header 4', 4) <docx.text.Paragraph object at 0x00000000036CB3C8> >>> doc.save('headings.docx')\n\nThe arguments to add_heading() are a string of the heading text and an integer from 0 to 4 . The integer 0 makes the heading the Title style, which is used for the top of the document. Integers 1 to 4 are for various heading levels, with 1 being the main heading and 4 the lowest subheading. The add_heading() function returns a Paragraph object to save you the step of extracting it from the Document object as a separate step.\n\nThe resulting headings.docx file will look like Figure 15-10.\n\nFigure 15-10: The headings.docx document with headings 0 to 4\n\nTo add a line break (rather than starting a whole new paragraph), you can call the add_break() method on the Run object you want to have the break appear after. If you want to add a page break instead, you need to pass the value docx.enum.text.WD_BREAK.PAGE as a lone argument to add_break() , as is done in the middle of the following example:\n\n>>> doc = docx.Document() >>> doc.add_paragraph('This is on the first page!') <docx.text.Paragraph object at 0x0000000003785518> \u278a >>> doc.paragraphs[0].runs[0].add_break(docx.enum.text.WD_BREAK.PAGE) >>> doc.add_paragraph('This is on the second page!') <docx.text.Paragraph object at 0x00000000037855F8> >>> doc.save('twoPage.docx')\n\nThis creates a two-page Word document with This is on the first page! on the first page and This is on the second page! on the second. Even though there was still plenty of space on the first page after the text This is on the first page! , we forced the next paragraph to begin on a new page by inserting a page break after the first run of the first paragraph \u278a .\n\nDocument objects have an add_picture() method that will let you add an image to the end of the document. Say you have a file zophie.png in the current working directory. You can add zophie.png to the end of your document with a width of 1 inch and height of 4 centimeters (Word can use both imperial and metric units) by entering the following:\n\n>>> doc.add_picture('zophie.png', width=docx.shared.Inches(1), height=docx.shared.Cm(4)) <docx.shape.InlineShape object at 0x00000000036C7D30>\n\nThe first argument is a string of the image\u2019s filename. The optional width and height keyword arguments will set the width and height of the image in the document. If left out, the width and height will default to the normal size of the image.\n\nYou\u2019ll probably prefer to specify an image\u2019s height and width in familiar units such as inches and centimeters, so you can use the docx.shared.Inches() and docx.shared.Cm() functions when you\u2019re specifying the width and height keyword arguments.", "source": "https://automatetheboringstuff.com/2e/chapter15/", "category": "15WORKING WITH PDF AND WORD DOCUMENTS"}
{"instruction": "Explain the concept of 'Creating PDFs from Word Documents' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "The PyPDF2 module doesn\u2019t allow you to create PDF documents directly, but there\u2019s a way to generate PDF files with Python if you\u2019re on Windows and have Microsoft Word installed. You\u2019ll need to install the Pywin32 package by running pip install --user -U pywin32==224 . With this and the docx module, you can create Word documents and then convert them to PDFs with the following script.\n\nOpen a new file editor tab, enter the following code, and save it as convertWordToPDF.py :\n\n# This script runs on Windows only, and you must have Word installed. import win32com.client # install with \"pip install pywin32==224\" import docx wordFilename = ' your_word_document .docx' pdfFilename = ' your_pdf_filename .pdf' doc = docx.Document() # Code to create Word document goes here. doc.save(wordFilename) wdFormatPDF = 17 # Word's numeric code for PDFs. wordObj = win32com.client.Dispatch('Word.Application') docObj = wordObj.Documents.Open(wordFilename) docObj.SaveAs(pdfFilename, FileFormat=wdFormatPDF) docObj.Close() wordObj.Quit()\n\nTo write a program that produces PDFs with your own content, you must use the docx module to create a Word document, then use the Pywin32 package\u2019s win32com.client module to convert it to a PDF. Replace the # Code to create Word document goes here. comment with docx function calls to create your own content for the PDF in a Word document.\n\nThis may seem like a convoluted way to produce PDFs, but as it turns out, professional software solutions are often just as complicated.", "source": "https://automatetheboringstuff.com/2e/chapter15/", "category": "15WORKING WITH PDF AND WORD DOCUMENTS"}
{"instruction": "Provide a guide on '16WORKING WITH CSV FILES AND JSON DATA' in Python.", "input": "", "output": "In Chapter 15, you learned how to extract text from PDF and Word documents. These files were in a binary format, which required special Python modules to access their data. CSV and JSON files, on the other hand, are just plaintext files. You can view them in a text editor, such as Mu. But Python also comes with the special csv and json modules, each providing functions to help you work with these file formats.\n\nCSV stands for \u201ccomma-separated values,\u201d and CSV files are simplified spreadsheets stored as plaintext files. Python\u2019s csv module makes it easy to parse CSV files.\n\nJSON (pronounced \u201cJAY-sawn\u201d or \u201cJason\u201d\u2014it doesn\u2019t matter how because either way people will say you\u2019re pronouncing it wrong) is a format that stores information as JavaScript source code in plaintext files. (JSON is short for JavaScript Object Notation.) You don\u2019t need to know the JavaScript programming language to use JSON files, but the JSON format is useful to know because it\u2019s used in many web applications.", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "How do I use 'The csv Module' in Python?", "input": "", "output": "Each line in a CSV file represents a row in the spreadsheet, and commas separate the cells in the row. For example, the spreadsheet example.xlsx from https://nostarch.com/automatestuff2/ would look like this in a CSV file:\n\n4/5/2015 13:34,Apples,73 4/5/2015 3:41,Cherries,85 4/6/2015 12:46,Pears,14 4/8/2015 8:59,Oranges,52 4/10/2015 2:07,Apples,152 4/10/2015 18:10,Bananas,23 4/10/2015 2:40,Strawberries,98\n\nI will use this file for this chapter\u2019s interactive shell examples. You can download example.csv from https://nostarch.com/automatestuff2/ or enter the text into a text editor and save it as example.csv .\n\nCSV files are simple, lacking many of the features of an Excel spreadsheet. For example, CSV files:\n\n* Don\u2019t have types for their values\u2014everything is a string\n* Don\u2019t have settings for font size or color\n* Don\u2019t have multiple worksheets\n* Can\u2019t specify cell widths and heights\n* Can\u2019t have merged cells\n* Can\u2019t have images or charts embedded in them\n\nThe advantage of CSV files is simplicity. CSV files are widely supported by many types of programs, can be viewed in text editors (including Mu), and are a straightforward way to represent spreadsheet data. The CSV format is exactly as advertised: it\u2019s just a text file of comma-separated values.\n\nSince CSV files are just text files, you might be tempted to read them in as a string and then process that string using the techniques you learned in Chapter 9. For example, since each cell in a CSV file is separated by a comma, maybe you could just call split(',') on each line of text to get the comma-separated values as a list of strings. But not every comma in a CSV file represents the boundary between two cells. CSV files also have their own set of escape characters to allow commas and other characters to be included as part of the values . The split() method doesn\u2019t handle these escape characters. Because of these potential pitfalls, you should always use the csv module for reading and writing CSV files.\n\nTo read data from a CSV file with the csv module, you need to create a reader object. A reader object lets you iterate over lines in the CSV file. Enter the following into the interactive shell, with example.csv in the current working directory:\n\n\u278a >>> import csv \u278b >>> exampleFile = open('example.csv') \u278c >>> exampleReader = csv.reader(exampleFile) \u278d >>> exampleData = list(exampleReader) \u278e >>> exampleData [['4/5/2015 13:34', 'Apples', '73'], ['4/5/2015 3:41', 'Cherries', '85'], ['4/6/2015 12:46', 'Pears', '14'], ['4/8/2015 8:59', 'Oranges', '52'], ['4/10/2015 2:07', 'Apples', '152'], ['4/10/2015 18:10', 'Bananas', '23'], ['4/10/2015 2:40', 'Strawberries', '98']]\n\nThe csv module comes with Python, so we can import it \u278a without having to install it first.\n\nTo read a CSV file with the csv module, first open it using the open() function \u278b , just as you would any other text file. But instead of calling the read() or readlines() method on the File object that open() returns, pass it to the csv.reader() function \u278c . This will return a reader object for you to use. Note that you don\u2019t pass a filename string directly to the csv.reader() function.\n\nThe most direct way to access the values in the reader object is to convert it to a plain Python list by passing it to list() \u278d . Using list() on this reader object returns a list of lists, which you can store in a variable like exampleData . Entering exampleData in the shell displays the list of lists \u278e .\n\nNow that you have the CSV file as a list of lists, you can access the value at a particular row and column with the expression exampleData[row][col] , where row is the index of one of the lists in exampleData , and col is the index of the item you want from that list. Enter the following into the interactive shell:\n\n>>> exampleData[0][0] '4/5/2015 13:34' >>> exampleData[0][1] 'Apples' >>> exampleData[0][2] '73' >>> exampleData[1][1] 'Cherries' >>> exampleData[6][1] 'Strawberries'\n\nAs you can see from the output, exampleData[0][0] goes into the first list and gives us the first string, exampleData[0][2] goes into the first list and gives us the third string, and so on.\n\nFor large CSV files, you\u2019ll want to use the reader object in a for loop. This avoids loading the entire file into memory at once. For example, enter the following into the interactive shell:\n\n>>> import csv >>> exampleFile = open('example.csv') >>> exampleReader = csv.reader(exampleFile) >>> for row in exampleReader: print('Row #' + str(exampleReader.line_num) + ' ' + str(row)) Row #1 ['4/5/2015 13:34', 'Apples', '73'] Row #2 ['4/5/2015 3:41', 'Cherries', '85'] Row #3 ['4/6/2015 12:46', 'Pears', '14'] Row #4 ['4/8/2015 8:59', 'Oranges', '52'] Row #5 ['4/10/2015 2:07', 'Apples', '152'] Row #6 ['4/10/2015 18:10', 'Bananas', '23'] Row #7 ['4/10/2015 2:40', 'Strawberries', '98']\n\nAfter you import the csv module and make a reader object from the CSV file, you can loop through the rows in the reader object. Each row is a list of values, with each value representing a cell.\n\nThe print() function call prints the number of the current row and the contents of the row. To get the row number, use the reader object\u2019s line_num variable, which contains the number of the current line.\n\nThe reader object can be looped over only once. To reread the CSV file, you must call csv.reader to create a reader object.\n\nA writer object lets you write data to a CSV file. To create a writer object, you use the csv.writer() function. Enter the following into the interactive shell:\n\n>>> import csv \u278a >>> outputFile = open('output.csv', 'w', newline='') \u278b >>> outputWriter = csv.writer(outputFile) >>> outputWriter.writerow(['spam', 'eggs', 'bacon', 'ham']) 21 >>> outputWriter.writerow(['Hello, world!', 'eggs', 'bacon', 'ham']) 32 >>> outputWriter.writerow([1, 2, 3.141592, 4]) 16 >>> outputFile.close()\n\nFirst, call open() and pass it 'w' to open a file in write mode \u278a . This will create the object you can then pass to csv.writer() \u278b to create a writer object.\n\nOn Windows, you\u2019ll also need to pass a blank string for the open() function\u2019s newline keyword argument. For technical reasons beyond the scope of this book, if you forget to set the newline argument, the rows in output.csv will be double-spaced, as shown in Figure 16-1.\n\nFigure 16-1: If you forget the newline='' keyword argument in open() , the CSV file will be double-spaced.\n\nThe writerow() method for writer objects takes a list argument. Each value in the list is placed in its own cell in the output CSV file. The return value of writerow() is the number of characters written to the file for that row (including newline characters).\n\nThis code produces an output.csv file that looks like this:\n\nspam,eggs,bacon,ham \"Hello, world!\",eggs,bacon,ham 1,2,3.141592,4\n\nNotice how the writer object automatically escapes the comma in the value 'Hello, world!' with double quotes in the CSV file. The csv module saves you from having to handle these special cases yourself.\n\nSay you want to separate cells with a tab character instead of a comma and you want the rows to be double-spaced. You could enter something like the following into the interactive shell:\n\n>>> import csv >>> csvFile = open('example.tsv', 'w', newline='') \u278a >>> csvWriter = csv.writer(csvFile, delimiter='\\t', lineterminator='\\n\\n') >>> csvWriter.writerow(['apples', 'oranges', 'grapes']) 24 >>> csvWriter.writerow(['eggs', 'bacon', 'ham']) 17 >>> csvWriter.writerow(['spam', 'spam', 'spam', 'spam', 'spam', 'spam']) 32 >>> csvFile.close()\n\nThis changes the delimiter and line terminator characters in your file. The delimiter is the character that appears between cells on a row. By default, the delimiter for a CSV file is a comma. The line terminator is the character that comes at the end of a row. By default, the line terminator is a newline. You can change characters to different values by using the delimiter and lineterminator keyword arguments with csv.writer() .\n\nPassing delimiter='\\t' and lineterminator='\\n\\n' \u278a changes the character between cells to a tab and the character between rows to two newlines. We then call writerow() three times to give us three rows.\n\nThis produces a file named example.tsv with the following contents:\n\napples\u00a0\u00a0oranges grapes eggs\u00a0\u00a0\u00a0\u00a0bacon\u00a0\u00a0\u00a0ham spam\u00a0\u00a0\u00a0\u00a0spam\u00a0\u00a0\u00a0\u00a0spam\u00a0\u00a0\u00a0\u00a0spam\u00a0\u00a0\u00a0\u00a0spam\u00a0\u00a0\u00a0\u00a0spam\n\nNow that our cells are separated by tabs, we\u2019re using the file extension .tsv , for tab-separated values.\n\nFor CSV files that contain header rows, it\u2019s often more convenient to work with the DictReader and DictWriter objects, rather than the reader and writer objects.\n\nThe reader and writer objects read and write to CSV file rows by using lists. The DictReader and DictWriter CSV objects perform the same functions but use dictionaries instead, and they use the first row of the CSV file as the keys of these dictionaries.\n\nGo to https://nostarch.com/automatestuff2/ and download the exampleWithHeader.csv file. This file is the same as example.csv except it has Timestamp, Fruit, and Quantity as the column headers in the first row.\n\nTo read the file, enter the following into the interactive shell:\n\n>>> import csv >>> exampleFile = open('exampleWithHeader.csv') >>> exampleDictReader = csv.DictReader(exampleFile) >>> for row in exampleDictReader: ... print(row['Timestamp'], row['Fruit'], row['Quantity']) ... 4/5/2015 13:34 Apples 73 4/5/2015 3:41 Cherries 85 4/6/2015 12:46 Pears 14 4/8/2015 8:59 Oranges 52 4/10/2015 2:07 Apples 152 4/10/2015 18:10 Bananas 23 4/10/2015 2:40 Strawberries 98\n\nInside the loop, DictReader object sets row to a dictionary object with keys derived from the headers in the first row. (Well, technically, it sets row to an OrderedDict object, which you can use in the same way as a dictionary; the difference between them is beyond the scope of this book.) Using a DictReader object means you don\u2019t need additional code to skip the first row\u2019s header information, since the DictReader object does this for you.\n\nIf you tried to use DictReader objects with example.csv , which doesn\u2019t have column headers in the first row, the DictReader object would use '4/5/2015 13:34' , 'Apples' , and '73' as the dictionary keys. To avoid this, you can supply the DictReader() function with a second argument containing made-up header names:\n\n>>> import csv >>> exampleFile = open('example.csv') >>> exampleDictReader = csv.DictReader(exampleFile, ['time', 'name', 'amount']) >>> for row in exampleDictReader: ... print(row['time'], row['name'], row['amount']) ... 4/5/2015 13:34 Apples 73 4/5/2015 3:41 Cherries 85 4/6/2015 12:46 Pears 14 4/8/2015 8:59 Oranges 52 4/10/2015 2:07 Apples 152 4/10/2015 18:10 Bananas 23 4/10/2015 2:40 Strawberries 98\n\nBecause example.csv \u2019s first row doesn\u2019t have any text for the heading of each column, we created our own: 'time' , 'name' , and 'amount' .\n\nDictWriter objects use dictionaries to create CSV files.\n\n>>> import csv >>> outputFile = open('output.csv', 'w', newline='') >>> outputDictWriter = csv.DictWriter(outputFile, ['Name', 'Pet', 'Phone']) >>> outputDictWriter.writeheader() >>> outputDictWriter.writerow({'Name': 'Alice', 'Pet': 'cat', 'Phone': '555- 1234'}) 20 >>> outputDictWriter.writerow({'Name': 'Bob', 'Phone': '555-9999'}) 15 >>> outputDictWriter.writerow({'Phone': '555-5555', 'Name': 'Carol', 'Pet': 'dog'}) 20 >>> outputFile.close()\n\nIf you want your file to contain a header row, write that row by calling writeheader() . Otherwise, skip calling writeheader() to omit a header row from the file. You then write each row of the CSV file with a writerow() method call, passing a dictionary that uses the headers as keys and contains the data to write to the file.\n\nThe output.csv file this code creates looks like this:\n\nName,Pet,Phone Alice,cat,555-1234 Bob,,555-9999 Carol,dog,555-5555\n\nNotice that the order of the key-value pairs in the dictionaries you passed to writerow() doesn\u2019t matter: they\u2019re written in the order of the keys given to DictWriter() . For example, even though you passed the Phone key and value before the Name and Pet keys and values in the fourth row, the phone number still appeared last in the output.\n\nNotice also that any missing keys, such as 'Pet' in {'Name': 'Bob', 'Phone': '555-9999'} , will simply be empty in the CSV file.", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "Explain the concept of 'Project: Removing the Header from CSV Files' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Say you have the boring job of removing the first line from several hundred CSV files. Maybe you\u2019ll be feeding them into an automated process that requires just the data and not the headers at the top of the columns. You could open each file in Excel, delete the first row, and resave the file\u2014but that would take hours. Let\u2019s write a program to do it instead.\n\nThe program will need to open every file with the .csv extension in the current working directory, read in the contents of the CSV file, and rewrite the contents without the first row to a file of the same name. This will replace the old contents of the CSV file with the new, headless contents.\n\nAt a high level, the program must do the following:\n\n1. Find all the CSV files in the current working directory.\n2. Read in the full contents of each file.\n3. Write out the contents, skipping the first line, to a new CSV file.\n\nAt the code level, this means the program will need to do the following:\n\n1. Loop over a list of files from os.listdir() , skipping the non-CSV files.\n2. Create a CSV reader object and read in the contents of the file, using the line_num attribute to figure out which line to skip.\n3. Create a CSV writer object and write out the read-in data to the new file.\n\nFor this project, open a new file editor window and save it as removeCsvHeader.py .\n\nThe first thing your program needs to do is loop over a list of all CSV filenames for the current working directory. Make your removeCsvHeader.py look like this:\n\n#! python3 # removeCsvHeader.py - Removes the header from all CSV files in the current # working directory. import csv, os os.makedirs('headerRemoved', exist_ok=True) # Loop through every file in the current working directory. for csvFilename in os.listdir('.'): if not csvFilename.endswith('.csv'): \u278a continue\u00a0\u00a0\u00a0\u00a0# skip non-csv files print('Removing header from ' + csvFilename + '...') # TODO: Read the CSV file in (skipping first row). # TODO: Write out the CSV file.\n\nThe os.makedirs() call will create a headerRemoved folder where all the headless CSV files will be written. A for loop on os.listdir('.') gets you partway there, but it will loop over all files in the working directory, so you\u2019ll need to add some code at the start of the loop that skips filenames that don\u2019t end with .csv . The continue statement \u278a makes the for loop move on to the next filename when it comes across a non-CSV file.\n\nJust so there\u2019s some output as the program runs, print out a message saying which CSV file the program is working on. Then, add some TODO comments for what the rest of the program should do.\n\nThe program doesn\u2019t remove the first line from the CSV file. Rather, it creates a new copy of the CSV file without the first line. Since the copy\u2019s filename is the same as the original filename, the copy will overwrite the original.\n\nThe program will need a way to track whether it is currently looping on the first row. Add the following to removeCsvHeader.py .\n\n#! python3 # removeCsvHeader.py - Removes the header from all CSV files in the current # working directory. -- snip -- # Read the CSV file in (skipping first row). csvRows = [] csvFileObj = open(csvFilename) readerObj = csv.reader(csvFileObj) for row in readerObj: if readerObj.line_num == 1: continue\u00a0\u00a0\u00a0\u00a0# skip first row csvRows.append(row) csvFileObj.close() # TODO: Write out the CSV file.\n\nThe reader object\u2019s line_num attribute can be used to determine which line in the CSV file it is currently reading. Another for loop will loop over the rows returned from the CSV reader object, and all rows but the first will be appended to csvRows .\n\nAs the for loop iterates over each row, the code checks whether readerObj.line_num is set to 1 . If so, it executes a continue to move on to the next row without appending it to csvRows . For every row afterward, the condition will be always be False , and the row will be appended to csvRows .\n\nNow that csvRows contains all rows but the first row, the list needs to be written out to a CSV file in the headerRemoved folder. Add the following to removeCsvHeader.py :\n\n#! python3 # removeCsvHeader.py - Removes the header from all CSV files in the current # working directory. -- snip -- # Loop through every file in the current working directory. \u278a for csvFilename in os.listdir('.'): if not csvFilename.endswith('.csv'): continue\u00a0\u00a0\u00a0\u00a0# skip non-CSV files -- snip -- # Write out the CSV file. csvFileObj = open(os.path.join('headerRemoved', csvFilename), 'w', newline='') csvWriter = csv.writer(csvFileObj) for row in csvRows: csvWriter.writerow(row) csvFileObj.close()\n\nThe CSV writer object will write the list to a CSV file in headerRemoved using csvFilename (which we also used in the CSV reader). This will overwrite the original file.\n\nOnce we create the writer object, we loop over the sublists stored in csvRows and write each sublist to the file.\n\nAfter the code is executed, the outer for loop \u278a will loop to the next filename from os.listdir('.') . When that loop is finished, the program will be complete.\n\nTo test your program, download removeCsvHeader.zip from https://nostarch.com/automatestuff2/ and unzip it to a folder. Run the removeCsvHeader.py program in that folder. The output will look like this:\n\nRemoving header from NAICS_data_1048.csv... Removing header from NAICS_data_1218.csv... -- snip -- Removing header from NAICS_data_9834.csv... Removing header from NAICS_data_9986.csv...\n\nThis program should print a filename each time it strips the first line from a CSV file.\n\nThe programs that you could write for CSV files are similar to the kinds you could write for Excel files, since they\u2019re both spreadsheet files. You could write programs to do the following:\n\n* Compare data between different rows in a CSV file or between multiple CSV files.\n* Copy specific data from a CSV file to an Excel file, or vice versa.\n* Check for invalid data or formatting mistakes in CSV files and alert the user to these errors.\n* Read data from a CSV file as input for your Python programs.", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "Explain the concept of 'JSON and APIs' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "JavaScript Object Notation is a popular way to format data as a single human-readable string. JSON is the native way that JavaScript programs write their data structures and usually resembles what Python\u2019s pprint() function would produce. You don\u2019t need to know JavaScript in order to work with JSON-formatted data.\n\nHere\u2019s an example of data formatted as JSON:\n\n{\"name\": \"Zophie\", \"isCat\": true, \"miceCaught\": 0, \"napsTaken\": 37.5, \"felineIQ\": null}\n\nJSON is useful to know, because many websites offer JSON content as a way for programs to interact with the website. This is known as providing an application programming interface (API) . Accessing an API is the same as accessing any other web page via a URL. The difference is that the data returned by an API is formatted (with JSON, for example) for machines; APIs aren\u2019t easy for people to read.\n\nMany websites make their data available in JSON format. Facebook, Twitter, Yahoo, Google, Tumblr, Wikipedia, Flickr, Data.gov, Reddit, IMDb, Rotten Tomatoes, LinkedIn, and many other popular sites offer APIs for programs to use. Some of these sites require registration, which is almost always free. You\u2019ll have to find documentation for what URLs your program needs to request in order to get the data you want, as well as the general format of the JSON data structures that are returned. This documentation should be provided by whatever site is offering the API; if they have a \u201cDevelopers\u201d page, look for the documentation there.\n\nUsing APIs, you could write programs that do the following:\n\n* Scrape raw data from websites. (Accessing APIs is often more convenient than downloading web pages and parsing HTML with Beautiful Soup.)\n* Automatically download new posts from one of your social network accounts and post them to another account. For example, you could take your Tumblr posts and post them to Facebook.\n* Create a \u201cmovie encyclopedia\u201d for your personal movie collection by pulling data from IMDb, Rotten Tomatoes, and Wikipedia and putting it into a single text file on your computer.\n\nYou can see some examples of JSON APIs in the resources at https://nostarch.com/automatestuff2/ .\n\nJSON isn\u2019t the only way to format data into a human-readable string. There are many others, including XML (eXtensible Markup Language), TOML (Tom\u2019s Obvious, Minimal Language), YML (Yet another Markup Language), INI (Initialization), or even the outdated ASN.1 (Abstract Syntax Notation One) formats, all of which provide a structure for representing data as human-readable text. This book won\u2019t cover these, because JSON has quickly become the most widely used alternate format, but there are third-party Python modules that readily handle them.", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "Explain the concept of 'The json Module' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Python\u2019s json module handles all the details of translating between a string with JSON data and Python values for the json.loads() and json.dumps() functions. JSON can\u2019t store every kind of Python value. It can contain values of only the following data types: strings, integers, floats, Booleans, lists, dictionaries, and NoneType . JSON cannot represent Python-specific objects, such as File objects, CSV reader or writer objects, Regex objects, or Selenium WebElement objects.\n\nTo translate a string containing JSON data into a Python value, pass it to the json.loads() function. (The name means \u201cload string,\u201d not \u201cloads.\u201d) Enter the following into the interactive shell:\n\n>>> stringOfJsonData = '{\"name\": \"Zophie\", \"isCat\": true, \"miceCaught\": 0, \"felineIQ\": null}' >>> import json >>> jsonDataAsPythonValue = json.loads(stringOfJsonData) >>> jsonDataAsPythonValue {'isCat': True, 'miceCaught': 0, 'name': 'Zophie', 'felineIQ': None}\n\nAfter you import the json module, you can call loads() and pass it a string of JSON data. Note that JSON strings always use double quotes. It will return that data as a Python dictionary. Python dictionaries are not ordered, so the key-value pairs may appear in a different order when you print jsonDataAsPythonValue .\n\nThe json.dumps() function (which means \u201cdump string,\u201d not \u201cdumps\u201d) will translate a Python value into a string of JSON-formatted data. Enter the following into the interactive shell:\n\n>>> pythonValue = {'isCat': True, 'miceCaught': 0, 'name': 'Zophie', 'felineIQ': None} >>> import json >>> stringOfJsonData = json.dumps(pythonValue) >>> stringOfJsonData '{\"isCat\": true, \"felineIQ\": null, \"miceCaught\": 0, \"name\": \"Zophie\" }'\n\nThe value can only be one of the following basic Python data types: dictionary, list, integer, float, string, Boolean, or None .", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "What is 'Project: Fetching Current Weather Data' and how does it work in Python?", "input": "", "output": "Checking the weather seems fairly trivial: Open your web browser, click the address bar, type the URL to a weather website (or search for one and then click the link), wait for the page to load, look past all the ads, and so on.\n\nActually, there are a lot of boring steps you could skip if you had a program that downloaded the weather forecast for the next few days and printed it as plaintext. This program uses the requests module from Chapter 12 to download data from the web.\n\nOverall, the program does the following:\n\n1. Reads the requested location from the command line\n2. Downloads JSON weather data from OpenWeatherMap.org\n3. Converts the string of JSON data to a Python data structure\n4. Prints the weather for today and the next two days\n\nSo the code will need to do the following:\n\n1. Join strings in sys.argv to get the location.\n2. Call requests.get() to download the weather data.\n3. Call json.loads() to convert the JSON data to a Python data structure.\n4. Print the weather forecast.\n\nFor this project, open a new file editor window and save it as getOpenWeather.py . Then visit https://openweathermap.org/api/ in your browser and sign up for a free account to obtain an API key , also called an app ID, which for the OpenWeatherMap service is a string code that looks something like '30144aba38018987d84710d0e319281e' . You don\u2019t need to pay for this service unless you plan on making more than 60 API calls per minute. Keep the API key secret; anyone who knows it can write scripts that use your account\u2019s usage quota.\n\nThe input for this program will come from the command line. Make getOpenWeather.py look like this:\n\n#! python3 # getOpenWeather.py - Prints the weather for a location from the command line. APPID = 'YOUR_APPID_HERE' import json, requests, sys # Compute location from command line arguments. if len(sys.argv) < 2: print('Usage: getOpenWeather.py city_name, 2-letter_country_code') sys.exit() location = ' '.join(sys.argv[1:]) # TODO: Download the JSON data from OpenWeatherMap.org's API. # TODO: Load JSON data into a Python variable.\n\nIn Python, command line arguments are stored in the sys.argv list. The APPID variable should be set to the API key for your account. Without this key, your requests to the weather service will fail. After the #! shebang line and import statements, the program will check that there is more than one command line argument. (Recall that sys.argv will always have at least one element, sys.argv[0] , which contains the Python script\u2019s filename.) If there is only one element in the list, then the user didn\u2019t provide a location on the command line, and a \u201cusage\u201d message will be provided to the user before the program ends.\n\nThe OpenWeatherMap service requires that the query be formatted as the city name, a comma, and a two-letter country code (like \u201cUS\u201d for the United States). You can find a list of these codes at https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2 . Our script displays the weather for the first city listed in the retrieved JSON text. Unfortunately, cities that share a name, like Portland, Oregon, and Portland, Maine, will both be included, though the JSON text will include longitude and latitude information to differentiate between the cities.\n\nCommand line arguments are split on spaces. The command line argument San Francisco, US would make sys.argv hold ['getOpenWeather.py', 'San', 'Francisco,', 'US'] . Therefore, call the join() method to join all the strings except for the first in sys.argv . Store this joined string in a variable named location .\n\nOpenWeatherMap.org provides real-time weather information in JSON format. First you must sign up for a free API key on the site. (This key is used to limit how frequently you make requests on their server, to keep their bandwidth costs down.) Your program simply has to download the page at https://api.openweathermap.org/data/2.5/forecast/daily?q=<Location>&cnt=3&APPID=<APIkey> , where <Location> is the name of the city whose weather you want and <API key> is your personal API key. Add the following to getOpenWeather.py .\n\n#! python3 # getOpenWeather.py - Prints the weather for a location from the command line. -- snip -- # Download the JSON data from OpenWeatherMap.org's API. url ='https://api.openweathermap.org/data/2.5/forecast/daily?q=%s&cnt=3&APPID=%s ' % (location, APPID) response = requests.get(url) response.raise_for_status() # Uncomment to see the raw JSON text: #print(response.text) # TODO: Load JSON data into a Python variable.\n\nWe have location from our command line arguments. To make the URL we want to access, we use the %s placeholder and insert whatever string is stored in location into that spot in the URL string. We store the result in url and pass url to requests.get() . The requests.get() call returns a Response object, which you can check for errors by calling raise_for_status() . If no exception is raised, the downloaded text will be in response.text .\n\nThe response.text member variable holds a large string of JSON-formatted data. To convert this to a Python value, call the json.loads() function. The JSON data will look something like this:\n\n{'city': {'coord': {'lat': 37.7771, 'lon': -122.42}, 'country': 'United States of America', 'id': '5391959', 'name': 'San Francisco', 'population': 0}, 'cnt': 3, 'cod': '200', 'list': [{'clouds': 0, 'deg': 233, 'dt': 1402344000, 'humidity': 58, 'pressure': 1012.23, 'speed': 1.96, 'temp': {'day': 302.29, 'eve': 296.46, 'max': 302.29, 'min': 289.77, 'morn': 294.59, 'night': 289.77}, 'weather': [{'description': 'sky is clear', 'icon': '01d', -- snip --\n\nYou can see this data by passing weatherData to pprint.pprint() . You may want to check https://openweathermap.org/ for more documentation on what these fields mean. For example, the online documentation will tell you that the 302.29 after 'day' is the daytime temperature in Kelvin, not Celsius or Fahrenheit.\n\nThe weather descriptions you want are after 'main' and 'description' . To neatly print them out, add the following to getOpenWeather.py .\n\n! python3 # getOpenWeather.py - Prints the weather for a location from the command line. -- snip -- # Load JSON data into a Python variable. weatherData = json.loads(response.text) # Print weather descriptions. \u278a w = weatherData['list'] print('Current weather in %s:' % (location)) print(w[0]['weather'][0]['main'], '-', w[0]['weather'][0]['description']) print() print('Tomorrow:') print(w[1]['weather'][0]['main'], '-', w[1]['weather'][0]['description']) print() print('Day after tomorrow:') print(w[2]['weather'][0]['main'], '-', w[2]['weather'][0]['description'])\n\nNotice how the code stores weatherData['list'] in the variable w to save you some typing \u278a . You use w[0] , w[1] , and w[2] to retrieve the dictionaries for today, tomorrow, and the day after tomorrow\u2019s weather, respectively. Each of these dictionaries has a 'weather' key, which contains a list value. You\u2019re interested in the first list item, a nested dictionary with several more keys, at index 0. Here, we print the values stored in the 'main' and 'description' keys, separated by a hyphen.\n\nWhen this program is run with the command line argument getOpenWeather.py San Francisco, CA , the output looks something like this:\n\nCurrent weather in San Francisco, CA: Clear - sky is clear Tomorrow: Clouds - few clouds Day after tomorrow: Clear - sky is clear\n\n(The weather is one of the reasons I like living in San Francisco!)\n\nAccessing weather data can form the basis for many types of programs. You can create similar programs to do the following:\n\n* Collect weather forecasts for several campsites or hiking trails to see which one will have the best weather.\n* Schedule a program to regularly check the weather and send you a frost alert if you need to move your plants indoors. (Chapter 17 covers scheduling, and Chapter 18 explains how to send email.)\n* Pull weather data from multiple sites to show all at once, or calculate and show the average of the multiple weather predictions.", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "What is 'Practice Project' and how does it work in Python?", "input": "", "output": "For practice, write a program that does the following.\n\nExcel can save a spreadsheet to a CSV file with a few mouse clicks, but if you had to convert hundreds of Excel files to CSVs, it would take hours of clicking. Using the openpyxl module from Chapter 12, write a program that reads all the Excel files in the current working directory and outputs them as CSV files.\n\nA single Excel file might contain multiple sheets; you\u2019ll have to create one CSV file per sheet . The filenames of the CSV files should be <excel filename>_<sheet title>.csv , where <excel filename> is the filename of the Excel file without the file extension (for example, 'spam_data' , not 'spam_data.xlsx' ) and <sheet title> is the string from the Worksheet object\u2019s title variable.\n\nThis program will involve many nested for loops. The skeleton of the program will look something like this:\n\nfor excelFile in os.listdir('.'): # Skip non-xlsx files, load the workbook object. for sheetName in wb.get_sheet_names(): # Loop through every sheet in the workbook. sheet = wb.get_sheet_by_name(sheetName) # Create the CSV filename from the Excel filename and sheet title. # Create the csv.writer object for this CSV file. # Loop through every row in the sheet. for rowNum in range(1, sheet.max_row + 1): rowData = []\u00a0\u00a0\u00a0\u00a0# append each cell to this list # Loop through each cell in the row. for colNum in range(1, sheet.max_column + 1): # Append each cell's data to rowData. # Write the rowData list to the CSV file. csvFile.close()\n\nDownload the ZIP file excelSpreadsheets.zip from https://nostarch.com/automatestuff2/ and unzip the spreadsheets into the same directory as your program. You can use these as the files to test the program on.", "source": "https://automatetheboringstuff.com/2e/chapter16/", "category": "16WORKING WITH CSV FILES AND JSON DATA"}
{"instruction": "Explain the concept of '17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Running programs while you\u2019re sitting at your computer is fine, but it\u2019s also useful to have programs run without your direct supervision. Your computer\u2019s clock can schedule programs to run code at some specified time and date or at regular intervals. For example, your program could scrape a website every hour to check for changes or do a CPU-intensive task at 4 AM while you sleep. Python\u2019s time and datetime modules provide these functions.\n\nYou can also write programs that launch other programs on a schedule by using the subprocess and threading modules. Often, the fastest way to program is to take advantage of applications that other people have already written.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "How do I use 'The time Module' in Python?", "input": "", "output": "Your computer\u2019s system clock is set to a specific date, time, and time zone. The built-in time module allows your Python programs to read the system clock for the current time. The time.time() and time.sleep() functions are the most useful in the time module.\n\nThe Unix epoch is a time reference commonly used in programming: 12 AM on January 1, 1970, Coordinated Universal Time (UTC). The time.time() function returns the number of seconds since that moment as a float value. (Recall that a float is just a number with a decimal point.) This number is called an epoch timestamp . For example, enter the following into the interactive shell:\n\n>>> import time >>> time.time() 1543813875.3518236\n\nHere I\u2019m calling time.time() on December 2, 2018, at 9:11 PM Pacific Standard Time. The return value is how many seconds have passed between the Unix epoch and the moment time.time() was called.\n\nEpoch timestamps can be used to profile code, that is, measure how long a piece of code takes to run. If you call time.time() at the beginning of the code block you want to measure and again at the end, you can subtract the first timestamp from the second to find the elapsed time between those two calls. For example, open a new file editor tab and enter the following program:\n\nimport time \u278a def calcProd(): # Calculate the product of the first 100,000 numbers. product = 1 for i in range(1, 100000): product = product * i return product \u278b startTime = time.time() prod = calcProd() \u278c endTime = time.time() \u278d print('The result is %s digits long.' % (len(str(prod)))) \u278e print('Took %s seconds to calculate.' % (endTime - startTime))\n\nAt \u278a , we define a function calcProd() to loop through the integers from 1 to 99,999 and return their product. At \u278b , we call time.time() and store it in startTime . Right after calling calcProd() , we call time.time() again and store it in endTime \u278c . We end by printing the length of the product returned by calcProd() \u278d and how long it took to run calcProd() \u278e .\n\nSave this program as calcProd.py and run it. The output will look something like this:\n\nThe result is 456569 digits long. Took 2.844162940979004 seconds to calculate.\n\nThe return value from time.time() is useful, but not human-readable. The time.ctime() function returns a string description of the current time. You can also optionally pass the number of seconds since the Unix epoch, as returned by time.time() , to get a string value of that time. Enter the following into the interactive shell:\n\n>>> import time >>> time.ctime() 'Mon Jun 15 14:00:38 2020' >>> thisMoment = time.time() >>> time.ctime(thisMoment) 'Mon Jun 15 14:00:45 2020'\n\nIf you need to pause your program for a while, call the time.sleep() function and pass it the number of seconds you want your program to stay paused. Enter the following into the interactive shell:\n\n>>> import time >>> for i in range(3): \u278a print('Tick') \u278b time.sleep(1) \u278c print('Tock') \u278d time.sleep(1) Tick Tock Tick Tock Tick Tock \u278e >>> time.sleep(5)\n\nThe for loop will print Tick \u278a , pause for 1 second \u278b , print Tock \u278c , pause for 1 second \u278d , print Tick , pause, and so on until Tick and Tock have each been printed three times.\n\nThe time.sleep() function will block \u2014that is, it will not return and release your program to execute other code\u2014until after the number of seconds you passed to time.sleep() has elapsed. For example, if you enter time.sleep(5) \u278e , you\u2019ll see that the next prompt ( >>> ) doesn\u2019t appear until 5 seconds have passed.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "Provide a guide on 'Rounding Numbers' in Python.", "input": "", "output": "When working with times, you\u2019ll often encounter float values with many digits after the decimal. To make these values easier to work with, you can shorten them with Python\u2019s built-in round() function, which rounds a float to the precision you specify. Just pass in the number you want to round, plus an optional second argument representing how many digits after the decimal point you want to round it to. If you omit the second argument, round() rounds your number to the nearest whole integer. Enter the following into the interactive shell:\n\n>>> import time >>> now = time.time() >>> now 1543814036.6147408 >>> round(now, 2) 1543814036.61 >>> round(now, 4) 1543814036.6147 >>> round(now) 1543814037\n\nAfter importing time and storing time.time() in now , we call round(now, 2) to round now to two digits after the decimal, round(now, 4) to round to four digits after the decimal, and round(now) to round to the nearest integer.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "How do I use 'Project: Super Stopwatch' in Python?", "input": "", "output": "Say you want to track how much time you spend on boring tasks you haven\u2019t automated yet. You don\u2019t have a physical stopwatch, and it\u2019s surprisingly difficult to find a free stopwatch app for your laptop or smartphone that isn\u2019t covered in ads and doesn\u2019t send a copy of your browser history to marketers. (It says it can do this in the license agreement you agreed to. You did read the license agreement, didn\u2019t you?) You can write a simple stopwatch program yourself in Python.\n\nAt a high level, here\u2019s what your program will do:\n\n1. Track the amount of time elapsed between presses of the ENTER key, with each key press starting a new \u201clap\u201d on the timer.\n2. Print the lap number, total time, and lap time.\n\nThis means your code will need to do the following:\n\n1. Find the current time by calling time.time() and store it as a timestamp at the start of the program, as well as at the start of each lap.\n2. Keep a lap counter and increment it every time the user presses ENTER .\n3. Calculate the elapsed time by subtracting timestamps.\n4. Handle the KeyboardInterrupt exception so the user can press CTRL -C to quit.\n\nOpen a new file editor tab and save it as stopwatch.py .\n\nThe stopwatch program will need to use the current time, so you\u2019ll want to import the time module. Your program should also print some brief instructions to the user before calling input() , so the timer can begin after the user presses ENTER . Then the code will start tracking lap times.\n\nEnter the following code into the file editor, writing a TODO comment as a placeholder for the rest of the code:\n\n#! python3 # stopwatch.py - A simple stopwatch program. import time # Display the program's instructions. print('Press ENTER to begin. Afterward, press ENTER to \"click\" the stopwatch. Press Ctrl-C to quit.') input()\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# press Enter to begin print('Started.') startTime = time.time()\u00a0\u00a0\u00a0\u00a0# get the first lap's start time lastTime = startTime lapNum = 1 # TODO: Start tracking the lap times.\n\nNow that we\u2019ve written the code to display the instructions, start the first lap, note the time, and set our lap count to 1.\n\nNow let\u2019s write the code to start each new lap, calculate how long the previous lap took, and calculate the total time elapsed since starting the stopwatch. We\u2019ll display the lap time and total time and increase the lap count for each new lap. Add the following code to your program:\n\n#! python3 # stopwatch.py - A simple stopwatch program. import time -- snip -- # Start tracking the lap times. \u278a try: \u278b while True: input() \u278c lapTime = round(time.time() - lastTime, 2) \u278d totalTime = round(time.time() - startTime, 2) \u278e print('Lap #%s: %s (%s)' % (lapNum, totalTime, lapTime), end='') lapNum += 1 lastTime = time.time() # reset the last lap time \u278f except KeyboardInterrupt: # Handle the Ctrl-C exception to keep its error message from displaying. print('\\nDone.')\n\nIf the user presses CTRL -C to stop the stopwatch, the KeyboardInterrupt exception will be raised, and the program will crash if its execution is not a try statement. To prevent crashing, we wrap this part of the program in a try statement \u278a . We\u2019ll handle the exception in the except clause \u278f , so when CTRL -C is pressed and the exception is raised, the program execution moves to the except clause to print Done , instead of the KeyboardInterrupt error message. Until this happens, the execution is inside an infinite loop \u278b that calls input() and waits until the user presses ENTER to end a lap. When a lap ends, we calculate how long the lap took by subtracting the start time of the lap, lastTime , from the current time, time.time() \u278c . We calculate the total time elapsed by subtracting the overall start time of the stopwatch, startTime , from the current time \u278d .\n\nSince the results of these time calculations will have many digits after the decimal point (such as 4.766272783279419 ), we use the round() function to round the float value to two digits at \u278c and \u278d .\n\nAt \u278e , we print the lap number, total time elapsed, and the lap time. Since the user pressing ENTER for the input() call will print a newline to the screen, pass end='' to the print() function to avoid double-spacing the output. After printing the lap information, we get ready for the next lap by adding 1 to the count lapNum and setting lastTime to the current time, which is the start time of the next lap.\n\nTime tracking opens up several possibilities for your programs. Although you can download apps to do some of these things, the benefit of writing programs yourself is that they will be free and not bloated with ads and useless features. You could write similar programs to do the following:\n\n* Create a simple timesheet app that records when you type a person\u2019s name and uses the current time to clock them in or out.\n* Add a feature to your program to display the elapsed time since a process started, such as a download that uses the requests module. (See Chapter 12.)\n* Intermittently check how long a program has been running and offer the user a chance to cancel tasks that are taking too long.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "How do I use 'The datetime Module' in Python?", "input": "", "output": "The time module is useful for getting a Unix epoch timestamp to work with. But if you want to display a date in a more convenient format, or do arithmetic with dates (for example, figuring out what date was 205 days ago or what date is 123 days from now), you should use the datetime module.\n\nThe datetime module has its own datetime data type. datetime values represent a specific moment in time. Enter the following into the interactive shell:\n\n>>> import datetime \u278a >>> datetime.datetime.now() \u278b datetime.datetime(2019, 2, 27, 11, 10, 49, 55, 53) \u278c >>> dt = datetime.datetime(2019, 10, 21, 16, 29, 0) \u278d >>> dt.year, dt.month, dt.day (2019, 10, 21) \u278e >>> dt.hour, dt.minute, dt.second (16, 29, 0)\n\nCalling datetime.datetime.now() \u278a returns a datetime object \u278b for the current date and time, according to your computer\u2019s clock. This object includes the year, month, day, hour, minute, second, and microsecond of the current moment. You can also retrieve a datetime object for a specific moment by using the datetime.datetime() function \u278c , passing it integers representing the year, month, day, hour, and second of the moment you want. These integers will be stored in the datetime object\u2019s year , month , day \u278d , hour , minute , and second \u278e attributes.\n\nA Unix epoch timestamp can be converted to a datetime object with the datetime.datetime.fromtimestamp() function. The date and time of the datetime object will be converted for the local time zone. Enter the following into the interactive shell:\n\n>>> import datetime, time >>> datetime.datetime.fromtimestamp(1000000) datetime.datetime(1970, 1, 12, 5, 46, 40) >>> datetime.datetime.fromtimestamp(time.time()) datetime.datetime(2019, 10, 21, 16, 30, 0, 604980)\n\nCalling datetime.datetime.fromtimestamp() and passing it 1000000 returns a datetime object for the moment 1,000,000 seconds after the Unix epoch. Passing time.time() , the Unix epoch timestamp for the current moment, returns a datetime object for the current moment. So the expressions datetime.datetime.now() and datetime.datetime.fromtimestamp(time.time()) do the same thing; they both give you a datetime object for the present moment.\n\nYou can compare datetime objects with each other using comparison operators to find out which one precedes the other. The later datetime object is the \u201cgreater\u201d value. Enter the following into the interactive shell:\n\n\u278a >>> halloween2019 = datetime.datetime(2019, 10, 31, 0, 0, 0) \u278b >>> newyears2020 = datetime.datetime(2020, 1, 1, 0, 0, 0) >>> oct31_2019 = datetime.datetime(2019, 10, 31, 0, 0, 0) \u278c >>> halloween2019 == oct31_2019 True \u278d >>> halloween2019 > newyears2020 False \u278e >>> newyears2020 > halloween2019 True >>> newyears2020 != oct31_2019 True\n\nMake a datetime object for the first moment (midnight) of October 31, 2019, and store it in halloween2019 \u278a . Make a datetime object for the first moment of January 1, 2020, and store it in newyears2020 \u278b . Then make another object for midnight on October 31, 2019, and store it in oct31_2019 . Comparing halloween2019 and oct31_2019 shows that they\u2019re equal \u278c . Comparing newyears2020 and halloween2019 shows that newyears2020 is greater (later) than halloween2019 \u278d \u278e .\n\nThe datetime module also provides a timedelta data type, which represents a duration of time rather than a moment in time. Enter the following into the interactive shell:\n\n\u278a >>> delta = datetime.timedelta(days=11, hours=10, minutes=9, seconds=8) \u278b >>> delta.days, delta.seconds, delta.microseconds (11, 36548, 0) >>> delta.total_seconds() 986948.0 >>> str(delta) '11 days, 10:09:08'\n\nTo create a timedelta object, use the datetime.timedelta() function. The datetime.timedelta() function takes keyword arguments weeks , days , hours , minutes , seconds , milliseconds , and microseconds . There is no month or year keyword argument, because \u201ca month\u201d or \u201ca year\u201d is a variable amount of time depending on the particular month or year. A timedelta object has the total duration represented in days, seconds, and microseconds. These numbers are stored in the days , seconds , and microseconds attributes, respectively. The total_seconds() method will return the duration in number of seconds alone. Passing a timedelta object to str() will return a nicely formatted, human-readable string representation of the object.\n\nIn this example, we pass keyword arguments to datetime.delta() to specify a duration of 11 days, 10 hours, 9 minutes, and 8 seconds, and store the returned timedelta object in delta \u278a . This timedelta object\u2019s days attributes stores 11 , and its seconds attribute stores 36548 (10 hours, 9 minutes, and 8 seconds, expressed in seconds) \u278b . Calling total_seconds() tells us that 11 days, 10 hours, 9 minutes, and 8 seconds is 986,948 seconds. Finally, passing the timedelta object to str() returns a string that plainly describes the duration.\n\nThe arithmetic operators can be used to perform date arithmetic on datetime values. For example, to calculate the date 1,000 days from now, enter the following into the interactive shell:\n\n>>> dt = datetime.datetime.now() >>> dt datetime.datetime(2018, 12, 2, 18, 38, 50, 636181) >>> thousandDays = datetime.timedelta(days=1000) >>> dt + thousandDays datetime.datetime(2021, 8, 28, 18, 38, 50, 636181)\n\nFirst, make a datetime object for the current moment and store it in dt . Then make a timedelta object for a duration of 1,000 days and store it in thousandDays . Add dt and thousandDays together to get a datetime object for the date 1,000 days from now. Python will do the date arithmetic to figure out that 1,000 days after December 2, 2018, will be August 18, 2021. This is useful because when you calculate 1,000 days from a given date, you have to remember how many days are in each month and factor in leap years and other tricky details. The datetime module handles all of this for you.\n\ntimedelta objects can be added or subtracted with datetime objects or other timedelta objects using the + and - operators. A timedelta object can be multiplied or divided by integer or float values with the * and / operators. Enter the following into the interactive shell:\n\n\u278a >>> oct21st = datetime.datetime(2019, 10, 21, 16, 29, 0) \u278b >>> aboutThirtyYears = datetime.timedelta(days=365 * 30) >>> oct21st datetime.datetime(2019, 10, 21, 16, 29) >>> oct21st - aboutThirtyYears datetime.datetime(1989, 10, 28, 16, 29) >>> oct21st - (2 * aboutThirtyYears) datetime.datetime(1959, 11, 5, 16, 29)\n\nHere we make a datetime object for October 21, 2019, \u278a and a timedelta object for a duration of about 30 years (we\u2019re assuming 365 days for each of those years) \u278b . Subtracting aboutThirtyYears from oct21st gives us a datetime object for the date 30 years before October 21, 2019. Subtracting 2 * aboutThirtyYears from oct21st returns a datetime object for the date 60 years before October 21, 2019.\n\nThe time.sleep() method lets you pause a program for a certain number of seconds. By using a while loop, you can pause your programs until a specific date. For example, the following code will continue to loop until Halloween 2016:\n\nimport datetime import time halloween2016 = datetime.datetime(2016, 10, 31, 0, 0, 0) while datetime.datetime.now() < halloween2016: time.sleep(1)\n\nThe time.sleep(1) call will pause your Python program so that the computer doesn\u2019t waste CPU processing cycles simply checking the time over and over. Rather, the while loop will just check the condition once per second and continue with the rest of the program after Halloween 2016 (or whenever you program it to stop).\n\nEpoch timestamps and datetime objects aren\u2019t very friendly to the human eye. Use the strftime() method to display a datetime object as a string. (The f in the name of the strftime() function stands for format .)\n\nThe strftime() method uses directives similar to Python\u2019s string formatting. Table 17-1 has a full list of strftime() directives.\n\nTable 17-1: strftime() Directives\n\nPass strftime() a custom format string containing formatting directives (along with any desired slashes, colons, and so on), and strftime() will return the datetime object\u2019s information as a formatted string. Enter the following into the interactive shell:\n\n>>> oct21st = datetime.datetime(2019, 10, 21, 16, 29, 0) >>> oct21st.strftime('%Y/%m/%d %H:%M:%S') '2019/10/21 16:29:00' >>> oct21st.strftime('%I:%M %p') '04:29 PM' >>> oct21st.strftime(\"%B of '%y\") \"October of '19\"\n\nHere we have a datetime object for October 21, 2019, at 4:29 PM , stored in oct21st . Passing strftime() the custom format string '%Y/%m/%d %H:%M:%S' returns a string containing 2019, 10, and 21 separated by slashes and 16, 29, and 00 separated by colons. Passing '%I:%M% p' returns '04:29 PM' , and passing \"%B of '%y\" returns \"October of '19\" . Note that strftime() doesn\u2019t begin with datetime.datetime .\n\nIf you have a string of date information, such as '2019/10/21 16:29:00' or 'October 21, 2019' , and need to convert it to a datetime object, use the datetime.datetime.strptime() function. The strptime() function is the inverse of the strftime() method. A custom format string using the same directives as strftime() must be passed so that strptime() knows how to parse and understand the string. (The p in the name of the strptime() function stands for parse .)\n\nEnter the following into the interactive shell:\n\n\u278a >>> datetime.datetime.strptime('October 21, 2019', '%B %d, %Y') datetime.datetime(2019, 10, 21, 0, 0) >>> datetime.datetime.strptime('2019/10/21 16:29:00', '%Y/%m/%d %H:%M:%S') datetime.datetime(2019, 10, 21, 16, 29) >>> datetime.datetime.strptime(\"October of '19\", \"%B of '%y\") datetime.datetime(2019, 10, 1, 0, 0) >>> datetime.datetime.strptime(\"November of '63\", \"%B of '%y\") datetime.datetime(2063, 11, 1, 0, 0)\n\nTo get a datetime object from the string 'October 21, 2019' , pass that string as the first argument to strptime() and the custom format string that corresponds to 'October 21, 2019' as the second argument \u278a . The string with the date information must match the custom format string exactly, or Python will raise a ValueError exception.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "Provide a guide on 'Review of Python\u2019s Time Functions' in Python.", "input": "", "output": "Dates and times in Python can involve quite a few different data types and functions. Here\u2019s a review of the three different types of values used to represent time:\n\n* A Unix epoch timestamp (used by the time module) is a float or integer value of the number of seconds since 12 AM on January 1, 1970, UTC.\n* A datetime object (of the datetime module) has integers stored in the attributes year , month , day , hour , minute , and second .\n* A timedelta object (of the datetime module) represents a time duration, rather than a specific moment.\n\nHere\u2019s a review of time functions and their parameters and return values:\n\ntime.time() This function returns an epoch timestamp float value of the current moment.\n\ntime.sleep( seconds ) This function stops the program for the number of seconds specified by the seconds argument.\n\ndatetime.datetime( year , month , day , hour , minute , second ) This function returns a datetime object of the moment specified by the arguments. If hour , minute , or second arguments are not provided, they default to 0 .\n\ndatetime.datetime.now() This function returns a datetime object of the current moment.\n\ndatetime.datetime.fromtimestamp( epoch ) This function returns a datetime object of the moment represented by the epoch timestamp argument.\n\ndatetime.timedelta( weeks , days , hours , minutes , seconds , milliseconds , microseconds ) This function returns a timedelta object representing a duration of time. The function\u2019s keyword arguments are all optional and do not include month or year .\n\ntotal_seconds() This method for timedelta objects returns the number of seconds the timedelta object represents.\n\nstrftime( format ) This method returns a string of the time represented by the datetime object in a custom format that\u2019s based on the format string. See Table 17-1 for the format details.\n\ndatetime.datetime.strptime( time_string , format ) This function returns a datetime object of the moment specified by time_string , parsed using the format string argument. See Table 17-1 for the format details.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "What is 'Multithreading' and how does it work in Python?", "input": "", "output": "To introduce the concept of multithreading, let\u2019s look at an example situation. Say you want to schedule some code to run after a delay or at a specific time. You could add code like the following at the start of your program:\n\nimport time, datetime startTime = datetime.datetime(2029, 10, 31, 0, 0, 0) while datetime.datetime.now() < startTime: time.sleep(1) print('Program now starting on Halloween 2029') -- snip --\n\nThis code designates a start time of October 31, 2029, and keeps calling time.sleep(1) until the start time arrives. Your program cannot do anything while waiting for the loop of time.sleep() calls to finish; it just sits around until Halloween 2029. This is because Python programs by default have a single thread of execution.\n\nTo understand what a thread of execution is, remember the Chapter 2 discussion of flow control, when you imagined the execution of a program as placing your finger on a line of code in your program and moving to the next line or wherever it was sent by a flow control statement. A single-threaded program has only one finger. But a multithreaded program has multiple fingers. Each finger still moves to the next line of code as defined by the flow control statements, but the fingers can be at different places in the program, executing different lines of code at the same time. (All of the programs in this book so far have been single threaded.)\n\nRather than having all of your code wait until the time.sleep() function finishes, you can execute the delayed or scheduled code in a separate thread using Python\u2019s threading module. The separate thread will pause for the time.sleep calls. Meanwhile, your program can do other work in the original thread.\n\nTo make a separate thread, you first need to make a Thread object by calling the threading.Thread() function. Enter the following code in a new file and save it as threadDemo.py :\n\nimport threading, time print('Start of program.') \u278a def takeANap(): time.sleep(5) print('Wake up!') \u278b threadObj = threading.Thread(target=takeANap) \u278c threadObj.start() print('End of program.')\n\nAt \u278a , we define a function that we want to use in a new thread. To create a Thread object, we call threading.Thread() and pass it the keyword argument target=takeANap \u278b . This means the function we want to call in the new thread is takeANap() . Notice that the keyword argument is target=takeANap , not target=takeANap() . This is because you want to pass the takeANap() function itself as the argument, not call takeANap() and pass its return value.\n\nAfter we store the Thread object created by threading.Thread() in threadObj , we call threadObj.start() \u278c to create the new thread and start executing the target function in the new thread. When this program is run, the output will look like this:\n\nStart of program. End of program. Wake up!\n\nThis can be a bit confusing. If print('End of program.') is the last line of the program, you might think that it should be the last thing printed. The reason Wake up! comes after it is that when threadObj.start() is called, the target function for threadObj is run in a new thread of execution. Think of it as a second finger appearing at the start of the takeANap() function. The main thread continues to print('End of program.') . Meanwhile, the new thread that has been executing the time.sleep(5) call, pauses for 5 seconds. After it wakes from its 5-second nap, it prints 'Wake up!' and then returns from the takeANap() function. Chronologically, 'Wake up!' is the last thing printed by the program.\n\nNormally a program terminates when the last line of code in the file has run (or the sys.exit() function is called). But threadDemo.py has two threads. The first is the original thread that began at the start of the program and ends after print('End of program.') . The second thread is created when threadObj.start() is called, begins at the start of the takeANap() function, and ends after takeANap() returns.\n\nA Python program will not terminate until all its threads have terminated. When you ran threadDemo.py , even though the original thread had terminated, the second thread was still executing the time.sleep(5) call.\n\nIf the target function you want to run in the new thread takes arguments, you can pass the target function\u2019s arguments to threading.Thread() . For example, say you wanted to run this print() call in its own thread:\n\n>>> print('Cats', 'Dogs', 'Frogs', sep=' & ') Cats & Dogs & Frogs\n\nThis print() call has three regular arguments, 'Cats' , 'Dogs' , and 'Frogs' , and one keyword argument, sep=' & ' . The regular arguments can be passed as a list to the args keyword argument in threading.Thread() . The keyword argument can be specified as a dictionary to the kwargs keyword argument in threading.Thread() .\n\nEnter the following into the interactive shell:\n\n>>> import threading >>> threadObj = threading.Thread(target=print, args=['Cats', 'Dogs', 'Frogs'], kwargs={'sep': ' & '}) >>> threadObj.start() Cats & Dogs & Frogs\n\nTo make sure the arguments 'Cats' , 'Dogs' , and 'Frogs' get passed to print() in the new thread, we pass args=['Cats', 'Dogs', 'Frogs'] to threading.Thread() . To make sure the keyword argument sep=' & ' gets passed to print() in the new thread, we pass kwargs={'sep': '& '} to threading.Thread() .\n\nThe threadObj.start() call will create a new thread to call the print() function, and it will pass 'Cats' , 'Dogs' , and 'Frogs' as arguments and ' & ' for the sep keyword argument.\n\nThis is an incorrect way to create the new thread that calls print() :\n\nthreadObj = threading.Thread(target=print('Cats', 'Dogs', 'Frogs', sep=' & '))\n\nWhat this ends up doing is calling the print() function and passing its return value ( print() \u2019s return value is always None ) as the target keyword argument. It doesn\u2019t pass the print() function itself. When passing arguments to a function in a new thread, use the threading.Thread() function\u2019s args and kwargs keyword arguments.\n\nYou can easily create several new threads and have them all running at the same time. But multiple threads can also cause problems called concurrency issues . These issues happen when threads read and write variables at the same time, causing the threads to trip over each other. Concurrency issues can be hard to reproduce consistently, making them hard to debug.\n\nMultithreaded programming is its own wide subject and beyond the scope of this book. What you have to keep in mind is this: to avoid concurrency issues, never let multiple threads read or write the same variables. When you create a new Thread object, make sure its target function uses only local variables in that function. This will avoid hard-to-debug concurrency issues in your programs.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "Provide a guide on 'Project: Multithreaded XKCD Downloader' in Python.", "input": "", "output": "In Chapter 12, you wrote a program that downloaded all of the XKCD comic strips from the XKCD website. This was a single-threaded program: it downloaded one comic at a time. Much of the program\u2019s running time was spent establishing the network connection to begin the download and writing the downloaded images to the hard drive. If you have a broadband internet connection, your single-threaded program wasn\u2019t fully utilizing the available bandwidth.\n\nA multithreaded program that has some threads downloading comics while others are establishing connections and writing the comic image files to disk uses your internet connection more efficiently and downloads the collection of comics more quickly. Open a new file editor tab and save it as threadedDownloadXkcd.py . You will modify this program to add multithreading. The completely modified source code is available to download from https://nostarch.com/automatestuff2/ .\n\nThis program will mostly be the same downloading code from Chapter 12, so I\u2019ll skip the explanation for the requests and Beautiful Soup code. The main changes you need to make are importing the threading module and making a downloadXkcd() function, which takes starting and ending comic numbers as parameters.\n\nFor example, calling downloadXkcd(140, 280) would loop over the downloading code to download the comics at https://xkcd.com/140/ , https://xkcd.com/141/ , https://xkcd.com/142/ , and so on, up to https://xkcd.com/279/ . Each thread that you create will call downloadXkcd() and pass a different range of comics to download.\n\nAdd the following code to your threadedDownloadXkcd.py program:\n\n#! python3 # threadedDownloadXkcd.py - Downloads XKCD comics using multiple threads. import requests, os, bs4, threading \u278a os.makedirs('xkcd', exist_ok=True)\u00a0\u00a0\u00a0\u00a0# store comics in ./xkcd \u278b def downloadXkcd(startComic, endComic): \u278c for urlNumber in range(startComic, endComic): # Download the page. print('Downloading page https://xkcd.com/%s...' % (urlNumber)) \u278d res = requests.get('https://xkcd.com/%s' % (urlNumber)) res.raise_for_status() \u278e soup = bs4.BeautifulSoup(res.text, 'html.parser') # Find the URL of the comic image. \u278f comicElem = soup.select('#comic img') if comicElem == []: print('Could not find comic image.') else: \u2790 comicUrl = comicElem[0].get('src') # Download the image. print('Downloading image %s...' % (comicUrl)) \u2791 res = requests.get('https:' + comicUrl) res.raise_for_status() # Save the image to ./xkcd. imageFile = open(os.path.join('xkcd', os.path.basename(comicUrl)), 'wb') for chunk in res.iter_content(100000): imageFile.write(chunk) imageFile.close() # TODO: Create and start the Thread objects. # TODO: Wait for all threads to end.\n\nAfter importing the modules we need, we make a directory to store comics in \u278a and start defining downloadxkcd() \u278b . We loop through all the numbers in the specified range \u278c and download each page \u278d . We use Beautiful Soup to look through the HTML of each page \u278e and find the comic image \u278f . If no comic image is found on a page, we print a message. Otherwise, we get the URL of the image \u2790 and download the image \u2791 . Finally, we save the image to the directory we created.\n\nNow that we\u2019ve defined downloadXkcd() , we\u2019ll create the multiple threads that each call downloadXkcd() to download different ranges of comics from the XKCD website. Add the following code to threadedDownloadXkcd.py after the downloadXkcd() function definition:\n\n#! python3 # threadedDownloadXkcd.py - Downloads XKCD comics using multiple threads. -- snip -- # Create and start the Thread objects. downloadThreads = []\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# a list of all the Thread objects for i in range(0, 140, 10):\u00a0\u00a0\u00a0\u00a0# loops 14 times, creates 14 threads start = i end = i + 9 if start == 0: start = 1 # There is no comic 0, so set it to 1. downloadThread = threading.Thread(target=downloadXkcd, args=(start, end)) downloadThreads.append(downloadThread) downloadThread.start()\n\nFirst we make an empy list downloadThreads ; the list will help us keep track of the many Thread objects we\u2019ll create. Then we start our for loop. Each time through the loop, we create a Thread object with threading.Thread() , append the Thread object to the list, and call start() to start running downloadXkcd() in the new thread. Since the for loop sets the i variable from 0 to 140 at steps of 10 , i will be set to 0 on the first iteration, 10 on the second iteration, 20 on the third, and so on. Since we pass args=(start, end) to threading.Thread() , the two arguments passed to downloadXkcd() will be 1 and 9 on the first iteration, 10 and 19 on the second iteration, 20 and 29 on the third, and so on.\n\nAs the Thread object\u2019s start() method is called and the new thread begins to run the code inside downloadXkcd() , the main thread will continue to the next iteration of the for loop and create the next thread.\n\nThe main thread moves on as normal while the other threads we create download comics. But say there\u2019s some code you don\u2019t want to run in the main thread until all the threads have completed. Calling a Thread object\u2019s join() method will block until that thread has finished. By using a for loop to iterate over all the Thread objects in the downloadThreads list, the main thread can call the join() method on each of the other threads. Add the following to the bottom of your program:\n\n#! python3 # threadedDownloadXkcd.py - Downloads XKCD comics using multiple threads. -- snip -- # Wait for all threads to end. for downloadThread in downloadThreads: downloadThread.join() print('Done.')\n\nThe 'Done.' string will not be printed until all of the join() calls have returned. If a Thread object has already completed when its join() method is called, then the method will simply return immediately. If you wanted to extend this program with code that runs only after all of the comics downloaded, you could replace the print('Done.') line with your new code.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "What is 'Launching Other Programs from Python' and how does it work in Python?", "input": "", "output": "Your Python program can start other programs on your computer with the Popen() function in the built-in subprocess module. (The P in the name of the Popen() function stands for process .) If you have multiple instances of an application open, each of those instances is a separate process of the same program. For example, if you open multiple windows of your web browser at the same time, each of those windows is a different process of the web browser program. See Figure 17-1 for an example of multiple calculator processes open at once.\n\nFigure 17-1: Six running processes of the same calculator program\n\nEvery process can have multiple threads. Unlike threads, a process cannot directly read and write another process\u2019s variables. If you think of a multithreaded program as having multiple fingers following source code, then having multiple processes of the same program open is like having a friend with a separate copy of the program\u2019s source code. You are both independently executing the same program.\n\nIf you want to start an external program from your Python script, pass the program\u2019s filename to subprocess.Popen() . (On Windows, right-click the application\u2019s Start menu item and select Properties to view the application\u2019s filename. On macOS, CTRL -click the application and select Show Package Contents to find the path to the executable file.) The Popen() function will then immediately return. Keep in mind that the launched program is not run in the same thread as your Python program.\n\nOn a Windows computer, enter the following into the interactive shell:\n\n>>> import subprocess >>> subprocess.Popen('C:\\\\Windows\\\\System32\\\\calc.exe') <subprocess.Popen object at 0x0000000003055A58>\n\nOn Ubuntu Linux, you would enter the following:\n\n>>> import subprocess >>> subprocess.Popen('/snap/bin/gnome-calculator') <subprocess.Popen object at 0x7f2bcf93b20>\n\nOn macOS, the process is slightly different. See \u201cOpening Files with Default Applications\u201d on page 409.\n\nThe return value is a Popen object, which has two useful methods: poll() and wait() .\n\nYou can think of the poll() method as asking your driver \u201cAre we there yet?\u201d over and over until you arrive. The poll() method will return None if the process is still running at the time poll() is called. If the program has terminated, it will return the process\u2019s integer exit code . An exit code is used to indicate whether the process terminated without errors (an exit code of 0 ) or whether an error caused the process to terminate (a nonzero exit code\u2014generally 1 , but it may vary depending on the program).\n\nThe wait() method is like waiting until the driver has arrived at your destination. The wait() method will block until the launched process has terminated. This is helpful if you want your program to pause until the user finishes with the other program. The return value of wait() is the process\u2019s integer exit code.\n\nOn Windows, enter the following into the interactive shell. Note that the wait() call will block until you quit the launched MS Paint program.\n\n>>> import subprocess \u278a >>> paintProc = subprocess.Popen('c:\\\\Windows\\\\System32\\\\mspaint.exe') \u278b >>> paintProc.poll() == None True \u278c >>> paintProc.wait() # Doesn't return until MS Paint closes. 0 >>> paintProc.poll() 0\n\nHere we open an MS Paint process \u278a . While it\u2019s still running, we check whether poll() returns None \u278b . It should, as the process is still running. Then we close the MS Paint program and call wait() on the terminated process \u278c . Now wait() and poll() return 0 , indicating that the process terminated without errors.\n\nYou can pass command line arguments to processes you create with Popen() . To do so, you pass a list as the sole argument to Popen() . The first string in this list will be the executable filename of the program you want to launch; all the subsequent strings will be the command line arguments to pass to the program when it starts. In effect, this list will be the value of sys.argv for the launched program.\n\nMost applications with a graphical user interface (GUI) don\u2019t use command line arguments as extensively as command line\u2013based or terminal-based programs do. But most GUI applications will accept a single argument for a file that the applications will immediately open when they start. For example, if you\u2019re using Windows, create a simple text file called C:\\Users\\Al\\hello.txt and then enter the following into the interactive shell:\n\n>>> subprocess.Popen(['C:\\\\Windows\\\\notepad.exe', 'C:\\\\Users\\Al\\\\hello.txt']) <subprocess.Popen object at 0x00000000032DCEB8>\n\nThis will not only launch the Notepad application but also have it immediately open the C:\\Users\\Al\\hello.txt file.\n\nIf you are computer savvy, you may know about Task Scheduler on Windows, launchd on macOS, or the cron scheduler on Linux. These well-documented and reliable tools all allow you to schedule applications to launch at specific times. If you\u2019d like to learn more about them, you can find links to tutorials at https://nostarch.com/automatestuff2/ .\n\nUsing your operating system\u2019s built-in scheduler saves you from writing your own clock-checking code to schedule your programs. However, use the time.sleep() function if you just need your program to pause briefly. Or instead of using the operating system\u2019s scheduler, your code can loop until a certain date and time, calling time.sleep(1) each time through the loop.\n\nThe webbrowser.open() function can launch a web browser from your program to a specific website, rather than opening the browser application with subprocess.Popen() . See \u201cProject: mapIt.py with the webbrowser Module\u201d on page 268 for more details.\n\nYou can launch a Python script from Python just like any other application. Simply pass the python.exe executable to Popen() and the filename of the .py script you want to run as its argument. For example, the following would run the hello.py script from Chapter 1:\n\n>>> subprocess.Popen(['C:\\\\Users\\\\<YOUR USERNAME>\\\\AppData\\\\Local\\\\Programs\\\\ Python\\\\Python38\\\\python.exe', 'hello.py']) <subprocess.Popen object at 0x000000000331CF28>\n\nPass Popen() a list containing a string of the Python executable\u2019s path and a string of the script\u2019s filename. If the script you\u2019re launching needs command line arguments, add them to the list after the script\u2019s filename. The location of the Python executable on Windows is C:\\Users\\<YOUR USERNAME>\\AppData\\Local\\Programs\\Python\\Python38\\python.exe . On macOS, it is /Library/Frameworks/Python.framework/Versions/3.8/bin/python3 . On Linux, it is /usr/bin/python3.8 .\n\nUnlike importing the Python program as a module, when your Python program launches another Python program, the two are run in separate processes and will not be able to share each other\u2019s variables.\n\nDouble-clicking a .txt file on your computer will automatically launch the application associated with the .txt file extension. Your computer will have several of these file extension associations set up already. Python can also open files this way with Popen() .\n\nEach operating system has a program that performs the equivalent of double-clicking a document file to open it. On Windows, this is the start program. On macOS, this is the open program. On Ubuntu Linux, this is the see program. Enter the following into the interactive shell, passing 'start' , 'open' , or 'see' to Popen() depending on your system:\n\n>>> fileObj = open('hello.txt', 'w') >>> fileObj.write('Hello, world!') 12 >>> fileObj.close() >>> import subprocess >>> subprocess.Popen([' start ', 'hello.txt'], shell=True)\n\nHere we write Hello, world! to a new hello.txt file. Then we call Popen() , passing it a list containing the program name (in this example, 'start' for Windows) and the filename. We also pass the shell=True keyword argument, which is needed only on Windows. The operating system knows all of the file associations and can figure out that it should launch, say, Notepad.exe to handle the hello.txt file.\n\nOn macOS, the open program is used for opening both document files and programs. Enter the following into the interactive shell if you have a Mac:\n\n>>> subprocess.Popen(['open', '/Applications/Calculator.app/']) <subprocess.Popen object at 0x10202ff98>\n\nThe Calculator app should open.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "Provide a guide on 'Project: Simple Countdown Program' in Python.", "input": "", "output": "Just like it\u2019s hard to find a simple stopwatch application, it can be hard to find a simple countdown application. Let\u2019s write a countdown program that plays an alarm at the end of the countdown.\n\nAt a high level, here\u2019s what your program will do:\n\n1. Count down from 60.\n2. Play a sound file ( alarm.wav ) when the countdown reaches zero.\n\nThis means your code will need to do the following:\n\n1. Pause for 1 second in between displaying each number in the countdown by calling time.sleep() .\n2. Call subprocess.Popen() to open the sound file with the default application.\n\nOpen a new file editor tab and save it as countdown.py .\n\nThis program will require the time module for the time.sleep() function and the subprocess module for the subprocess.Popen() function. Enter the following code and save the file as countdown.py :\n\n#! python3 # countdown.py - A simple countdown script. import time, subprocess \u278a timeLeft = 60 while timeLeft > 0: \u278b print(timeLeft, end='') \u278c time.sleep(1) \u278d timeLeft = timeLeft - 1 # TODO: At the end of the countdown, play a sound file.\n\nAfter importing time and subprocess , make a variable called timeLeft to hold the number of seconds left in the countdown \u278a . It can start at 60\u2014or you can change the value here to whatever you need, or even have it get set from a command line argument.\n\nIn a while loop, you display the remaining count \u278b , pause for 1 second \u278c , and then decrement the timeLeft variable \u278d before the loop starts over again. The loop will keep looping as long as timeLeft is greater than 0 . After that, the countdown will be over.\n\nWhile there are third-party modules to play sound files of various formats, the quick and easy way is to just launch whatever application the user already uses to play sound files. The operating system will figure out from the .wav file extension which application it should launch to play the file. This .wav file could easily be some other sound file format, such as .mp3 or .ogg .\n\nYou can use any sound file that is on your computer to play at the end of the countdown, or you can download alarm.wav from https://nostarch.com/automatestuff2/ .\n\nAdd the following to your code:\n\n#! python3 # countdown.py - A simple countdown script. import time, subprocess -- snip -- # At the end of the countdown, play a sound file. subprocess.Popen(['start', 'alarm.wav'], shell=True)\n\nAfter the while loop finishes, alarm.wav (or the sound file you choose) will play to notify the user that the countdown is over. On Windows, be sure to include 'start' in the list you pass to Popen() and pass the keyword argument shell=True . On macOS, pass 'open' instead of 'start' and remove shell=True .\n\nInstead of playing a sound file, you could save a text file somewhere with a message like Break time is over! and use Popen() to open it at the end of the countdown. This will effectively create a pop-up window with a message. Or you could use the webbrowser.open() function to open a specific website at the end of the countdown. Unlike some free countdown application you\u2019d find online, your own countdown program\u2019s alarm can be anything you want!\n\nA countdown is a simple delay before continuing the program\u2019s execution. This can also be used for other applications and features, such as the following:\n\n* Use time.sleep() to give the user a chance to press CTRL -C to cancel an action, such as deleting files. Your program can print a \u201cPress CTRL -C to cancel\u201d message and then handle any KeyboardInterrupt exceptions with try and except statements.\n* For a long-term countdown, you can use timedelta objects to measure the number of days, hours, minutes, and seconds until some point (a birthday? an anniversary?) in the future.", "source": "https://automatetheboringstuff.com/2e/chapter17/", "category": "17KEEPING TIME, SCHEDULING TASKS, AND LAUNCHING PROGRAMS"}
{"instruction": "How do I use '18SENDING EMAIL AND TEXT MESSAGES' in Python?", "input": "", "output": "Checking and replying to email is a huge time sink. Of course, you can\u2019t just write a program to handle all your email for you, since each message requires its own response. But you can still automate plenty of email-related tasks once you know how to write programs that can send and receive email.\n\nFor example, maybe you have a spreadsheet full of customer records and want to send each customer a different form letter depending on their age and location details. Commercial software might not be able to do this for you; fortunately, you can write your own program to send these emails, saving yourself a lot of time copying and pasting form emails.\n\nYou can also write programs to send emails and SMS texts to notify you of things even while you\u2019re away from your computer. If you\u2019re automating a task that takes a couple of hours to do, you don\u2019t want to go back to your computer every few minutes to check on the program\u2019s status. Instead, the program can just text your phone when it\u2019s done\u2014freeing you to focus on more important things while you\u2019re away from your computer.\n\nThis chapter features the EZGmail module, a simple way to send and read emails from Gmail accounts, as well as a Python module for using the standard SMTP and IMAP email protocols.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "Explain the concept of 'Sending and Receiving Email with the Gmail API' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Gmail owns close to a third of the email client market share, and most likely you have at least one Gmail email address. Because of additional security and anti-spam measures, it is easier to control a Gmail account through the EZGmail module than through smtplib and imapclient , discussed later in this chapter. EZGmail is a module I wrote that works on top of the official Gmail API and provides functions that make it easy to use Gmail from Python. You can find full details on EZGmail at https://github.com/asweigart/ezgmail/ . EZGmail is not produced by or affiliated with Google; find the official Gmail API documentation at https://developers.google.com/gmail/api/v1/reference/ .\n\nTo install EZGmail, run pip install --user --upgrade ezgmail on Windows (or use pip3 on macOS and Linux). The --upgrade option will ensure that you install the latest version of the package, which is necessary for interacting with a constantly changing online service like the Gmail API.\n\nBefore you write code, you must first sign up for a Gmail email account at https://gmail.com/ . Then, go to https://developers.google.com/gmail/api/quickstart/python/ , click the Enable the Gmail API button on that page, and fill out the form that appears.\n\nAfter you\u2019ve filled out the form, the page will present a link to the credentials.json file, which you\u2019ll need to download and place in the same folder as your .py file. The credentials.json file contains the Client ID and Client Secret information, which you should treat the same as your Gmail password and not share with anyone else.\n\nThen, in the interactive shell, enter the following code:\n\n>>> import ezgmail, os >>> os.chdir(r'C:\\path\\to\\credentials_json_file') >>> ezgmail.init()\n\nMake sure you set your current working directory to the same folder that credentials.json is in and that you\u2019re connected to the internet. The ezgmail.init() function will open your browser to a Google sign-in page. Enter your Gmail address and password. The page may warn you \u201cThis app isn\u2019t verified,\u201d but this is fine; click Advanced and then Go to Quickstart ( unsafe ). (If you write Python scripts for others and don\u2019t want this warning appearing for them, you\u2019ll need to learn about Google\u2019s app verification process, which is beyond the scope of this book.) When the next page prompts you with \u201cQuickstart wants to access your Google Account,\u201d click Allow and then close the browser.\n\nA token.json file will be generated to give your Python scripts access to the Gmail account you entered. The browser will only open to the login page if it can\u2019t find an existing token.json file. With credentials.json and token.json , your Python scripts can send and read emails from your Gmail account without requiring you to include your Gmail password in your source code.\n\nOnce you have a token.json file, the EZGmail module should be able to send email with a single function call:\n\n>>> import ezgmail >>> ezgmail.send('recipient@example.com', 'Subject line', 'Body of the email')\n\nIf you want to attach files to your email, you can provide an extra list argument to the send() function:\n\n>>> ezgmail.send('recipient@example.com', 'Subject line', 'Body of the email', ['attachment1.jpg', 'attachment2.mp3'])\n\nNote that as part of its security and anti-spam features, Gmail might not send repeated emails with the exact same text (since these are likely spam) or emails that contain .exe or .zip file attachments (since they are likely viruses).\n\nYou can also supply the optional keyword arguments cc and bcc to send carbon copies and blind carbon copies:\n\n>>> import ezgmail >>> ezgmail.send('recipient@example.com', 'Subject line', 'Body of the email', cc='friend@example.com', bcc='otherfriend@example.com,someoneelse@example.com')\n\nIf you need to remember which Gmail address the token.json file is configured for, you can examine ezgmail.EMAIL_ADDRESS . Note that this variable is populated only after ezgmail.init() or any other EZGmail function is called:\n\n>>> import ezgmail >>> ezgmail.init() >>> ezgmail.EMAIL_ADDRESS 'example@gmail.com'\n\nBe sure to treat the token.json file the same as your password. If someone else obtains this file, they can access your Gmail account (though they won\u2019t be able to change your Gmail password). To revoke previously issued token.json files, go to https://security.google.com/settings/security/permissions?pli=1/ and revoke access to the Quickstart app. You will need to run ezgmail.init() and go through the login process again to obtain a new token.json file.\n\nGmail organizes emails that are replies to each other into conversation threads. When you log in to Gmail in your web browser or through an app, you\u2019re really looking at email threads rather than individual emails (even if the thread has only one email in it).\n\nEZGmail has GmailThread and GmailMessage objects to represent conversation threads and individual emails, respectively. A GmailThread object has a messages attribute that holds a list of GmailMessage objects. The unread() function returns a list of GmailThread objects for all unread emails, which can then be passed to ezgmail.summary() to print a summary of the conversation threads in that list:\n\n>>> import ezgmail >>> unreadThreads = ezgmail.unread() # List of GmailThread objects. >>> ezgmail.summary(unreadThreads) Al, Jon - Do you want to watch RoboCop this weekend? - Dec 09 Jon - Thanks for stopping me from buying Bitcoin. - Dec 09\n\nThe summary() function is handy for displaying a quick summary of the email threads, but to access specific messages (and parts of messages), you\u2019ll want to examine the messages attribute of the GmailThread object. The messages attribute contains a list of the GmailMessage objects that make up the thread, and these have subject , body , timestamp , sender , and recipient attributes that describe the email:\n\n>>> len(unreadThreads) 2 >>> str(unreadThreads[0]) \"<GmailThread len=2 snippet= Do you want to watch RoboCop this weekend?'>\" >>> len(unreadThreads[0].messages) 2 >>> str(unreadThreads[0].messages[0]) \"<GmailMessage from='Al Sweigart <al@inventwithpython.com>' to='Jon Doe <example@gmail.com>' timestamp=datetime.datetime(2018, 12, 9, 13, 28, 48) subject='RoboCop' snippet='Do you want to watch RoboCop this weekend?'>\" >>> unreadThreads[0].messages[0].subject 'RoboCop' >>> unreadThreads[0].messages[0].body 'Do you want to watch RoboCop this weekend?\\r\\n' >>> unreadThreads[0].messages[0].timestamp datetime.datetime(2018, 12, 9, 13, 28, 48) >>> unreadThreads[0].messages[0].sender 'Al Sweigart <al@inventwithpython.com>' >>> unreadThreads[0].messages[0].recipient 'Jon Doe <example@gmail.com>'\n\nSimilar to the ezgmail.unread() function, the ezgmail.recent() function will return the 25 most recent threads in your Gmail account. You can pass an optional maxResults keyword argument to change this limit:\n\n>>> recentThreads = ezgmail.recent() >>> len(recentThreads) 25 >>> recentThreads = ezgmail.recent(maxResults=100) >>> len(recentThreads) 46\n\nIn addition to using ezgmail.unread() and ezgmail.recent() , you can search for specific emails, the same way you would if you entered queries into the https://gmail.com/ search box, by calling ezgmail.search() :\n\n>>> resultThreads = ezgmail.search('RoboCop') >>> len(resultThreads) 1 >>> ezgmail.summary(resultThreads) Al, Jon - Do you want to watch RoboCop this weekend? - Dec 09\n\nThe previous search() call should yield the same results as if you had entered \u201cRoboCop\u201d into the search box, as in Figure 18-1.\n\nFigure 18-1: Searching for \u201cRoboCop\u201d emails at the Gmail website\n\nLike unread() and recent() , the search() function returns a list of GmailThread objects. You can also pass any of the special search operators that you can enter into the search box to the search() function, such as the following:\n\n'label:UNREAD' For unread emails\n\n'from:al@inventwithpython.com' For emails from al@inventwithpython.com\n\n'subject:hello' For emails with \u201chello\u201d in the subject\n\n'has:attachment' For emails with file attachments\n\nYou can view a full list of search operators at https://support.google.com/mail/answer/7190?hl=en/ .\n\nThe GmailMessage objects have an attachments attribute that is a list of filenames for the message\u2019s attached files. You can pass any of these names to a GmailMessage object\u2019s downloadAttachment() method to download the files. You can also download all of them at once with downloadAllAttachments() . By default, EZGmail saves attachments to the current working directory, but you can pass an additional downloadFolder keyword argument to downloadAttachment() and downloadAllAttachments() as well. For example:\n\n>>> import ezgmail >>> threads = ezgmail.search('vacation photos') >>> threads[0].messages[0].attachments ['tulips.jpg', 'canal.jpg', 'bicycles.jpg'] >>> threads[0].messages[0].downloadAttachment('tulips.jpg') >>> threads[0].messages[0].downloadAllAttachments(downloadFolder='vacat ion2019') ['tulips.jpg', 'canal.jpg', 'bicycles.jpg']\n\nIf a file already exists with the attachment\u2019s filename, the downloaded attachment will automatically overwrite it.\n\nEZGmail contains additional features, and you can find the full documentation at https://github.com/asweigart/ezgmail/ .", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "What is 'SMTP' and how does it work in Python?", "input": "", "output": "Much as HTTP is the protocol used by computers to send web pages across the internet, Simple Mail Transfer Protocol (SMTP) is the protocol used for sending email. SMTP dictates how email messages should be formatted, encrypted, and relayed between mail servers and all the other details that your computer handles after you click Send. You don\u2019t need to know these technical details, though, because Python\u2019s smtplib module simplifies them into a few functions.\n\nSMTP just deals with sending emails to others. A different protocol, called IMAP, deals with retrieving emails sent to you and is described in \u201cIMAP\u201d on page 424.\n\nIn addition to SMTP and IMAP, most web-based email providers today have other security measures in place to protect against spam, phishing, and other malicious email usage. These measures prevent Python scripts from logging in to an email account with the smtplib and imapclient modules. However, many of these services have APIs and specific Python modules that allow scripts to access them. This chapter covers Gmail\u2019s module. For others, you\u2019ll need to consult their online documentation.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "What is 'Sending Email' and how does it work in Python?", "input": "", "output": "You may be familiar with sending emails from Outlook or Thunderbird or through a website such as Gmail or Yahoo Mail. Unfortunately, Python doesn\u2019t offer you a nice graphical user interface like those services. Instead, you call functions to perform each major step of SMTP, as shown in the following interactive shell example.\n\n>>> import smtplib >>> smtpObj = smtplib.SMTP('smtp.example.com', 587) >>> smtpObj.ehlo() (250, b'mx.example.com at your service, [216.172.148.131]\\nSIZE 35882577\\ n8BITMIME\\nSTARTTLS\\nENHANCEDSTATUSCODES\\nCHUNKING') >>> smtpObj.starttls() (220, b'2.0.0 Ready to start TLS') >>> smtpObj.login('bob@example.com', ' MY_SECRET_PASSWORD ') (235, b'2.7.0 Accepted') >>> smtpObj.sendmail('bob@example.com', 'alice@example.com', 'Subject: So long.\\nDear Alice, so long and thanks for all the fish. Sincerely, Bob') {} >>> smtpObj.quit() (221, b'2.0.0 closing connection ko10sm23097611pbd.52 - gsmtp')\n\nIn the following sections, we\u2019ll go through each step, replacing the placeholders with your information to connect and log in to an SMTP server, send an email, and disconnect from the server.\n\nIf you\u2019ve ever set up Thunderbird, Outlook, or another program to connect to your email account, you may be familiar with configuring the SMTP server and port. These settings will be different for each email provider, but a web search for <your provider> smtp settings should turn up the server and port to use.\n\nThe domain name for the SMTP server will usually be the name of your email provider\u2019s domain name, with smtp. in front of it. For example, Verizon\u2019s SMTP server is at smtp.verizon.net . Table 18-1 lists some common email providers and their SMTP servers. (The port is an integer value and will almost always be 587. It\u2019s used by the command encryption standard, TLS.)\n\nTable 18-1: Email Providers and Their SMTP Servers\n\nOnce you have the domain name and port information for your email provider, create an SMTP object by calling smptlib.SMTP() , passing the domain name as a string argument, and passing the port as an integer argument. The SMTP object represents a connection to an SMTP mail server and has methods for sending emails. For example, the following call creates an SMTP object for connecting to an imaginary email server:\n\n>>> smtpObj = smtplib.SMTP('smtp.example.com', 587) >>> type(smtpObj) <class 'smtplib.SMTP'>\n\nEntering type(smtpObj) shows you that there\u2019s an SMTP object stored in smtpObj . You\u2019ll need this SMTP object in order to call the methods that log you in and send emails. If the smptlib.SMTP() call is not successful, your SMTP server might not support TLS on port 587. In this case, you will need to create an SMTP object using smtplib.SMTP_SSL() and port 465 instead.\n\n>>> smtpObj = smtplib.SMTP_SSL('smtp.example.com', 465)\n\nFor your programs, the differences between TLS and SSL aren\u2019t important. You only need to know which encryption standard your SMTP server uses so you know how to connect to it. In all of the interactive shell examples that follow, the smtpObj variable will contain an SMTP object returned by the smtplib.SMTP() or smtplib.SMTP_SSL() function.\n\nOnce you have the SMTP object, call its oddly named ehlo() method to \u201csay hello\u201d to the SMTP email server. This greeting is the first step in SMTP and is important for establishing a connection to the server. You don\u2019t need to know the specifics of these protocols. Just be sure to call the ehlo() method first thing after getting the SMTP object or else the later method calls will result in errors. The following is an example of an ehlo() call and its return value:\n\n>>> smtpObj.ehlo() (250, b'mx.example.com at your service, [216.172.148.131]\\nSIZE 35882577\\ n8BITMIME\\nSTARTTLS\\nENHANCEDSTATUSCODES\\nCHUNKING')\n\nIf the first item in the returned tuple is the integer 250 (the code for \u201csuccess\u201d in SMTP), then the greeting succeeded.\n\nIf you are connecting to port 587 on the SMTP server (that is, you\u2019re using TLS encryption), you\u2019ll need to call the starttls() method next. This required step enables encryption for your connection. If you are connecting to port 465 (using SSL), then encryption is already set up, and you should skip this step.\n\nHere\u2019s an example of the starttls() method call:\n\n>>> smtpObj.starttls() (220, b'2.0.0 Ready to start TLS')\n\nThe starttls() method puts your SMTP connection in TLS mode. The 220 in the return value tells you that the server is ready.\n\nOnce your encrypted connection to the SMTP server is set up, you can log in with your username (usually your email address) and email password by calling the login() method.\n\n>>> smtpObj.login(' my_email_address@example.com ', ' MY_SECRET_PASSWORD ') (235, b'2.7.0 Accepted')\n\nPass a string of your email address as the first argument and a string of your password as the second argument. The 235 in the return value means authentication was successful. Python raises an smtplib.SMTPAuthenticationError exception for incorrect passwords.\n\nOnce you are logged in to your email provider\u2019s SMTP server, you can call the sendmail() method to actually send the email. The sendmail() method call looks like this:\n\n>>> smtpObj.sendmail(' my_email_address@example.com ', ' recipient@example.com ', 'Subject: So long.\\nDear Alice, so long and thanks for all the fish. Sincerely, Bob') {}\n\nThe sendmail() method requires three arguments:\n\n* Your email address as a string (for the email\u2019s \u201cfrom\u201d address)\n* The recipient\u2019s email address as a string, or a list of strings for multiple recipients (for the \u201cto\u201d address)\n* The email body as a string\n\nThe start of the email body string must begin with 'Subject: \\n' for the subject line of the email. The '\\n' newline character separates the subject line from the main body of the email.\n\nThe return value from sendmail() is a dictionary. There will be one key-value pair in the dictionary for each recipient for whom email delivery failed . An empty dictionary means all recipients were successfully sent the email.\n\nBe sure to call the quit() method when you are done sending emails. This will disconnect your program from the SMTP server.\n\n>>> smtpObj.quit() (221, b'2.0.0 closing connection ko10sm23097611pbd.52 - gsmtp')\n\nThe 221 in the return value means the session is ending.\n\nTo review all the steps for connecting and logging in to the server, sending email, and disconnecting, see \u201cSending Email\u201d on page 420.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "How do I use 'IMAP' in Python?", "input": "", "output": "Just as SMTP is the protocol for sending email, the Internet Message Access Protocol (IMAP) specifies how to communicate with an email provider\u2019s server to retrieve emails sent to your email address. Python comes with an imaplib module, but in fact the third-party imapclient module is easier to use. This chapter provides an introduction to using IMAPClient; the full documentation is at https://imapclient.readthedocs.io/ .\n\nThe imapclient module downloads emails from an IMAP server in a rather complicated format. Most likely, you\u2019ll want to convert them from this format into simple string values. The pyzmail module does the hard job of parsing these email messages for you. You can find the complete documentation for PyzMail at https://www.magiksys.net/pyzmail/ .\n\nInstall imapclient and pyzmail from a Terminal window with pip install --user -U imapclient==2.1.0 and pip install --user -U pyzmail36== 1.0.4 on Windows (or using pip3 on macOS and Linux). Appendix A has steps on how to install third-party modules.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "Provide a guide on 'Retrieving and Deleting Emails with IMAP' in Python.", "input": "", "output": "Finding and retrieving an email in Python is a multistep process that requires both the imapclient and pyzmail third-party modules. Just to give you an overview, here\u2019s a full example of logging in to an IMAP server, searching for emails, fetching them, and then extracting the text of the email messages from them.\n\n>>> import imapclient >>> imapObj = imapclient.IMAPClient('imap.example.com', ssl=True) >>> imapObj.login(' my_email_address@example.com ', ' MY_SECRET_PASSWORD ') 'my_email_address@example.com Jane Doe authenticated (Success)' >>> imapObj.select_folder('INBOX', readonly=True) >>> UIDs = imapObj.search(['SINCE 05-Jul-2019']) >>> UIDs [40032, 40033, 40034, 40035, 40036, 40037, 40038, 40039, 40040, 40041] >>> rawMessages = imapObj.fetch([40041], ['BODY[]', 'FLAGS']) >>> import pyzmail >>> message = pyzmail.PyzMessage.factory(rawMessages[40041][b'BODY[]']) >>> message.get_subject() 'Hello!' >>> message.get_addresses('from') [('Edward Snowden', 'esnowden@nsa.gov')] >>> message.get_addresses('to') [('Jane Doe', 'jdoe@example.com')] >>> message.get_addresses('cc') [] >>> message.get_addresses('bcc') [] >>> message.text_part != None True >>> message.text_part.get_payload().decode(message.text_part.charset) 'Follow the money.\\r\\n\\r\\n-Ed\\r\\n' >>> message.html_part != None True >>> message.html_part.get_payload().decode(message.html_part.charset) '<div dir=\"ltr\"><div>So long, and thanks for all the fish!<br><br></div>- Al<br></div>\\r\\n' >>> imapObj.logout()\n\nYou don\u2019t have to memorize these steps. After we go through each step in detail, you can come back to this overview to refresh your memory.\n\nJust like you needed an SMTP object to connect to an SMTP server and send email, you need an IMAPClient object to connect to an IMAP server and receive email. First you\u2019ll need the domain name of your email provider\u2019s IMAP server. This will be different from the SMTP server\u2019s domain name. Table 18-2 lists the IMAP servers for several popular email providers.\n\nTable 18-2: Email Providers and Their IMAP Servers\n\nOnce you have the domain name of the IMAP server, call the imapclient.IMAPClient() function to create an IMAPClient object. Most email providers require SSL encryption, so pass the ssl=True keyword argument. Enter the following into the interactive shell (using your provider\u2019s domain name):\n\n>>> import imapclient >>> imapObj = imapclient.IMAPClient('imap.example.com', ssl=True)\n\nIn all of the interactive shell examples in the following sections, the imapObj variable contains an IMAPClient object returned from the imapclient.IMAPClient() function. In this context, a client is the object that connects to the server.\n\nOnce you have an IMAPClient object, call its login() method, passing in the username (this is usually your email address) and password as strings.\n\n>>> imapObj.login(' my_email_address@example.com ', ' MY_SECRET_PASSWORD ') 'my_email_address@example.com Jane Doe authenticated (Success)'\n\nIf the IMAP server rejects this username/password combination, Python raises an imaplib.error exception.\n\nOnce you\u2019re logged on, actually retrieving an email that you\u2019re interested in is a two-step process. First, you must select a folder you want to search through. Then, you must call the IMAPClient object\u2019s search() method, passing in a string of IMAP search keywords.\n\nAlmost every account has an INBOX folder by default, but you can also get a list of folders by calling the IMAPClient object\u2019s list_folders() method. This returns a list of tuples. Each tuple contains information about a single folder. Continue the interactive shell example by entering the following:\n\n>>> import pprint >>> pprint.pprint(imapObj.list_folders()) [(('\\\\HasNoChildren',), '/', 'Drafts'), (('\\\\HasNoChildren',), '/', 'Filler'), (('\\\\HasNoChildren',), '/', 'INBOX'), (('\\\\HasNoChildren',), '/', 'Sent'), -- snip -- (('\\\\HasNoChildren', '\\\\Flagged'), '/', 'Starred'), (('\\\\HasNoChildren', '\\\\Trash'), '/', 'Trash')]\n\nThe three values in each of the tuples\u2014for example, (('\\\\HasNoChildren',), '/', 'INBOX') \u2014are as follows:\n\n* A tuple of the folder\u2019s flags. (Exactly what these flags represent is beyond the scope of this book, and you can safely ignore this field.)\n* The delimiter used in the name string to separate parent folders and subfolders.\n* The full name of the folder.\n\nTo select a folder to search through, pass the folder\u2019s name as a string into the IMAPClient object\u2019s select_folder() method.\n\n>>> imapObj.select_folder('INBOX', readonly=True)\n\nYou can ignore select_folder() \u2019s return value. If the selected folder does not exist, Python raises an imaplib.error exception.\n\nThe readonly=True keyword argument prevents you from accidentally making changes or deletions to any of the emails in this folder during the subsequent method calls. Unless you want to delete emails, it\u2019s a good idea to always set readonly to True .\n\nWith a folder selected, you can now search for emails with the IMAPClient object\u2019s search() method. The argument to search() is a list of strings, each formatted to the IMAP\u2019s search keys. Table 18-3 describes the various search keys.\n\nNote that some IMAP servers may have slightly different implementations for how they handle their flags and search keys. It may require some experimentation in the interactive shell to see exactly how they behave.\n\nYou can pass multiple IMAP search key strings in the list argument to the search() method. The messages returned are the ones that match all the search keys. If you want to match any of the search keys, use the OR search key. For the NOT and OR search keys, one and two complete search keys follow the NOT and OR , respectively.\n\nTable 18-3: IMAP Search Keys\n\nHere are some example search() method calls along with their meanings:\n\nimapObj.search(['ALL']) Returns every message in the currently selected folder.\n\nimapObj.search(['ON 05-Jul-2019']) Returns every message sent on July 5, 2019.\n\nimapObj.search(['SINCE 01-Jan-2019', 'BEFORE 01-Feb-2019', 'UNSEEN']) Returns every message sent in January 2019 that is unread. (Note that this means on and after January 1 and up to but not including February 1.)\n\nimapObj.search(['SINCE 01-Jan-2019', 'FROM alice@example.com']) Returns every message from alice@example.com sent since the start of 2019.\n\nimapObj.search(['SINCE 01-Jan-2019', 'NOT FROM alice@example.com']) Returns every message sent from everyone except alice@example.com since the start of 2019.\n\nimapObj.search(['OR FROM alice@example.com FROM bob@example.com']) Returns every message ever sent from alice@example.com or bob@example.com .\n\nimapObj.search(['FROM alice@example.com', 'FROM bob@example.com']) Trick example! This search never returns any messages, because messages must match all search keywords. Since there can be only one \u201cfrom\u201d address, it is impossible for a message to be from both alice@example.com and bob@example.com .\n\nThe search() method doesn\u2019t return the emails themselves but rather unique IDs (UIDs) for the emails, as integer values. You can then pass these UIDs to the fetch() method to obtain the email content.\n\nContinue the interactive shell example by entering the following:\n\n>>> UIDs = imapObj.search(['SINCE 05-Jul-2019']) >>> UIDs [40032, 40033, 40034, 40035, 40036, 40037, 40038, 40039, 40040, 40041]\n\nHere, the list of message IDs (for messages received July 5 onward) returned by search() is stored in UIDs . The list of UIDs returned on your computer will be different from the ones shown here; they are unique to a particular email account. When you later pass UIDs to other function calls, use the UID values you received, not the ones printed in this book\u2019s examples.\n\nIf your search matches a large number of email messages, Python might raise an exception that says imaplib.error: got more than 10000 bytes . When this happens, you will have to disconnect and reconnect to the IMAP server and try again.\n\nThis limit is in place to prevent your Python programs from eating up too much memory. Unfortunately, the default size limit is often too small. You can change this limit from 10,000 bytes to 10,000,000 bytes by running this code:\n\n>>> import imaplib >>> imaplib._MAXLINE = 10000000\n\nThis should prevent this error message from coming up again. You may want to make these two lines part of every IMAP program you write.\n\nOnce you have a list of UIDs, you can call the IMAPClient object\u2019s fetch() method to get the actual email content.\n\nThe list of UIDs will be fetch() \u2019s first argument. The second argument should be the list ['BODY[]'] , which tells fetch() to download all the body content for the emails specified in your UID list.\n\nLet\u2019s continue our interactive shell example.\n\n>>> rawMessages = imapObj.fetch(UIDs, ['BODY[]']) >>> import pprint >>> pprint.pprint(rawMessages) {40040: {'BODY[]': 'Delivered-To: my_email_address@example.com\\r\\n' 'Received: by 10.76.71.167 with SMTP id ' -- snip -- '\\r\\n' '------=_Part_6000970_707736290.1404819487066--\\r\\n', 'SEQ': 5430}}\n\nImport pprint and pass the return value from fetch() , stored in the variable rawMessages , to pprint.pprint() to \u201cpretty print\u201d it, and you\u2019ll see that this return value is a nested dictionary of messages with UIDs as the keys. Each message is stored as a dictionary with two keys: 'BODY[]' and 'SEQ' . The 'BODY[]' key maps to the actual body of the email. The 'SEQ' key is for a sequence number , which has a similar role to the UID. You can safely ignore it.\n\nAs you can see, the message content in the 'BODY[]' key is pretty unintelligible. It\u2019s in a format called RFC 822, which is designed for IMAP servers to read. But you don\u2019t need to understand the RFC 822 format; later in this chapter, the pyzmail module will make sense of it for you.\n\nWhen you selected a folder to search through, you called select_folder() with the readonly=True keyword argument. Doing this prevents you from accidentally deleting an email\u2014but it also means that emails will not get marked as read if you fetch them with the fetch() method. If you do want emails to be marked as read when you fetch them, you\u2019ll need to pass readonly=False to select_folder() . If the selected folder is already in read-only mode, you can reselect the current folder with another call to select_folder() , this time with the readonly=False keyword argument:\n\n>>> imapObj.select_folder('INBOX', readonly=False)\n\nThe raw messages returned from the fetch() method still aren\u2019t very useful to people who just want to read their email. The pyzmail module parses these raw messages and returns them as PyzMessage objects, which make the subject, body, \u201cTo\u201d field, \u201cFrom\u201d field, and other sections of the email easily accessible to your Python code.\n\nContinue the interactive shell example with the following (using UIDs from your own email account, not the ones shown here):\n\n>>> import pyzmail >>> message = pyzmail.PyzMessage.factory(rawMessages[40041][b'BODY[]'])\n\nFirst, import pyzmail . Then, to create a PyzMessage object of an email, call the pyzmail.PyzMessage.factory() function and pass it the 'BODY[]' section of the raw message. (Note that the b prefix means this is a bytes value, not a string value. The difference isn\u2019t too important; just remember to include the b prefix in your code.) Store the result in message . Now message contains a PyzMessage object, which has several methods that make it easy to get the email\u2019s subject line, as well as all sender and recipient addresses. The get_subject() method returns the subject as a simple string value. The get_addresses() method returns a list of addresses for the field you pass it. For example, the method calls might look like this:\n\n>>> message.get_subject() 'Hello!' >>> message.get_addresses('from') [('Edward Snowden', 'esnowden@nsa.gov')] >>> message.get_addresses('to') [('Jane Doe', 'my_email_address@example.com')] >>> message.get_addresses('cc') [] >>> message.get_addresses('bcc') []\n\nNotice that the argument for get_addresses() is 'from' , 'to' , 'cc' , or 'bcc' . The return value of get_addresses() is a list of tuples. Each tuple contains two strings: the first is the name associated with the email address, and the second is the email address itself. If there are no addresses in the requested field, get_addresses() returns a blank list. Here, the 'cc' carbon copy and 'bcc' blind carbon copy fields both contained no addresses and so returned empty lists.\n\nEmails can be sent as plaintext, HTML, or both. Plaintext emails contain only text, while HTML emails can have colors, fonts, images, and other features that make the email message look like a small web page. If an email is only plaintext, its PyzMessage object will have its html_part attributes set to None . Likewise, if an email is only HTML, its PyzMessage object will have its text_part attribute set to None .\n\nOtherwise, the text_part or html_part value will have a get_payload() method that returns the email\u2019s body as a value of the bytes data type. (The bytes data type is beyond the scope of this book.) But this still isn\u2019t a string value that we can use. Ugh! The last step is to call the decode() method on the bytes value returned by get_payload() . The decode() method takes one argument: the message\u2019s character encoding, stored in the text_part.charset or html_part.charset attribute. This, finally, will return the string of the email\u2019s body.\n\nContinue the interactive shell example by entering the following:\n\n\u278a >>> message.text_part != None True >>> message.text_part.get_payload().decode(message.text_part.charset) \u278b 'So long, and thanks for all the fish!\\r\\n\\r\\n-Al\\r\\n' \u278c >>> message.html_part != None True \u278d >>> message.html_part.get_payload().decode(message.html_part.charset) '<div dir=\"ltr\"><div>So long, and thanks for all the fish!<br><br></div>-Al <br></div>\\r\\n'\n\nThe email we\u2019re working with has both plaintext and HTML content, so the PyzMessage object stored in message has text_part and html_part attributes not equal to None \u278a \u278c . Calling get_payload() on the message\u2019s text_part and then calling decode() on the bytes value returns a string of the text version of the email \u278b . Using get_payload() and decode() with the message\u2019s html_part returns a string of the HTML version of the email \u278d .\n\nTo delete emails, pass a list of message UIDs to the IMAPClient object\u2019s delete_messages() method. This marks the emails with the \\Deleted flag. Calling the expunge() method permanently deletes all emails with the /Deleted flag in the currently selected folder. Consider the following interactive shell example:\n\n\u278a >>> imapObj.select_folder('INBOX', readonly=False) \u278b >>> UIDs = imapObj.search(['ON 09-Jul-2019']) >>> UIDs [40066] >>> imapObj.delete_messages(UIDs) \u278c {40066: ('\\\\Seen', '\\\\Deleted')} >>> imapObj.expunge() ('Success', [(5452, 'EXISTS')])\n\nHere we select the inbox by calling select_folder() on the IMAPClient object and passing 'INBOX' as the first argument; we also pass the keyword argument readonly=False so that we can delete emails \u278a . We search the inbox for messages received on a specific date and store the returned message IDs in UIDs \u278b . Calling delete_message() and passing it UIDs returns a dictionary; each key-value pair is a message ID and a tuple of the message\u2019s flags, which should now include \\Deleted \u278c . Calling expunge() then permanently deletes messages with the \\Deleted flag and returns a success message if there were no problems expunging the emails. Note that some email providers automatically expunge emails deleted with delete_messages() instead of waiting for an expunge command from the IMAP client.\n\nWhen your program has finished retrieving or deleting emails, simply call the IMAPClient\u2019s logout() method to disconnect from the IMAP server.\n\n>>> imapObj.logout()\n\nIf your program runs for several minutes or more, the IMAP server may time out , or automatically disconnect. In this case, the next method call your program makes on the IMAPClient object should raise an exception like the following:\n\nimaplib.abort: socket error: [WinError 10054] An existing connection was forcibly closed by the remote host\n\nIn this event, your program will have to call imapclient.IMAPClient() to connect again.\n\nWhew! That\u2019s it. There were a lot of hoops to jump through, but you now have a way to get your Python programs to log in to an email account and fetch emails. You can always consult the overview in \u201cRetrieving and Deleting Emails with IMAP\u201d on page 424 whenever you need to remember all of the steps.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "Provide a guide on 'Project: Sending Member Dues Reminder Emails' in Python.", "input": "", "output": "Say you have been \u201cvolunteered\u201d to track member dues for the Mandatory Volunteerism Club. This is a truly boring job, involving maintaining a spreadsheet of everyone who has paid each month and emailing reminders to those who haven\u2019t. Instead of going through the spreadsheet yourself and copying and pasting the same email to everyone who is behind on dues, let\u2019s\u2014you guessed it\u2014write a script that does this for you.\n\nAt a high level, here\u2019s what your program will do:\n\n1. Read data from an Excel spreadsheet.\n2. Find all members who have not paid dues for the latest month.\n3. Find their email addresses and send them personalized reminders.\n\nThis means your code will need to do the following:\n\n1. Open and read the cells of an Excel document with the openpyxl module. (See Chapter 13 for working with Excel files.)\n2. Create a dictionary of members who are behind on their dues.\n3. Log in to an SMTP server by calling smtplib.SMTP() , ehlo() , starttls() , and login() .\n4. For all members behind on their dues, send a personalized reminder email by calling the sendmail() method.\n\nOpen a new file editor tab and save it as sendDuesReminders.py .\n\nLet\u2019s say the Excel spreadsheet you use to track membership dues payments looks like Figure 18-2 and is in a file named duesRecords.xlsx . You can download this file from https://nostarch.com/automatestuff2/ .\n\nFigure 18-2: The spreadsheet for tracking member dues payments\n\nThis spreadsheet has every member\u2019s name and email address. Each month has a column tracking members\u2019 payment statuses. The cell for each member is marked with the text paid once they have paid their dues.\n\nThe program will have to open duesRecords.xlsx and figure out the column for the latest month by reading the sheet.max_column attribute. (You can consult Chapter 13 for more information on accessing cells in Excel spreadsheet files with the openpyxl module.) Enter the following code into the file editor tab:\n\n#! python3 # sendDuesReminders.py - Sends emails based on payment status in spreadsheet. import openpyxl, smtplib, sys # Open the spreadsheet and get the latest dues status. \u278a wb = openpyxl.load_workbook('duesRecords.xlsx') \u278b sheet = wb.get_sheet_by_name('Sheet1') \u278c lastCol = sheet.max_column \u278d latestMonth = sheet.cell(row=1, column=lastCol).value # TODO: Check each member's payment status. # TODO: Log in to email account. # TODO: Send out reminder emails.\n\nAfter importing the openpyxl , smtplib , and sys modules, we open our duesRecords.xlsx file and store the resulting Workbook object in wb \u278a . Then we get Sheet 1 and store the resulting Worksheet object in sheet \u278b . Now that we have a Worksheet object, we can access rows, columns, and cells. We store the highest column in lastCol \u278c , and we then use row number 1 and lastCol to access the cell that should hold the most recent month. We get the value in this cell and store it in latestMonth \u278d .\n\nOnce you\u2019ve determined the column number of the latest month (stored in lastCol ), you can loop through all rows after the first row (which has the column headers) to see which members have the text paid in the cell for that month\u2019s dues. If the member hasn\u2019t paid, you can grab the member\u2019s name and email address from columns 1 and 2, respectively. This information will go into the unpaidMembers dictionary, which will track all members who haven\u2019t paid in the most recent month. Add the following code to sendDuesReminder.py .\n\n#! python3 # sendDuesReminders.py - Sends emails based on payment status in spreadsheet. -- snip -- # Check each member's payment status. unpaidMembers = {} \u278a for r in range(2, sheet.max_row + 1): \u278b payment = sheet.cell(row=r, column=lastCol).value if payment != 'paid': \u278c name = sheet.cell(row=r, column=1).value \u278d email = sheet.cell(row=r, column=2).value \u278e unpaidMembers[name] = email\n\nThis code sets up an empty dictionary unpaidMembers and then loops through all the rows after the first \u278a . For each row, the value in the most recent column is stored in payment \u278b . If payment is not equal to 'paid' , then the value of the first column is stored in name \u278c , the value of the second column is stored in email \u278d , and name and email are added to unpaidMembers \u278e .\n\nOnce you have a list of all unpaid members, it\u2019s time to send them email reminders. Add the following code to your program, except with your real email address and provider information:\n\n#! python3 # sendDuesReminders.py - Sends emails based on payment status in spreadsheet. -- snip -- # Log in to email account. smtpObj = smtplib.SMTP('smtp.example.com', 587) smtpObj.ehlo() smtpObj.starttls() smtpObj.login(' my_email_address@example.com ', sys.argv[1])\n\nCreate an SMTP object by calling smtplib.SMTP() and passing it the domain name and port for your provider. Call ehlo() and starttls() , and then call login() and pass it your email address and sys.argv[1] , which will store your password string. You\u2019ll enter the password as a command line argument each time you run the program, to avoid saving your password in your source code.\n\nOnce your program has logged in to your email account, it should go through the unpaidMembers dictionary and send a personalized email to each member\u2019s email address. Add the following to sendDuesReminders.py :\n\n#! python3 # sendDuesReminders.py - Sends emails based on payment status in spreadsheet. -- snip -- # Send out reminder emails. for name, email in unpaidMembers.items(): \u278a body = \"Subject: %s dues unpaid.\\nDear %s,\\nRecords show that you have not paid dues for %s. Please make this payment as soon as possible. Thank you!'\" % (latestMonth, name, latestMonth) \u278b print('Sending email to %s...' % email) \u278c sendmailStatus = smtpObj.sendmail(' my_email_address@example.com ', email, body) \u278d if sendmailStatus != {}: print('There was a problem sending email to %s: %s' % (email, sendmailStatus)) smtpObj.quit()\n\nThis code loops through the names and emails in unpaidMembers . For each member who hasn\u2019t paid, we customize a message with the latest month and the member\u2019s name, and store the message in body \u278a . We print output saying that we\u2019re sending an email to this member\u2019s email address \u278b . Then we call sendmail() , passing it the from address and the customized message \u278c . We store the return value in sendmailStatus .\n\nRemember that the sendmail() method will return a nonempty dictionary value if the SMTP server reported an error sending that particular email. The last part of the for loop at \u278d checks if the returned dictionary is nonempty and, if it is, prints the recipient\u2019s email address and the returned dictionary.\n\nAfter the program is done sending all the emails, the quit() method is called to disconnect from the SMTP server.\n\nWhen you run the program, the output will look something like this:\n\nSending email to alice@example.com... Sending email to bob@example.com... Sending email to eve@example.com...\n\nThe recipients will receive an email about their missed payments that looks just like an email you would have sent manually.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "What is 'Sending Text Messages with SMS Email Gateways' and how does it work in Python?", "input": "", "output": "People are more likely to be near their smartphones than their computers, so text messages are often a more immediate and reliable way of sending notifications than email. Also, text messages are usually shorter, making it more likely that a person will get around to reading them.\n\nThe easiest, though not most reliable, way to send text messages is by using an SMS (short message service) email gateway, an email server that a cell phone provider set up to receive text via email and then forward to the recipient as a text message.\n\nYou can write a program to send these emails using the ezgmail or smtplib modules. The phone number and phone company\u2019s email server make up the recipient email address. The subject and body of the email will be the body of the text message. For example, to send a text to the phone number 415-555-1234, which is owned by a Verizon customer, you would send an email to 4155551234@vtext.com .\n\nYou can find the SMS email gateway for a cell phone provider by doing a web search for \u201csms email gateway provider name ,\u201d but Table 18-4 lists the gateways for several popular providers. Many providers have separate email servers for SMS , which limits messages to 160 characters, and MMS (multimedia messaging service), which has no character limit. If you wanted to send a photo, you would have to use the MMS gateway and attach the file to the email.\n\nIf you don\u2019t know the recipient\u2019s cell phone provider, you can try using a carrier lookup site, which should provide a phone number\u2019s carrier. The best way to find these sites is by searching the web for \u201cfind cell phone provider for number.\u201d Many of these sites will let you look up numbers for free (though will charge you if you need to look up hundreds or thousands of phone numbers through their API).\n\nTable 18-4: SMS Email Gateways for Cell Phone Providers\n\nWhile SMS email gateways are free and simple to use, there are several major disadvantages to them:\n\n* You have no guarantee that the text will arrive promptly, or at all.\n* You have no way of knowing if the text failed to arrive.\n* The text recipient has no way of replying.\n* SMS gateways may block you if you send too many emails, and there\u2019s no way to find out how many is \u201ctoo many.\u201d\n* Just because the SMS gateway delivers a text message today doesn\u2019t mean it will work tomorrow.\n\nSending texts via an SMS gateway is ideal when you need to send the occasional, nonurgent message. If you need more reliable service, use a non-email SMS gateway service, as described next.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "How do I use 'Sending Text Messages with Twilio' in Python?", "input": "", "output": "In this section, you\u2019ll learn how to sign up for the free Twilio service and use its Python module to send text messages. Twilio is an SMS gateway service , which means it allows you to send text messages from your programs via the internet. Although the free trial account comes with a limited amount of credit and the texts will be prefixed with the words Sent from a Twilio trial account , this trial service is probably adequate for your personal programs.\n\nBut Twilio isn\u2019t the only SMS gateway service. If you prefer not to use Twilio, you can find alternative services by searching online for \u201cfree sms\u201d \u201cgateway,\u201d \u201cpython sms api,\u201d or even \u201ctwilio alternatives.\u201d\n\nBefore signing up for a Twilio account, install the twilio module with pip install --user --upgrade twilio on Windows (or use pip3 on macOS and Linux). Appendix A has more details about installing third-party modules.\n\nGo to https://twilio.com/ and fill out the sign-up form. Once you\u2019ve signed up for a new account, you\u2019ll need to verify a mobile phone number that you want to send texts to. Go to the Verified Caller IDs page and add a phone number you have access to. Twilio will text a code to this number that you must enter to verify the number. (This verification is necessary to prevent people from using the service to spam random phone numbers with text messages.) You will now be able to send texts to this phone number using the twilio module.\n\nTwilio provides your trial account with a phone number to use as the sender of text messages. You will need two more pieces of information: your account SID and the auth (authentication) token. You can find this information on the Dashboard page when you are logged in to your Twilio account. These values act as your Twilio username and password when logging in from a Python program.\n\nOnce you\u2019ve installed the twilio module, signed up for a Twilio account, verified your phone number, registered a Twilio phone number, and obtained your account SID and auth token, you will finally be ready to send yourself text messages from your Python scripts.\n\nCompared to all the registration steps, the actual Python code is fairly simple. With your computer connected to the internet, enter the following into the interactive shell, replacing the accountSID , authToken , myTwilioNumber , and myCellPhone variable values with your real information:\n\n\u278a >>> from twilio.rest import Client >>> accountSID = ' ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ' >>> authToken\u00a0\u00a0= ' xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ' \u278b >>> twilioCli = Client(accountSID, authToken) >>> myTwilioNumber = '+14955551234' >>> myCellPhone = '+14955558888' \u278c >>> message = twilioCli.messages.create (body='Mr. Watson - Come here - I want to see you.', from_=myTwilioNumber, to=myCellPhone)\n\nA few moments after typing the last line, you should receive a text message that reads, Sent from your Twilio trial account - Mr. Watson - Come here - I want to see you .\n\nBecause of the way the twilio module is set up, you need to import it using from twilio.rest import Client , not just import twilio \u278a . Store your account SID in accountSID and your auth token in authToken and then call Client() and pass it accountSID and authToken . The call to Client() returns a Client object \u278b . This object has a messages attribute, which in turn has a create() method you can use to send text messages. This is the method that will instruct Twilio\u2019s servers to send your text message. After storing your Twilio number and cell phone number in myTwilioNumber and myCellPhone , respectively, call create() and pass it keyword arguments specifying the body of the text message, the sender\u2019s number ( myTwilioNumber ), and the recipient\u2019s number ( myCellPhone ) \u278c .\n\nThe Message object returned from the create() method will have information about the text message that was sent. Continue the interactive shell example by entering the following:\n\n>>> message.to '+14955558888' >>> message.from _ '+14955551234' >>> message.body 'Mr. Watson - Come here - I want to see you.'\n\nThe to , from_ , and body attributes should hold your cell phone number, Twilio number, and message, respectively. Note that the sending phone number is in the from_ attribute\u2014with an underscore at the end\u2014not from . This is because from is a keyword in Python (you\u2019ve seen it used in the from modulename import * form of import statement, for example), so it cannot be used as an attribute name. Continue the interactive shell example with the following:\n\n>>> message.status 'queued' >>> message.date_created datetime.datetime(2019, 7, 8, 1, 36, 18) >>> message.date_sent == None True\n\nThe status attribute should give you a string. The date_created and date_sent attributes should give you a datetime object if the message has been created and sent. It may seem odd that the status attribute is set to 'queued' and the date_sent attribute is set to None when you\u2019ve already received the text message. This is because you captured the Message object in the message variable before the text was actually sent. You will need to refetch the Message object in order to see its most up-to-date status and date_sent . Every Twilio message has a unique string ID (SID) that can be used to fetch the latest update of the Message object. Continue the inter\u00adactive shell example by entering the following:\n\n>>> message.sid 'SM09520de7639ba3af137c6fcb7c5f4b51' \u278a >>> updatedMessage = twilioCli.messages.get(message.sid) >>> updatedMessage.status 'delivered' >>> updatedMessage.date_sent datetime.datetime(2019, 7, 8, 1, 36, 18)\n\nEntering message.sid shows you this message\u2019s long SID. By passing this SID to the Twilio client\u2019s get() method \u278a , you can retrieve a new Message object with the most up-to-date information. In this new Message object, the status and date_sent attributes are correct.\n\nThe status attribute will be set to one of the following string values: 'queued' , 'sending' , 'sent' , 'delivered' , 'undelivered' , or 'failed' . These statuses are self-explanatory, but for more precise details, take a look at the resources at https://nostarch.com/automatestuff2/ .", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "Provide a guide on 'Project: \u201cJust Text Me\u201d Module' in Python.", "input": "", "output": "The person you\u2019ll most often text from your programs is probably you. Texting is a great way to send yourself notifications when you\u2019re away from your computer. If you\u2019ve automated a boring task with a program that takes a couple of hours to run, you could have it notify you with a text when it\u2019s finished. Or you may have a regularly scheduled program running that sometimes needs to contact you, such as a weather-checking program that texts you a reminder to pack an umbrella.\n\nAs a simple example, here\u2019s a small Python program with a textmyself() function that sends a message passed to it as a string argument. Open a new file editor tab and enter the following code, replacing the account SID, auth token, and phone numbers with your own information. Save it as textMyself.py .\n\n#! python3 # textMyself.py - Defines the textmyself() function that texts a message # passed to it as a string. # Preset values: accountSID = ' ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ' authToken\u00a0\u00a0= ' xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ' myNumber = '+15559998888' twilioNumber = '+15552225678' from twilio.rest import Client \u278a def textmyself(message): \u278b twilioCli = Client(accountSID, authToken) \u278c twilioCli.messages.create(body=message, from_=twilioNumber, to=myNumber)\n\nThis program stores an account SID, auth token, sending number, and receiving number. It then defined textmyself() to take on argument \u278a , make a Client object \u278b , and call create() with the message you passed \u278c .\n\nIf you want to make the textmyself() function available to your other programs, simply place the textMyself.py file in the same folder as your Python script. Whenever you want one of your programs to text you, just add the following:\n\nimport textmyself textmyself.textmyself('The boring task is finished.')\n\nYou need to sign up for Twilio and write the texting code only once. After that, it\u2019s just two lines of code to send a text from any of your other programs.", "source": "https://automatetheboringstuff.com/2e/chapter18/", "category": "18SENDING EMAIL AND TEXT MESSAGES"}
{"instruction": "What is '19MANIPULATING IMAGES' and how does it work in Python?", "input": "", "output": "If you have a digital camera or even if you just upload photos from your phone to Facebook, you probably cross paths with digital image files all the time. You may know how to use basic graphics software, such as Microsoft Paint or Paintbrush, or even more advanced applications such as Adobe Photoshop. But if you need to edit a massive number of images, editing them by hand can be a lengthy, boring job.\n\nEnter Python. Pillow is a third-party Python module for interacting with image files. The module has several functions that make it easy to crop, resize, and edit the content of an image. With the power to manipulate images the same way you would with software such as Microsoft Paint or Adobe Photoshop, Python can automatically edit hundreds or thousands of images with ease. You can install Pillow by running pip install --user -U pillow==9.2.0 . Appendix A has more details on installing modules.", "source": "https://automatetheboringstuff.com/2e/chapter19/", "category": "19MANIPULATING IMAGES"}
{"instruction": "How do I use 'Computer Image Fundamentals' in Python?", "input": "", "output": "In order to manipulate an image, you need to understand the basics of how computers deal with colors and coordinates in images and how you can work with colors and coordinates in Pillow. But before you continue, install the pillow module. See Appendix A for help installing third-party modules.\n\nComputer programs often represent a color in an image as an RGBA value . An RGBA value is a group of numbers that specify the amount of red, green, blue, and alpha (or transparency) in a color. Each of these component values is an integer from 0 (none at all) to 255 (the maximum). These RGBA values are assigned to individual pixels ; a pixel is the smallest dot of a single color the computer screen can show (as you can imagine, there are millions of pixels on a screen). A pixel\u2019s RGB setting tells it precisely what shade of color it should display. Images also have an alpha value to create RGBA values. If an image is displayed on the screen over a background image or desktop wallpaper, the alpha value determines how much of the background you can \u201csee through\u201d the image\u2019s pixel.\n\nIn Pillow, RGBA values are represented by a tuple of four integer values. For example, the color red is represented by (255, 0, 0, 255) . This color has the maximum amount of red, no green or blue, and the maximum alpha value, meaning it is fully opaque. Green is represented by (0, 255, 0, 255) , and blue is (0, 0, 255, 255) . White, the combination of all colors, is (255, 255, 255, 255) , while black, which has no color at all, is (0, 0, 0, 255) .\n\nIf a color has an alpha value of 0, it is invisible, and it doesn\u2019t really matter what the RGB values are. After all, invisible red looks the same as invisible black.\n\nPillow uses the standard color names that HTML uses. Table 19-1 lists a selection of standard color names and their values.\n\nTable 19-1: Standard Color Names and Their RGBA Values\n\nPillow offers the ImageColor.getcolor() function so you don\u2019t have to memorize RGBA values for the colors you want to use. This function takes a color name string as its first argument, and the string 'RGBA' as its second argument, and it returns an RGBA tuple.\n\nTo see how this function works, enter the following into the interactive shell:\n\n\u278a >>> from PIL import ImageColor \u278b >>> ImageColor.getcolor('red', 'RGBA') (255, 0, 0, 255) \u278c >>> ImageColor.getcolor('RED', 'RGBA') (255, 0, 0, 255) >>> ImageColor.getcolor('Black', 'RGBA') (0, 0, 0, 255) >>> ImageColor.getcolor('chocolate', 'RGBA') (210, 105, 30, 255) >>> ImageColor.getcolor('CornflowerBlue', 'RGBA') (100, 149, 237, 255)\n\nFirst, you need to import the ImageColor module from PIL \u278a (not from Pillow; you\u2019ll see why in a moment). The color name string you pass to ImageColor.getcolor() is case-insensitive, so passing 'red' \u278b and passing 'RED' \u278c give you the same RGBA tuple. You can also pass more unusual color names, like 'chocolate' and 'Cornflower Blue' .\n\nPillow supports a huge number of color names, from 'aliceblue' to 'whitesmoke' . You can find the full list of more than 100 standard color names in the resources at https://nostarch.com/automatestuff2/ .\n\nImage pixels are addressed with x- and y-coordinates, which respectively specify a pixel\u2019s horizontal and vertical locations in an image. The origin is the pixel at the top-left corner of the image and is specified with the notation (0, 0). The first zero represents the x-coordinate, which starts at zero at the origin and increases going from left to right. The second zero represents the y-coordinate, which starts at zero at the origin and increases going down the image. This bears repeating: y-coordinates increase going downward, which is the opposite of how you may remember y-coordinates being used in math class. Figure 19-1 demonstrates how this coordinate system works.\n\nFigure 19-1: The x- and y-coordinates of a 28\u00d727 image of some sort of ancient data storage device\n\nMany of Pillow\u2019s functions and methods take a box tuple argument. This means Pillow is expecting a tuple of four integer coordinates that represent a rectangular region in an image. The four integers are, in order, as follows:\n\nLeft The x-coordinate of the leftmost edge of the box.\n\nTop The y-coordinate of the top edge of the box.\n\nRight The x-coordinate of one pixel to the right of the rightmost edge of the box. This integer must be greater than the left integer.\n\nBottom The y-coordinate of one pixel lower than the bottom edge of the box. This integer must be greater than the top integer.\n\nNote that the box includes the left and top coordinates and goes up to but does not include the right and bottom coordinates. For example, the box tuple (3, 1, 9, 6) represents all the pixels in the black box in Figure 19-2.\n\nFigure 19-2: The area represented by the box tuple (3, 1, 9, 6)", "source": "https://automatetheboringstuff.com/2e/chapter19/", "category": "19MANIPULATING IMAGES"}
{"instruction": "What is 'Manipulating Images with Pillow' and how does it work in Python?", "input": "", "output": "Now that you know how colors and coordinates work in Pillow, let\u2019s use Pillow to manipulate an image. Figure 19-3 is the image that will be used for all the interactive shell examples in this chapter. You can download it from https://nostarch.com/automatestuff2/ .\n\nOnce you have the image file zophie.png in your current working directory, you\u2019ll be ready to load the image of Zophie into Python, like so:\n\n>>> from PIL import Image >>> catIm = Image.open('zophie.png')\n\nTo load the image, import the Image module from Pillow and call Image.open() , passing it the image\u2019s filename. You can then store the loaded image in a variable like CatIm . Pillow\u2019s module name is PIL to make it backward compatible with an older module called Python Imaging Library; this is why you must run from PIL import Image instead of from Pillow import Image . Because of the way Pillow\u2019s creators set up the pillow module, you must use the import statement from PIL import Image , rather than simply import PIL .\n\nFigure 19-3: My cat, Zophie. The camera adds 10 pounds (which is a lot for a cat).\n\nIf the image file isn\u2019t in the current working directory, change the working directory to the folder that contains the image file by calling the os.chdir() function.\n\n>>> import os >>> os.chdir('C:\\\\folder_with_image_file')\n\nThe Image.open() function returns a value of the Image object data type, which is how Pillow represents an image as a Python value. You can load an Image object from an image file (of any format) by passing the Image.open() function a string of the filename. Any changes you make to the Image object can be saved to an image file (also of any format) with the save() method. All the rotations, resizing, cropping, drawing, and other image manipulations will be done through method calls on this Image object.\n\nTo shorten the examples in this chapter, I\u2019ll assume you\u2019ve imported Pillow\u2019s Image module and that you have the Zophie image stored in a variable named catIm . Be sure that the zophie.png file is in the current working directory so that the Image.open() function can find it. Otherwise, you will also have to specify the full absolute path in the string argument to Image.open() .\n\nAn Image object has several useful attributes that give you basic information about the image file it was loaded from: its width and height, the filename, and the graphics format (such as JPEG, GIF, or PNG).\n\nFor example, enter the following into the interactive shell:\n\n>>> from PIL import Image >>> catIm = Image.open('zophie.png') >>> catIm.size \u278a (816, 1088) \u278b >>> width, height = catIm.size \u278c >>> width 816 \u278d >>> height 1088 >>> catIm.filename 'zophie.png' >>> catIm.format 'PNG' >>> catIm.format_description 'Portable network graphics' \u278e >>> catIm.save('zophie.jpg')\n\nAfter making an Image object from zophie.png and storing the Image object in catIm , we can see that the object\u2019s size attribute contains a tuple of the image\u2019s width and height in pixels \u278a . We can assign the values in the tuple to width and height variables \u278b in order to access with width \u278c and height \u278d individually. The filename attribute describes the original file\u2019s name. The format and format_description attributes are strings that describe the image format of the original file (with format_description being a bit more verbose).\n\nFinally, calling the save() method and passing it 'zophie.jpg' saves a new image with the filename zophie.jpg to your hard drive \u278e . Pillow sees that the file extension is .jpg and automatically saves the image using the JPEG image format. Now you should have two images, zophie.png and zophie.jpg , on your hard drive. While these files are based on the same image, they are not identical because of their different formats.\n\nPillow also provides the Image.new() function, which returns an Image object\u2014much like Image.open() , except the image represented by Image.new() \u2019s object will be blank. The arguments to Image.new() are as follows:\n\n* The string 'RGBA' , which sets the color mode to RGBA. (There are other modes that this book doesn\u2019t go into.)\n* The size, as a two-integer tuple of the new image\u2019s width and height.\n* The background color that the image should start with, as a four-integer tuple of an RGBA value. You can use the return value of the ImageColor.getcolor() function for this argument. Alternatively, Image.new() also supports just passing the string of the standard color name.\n\nFor example, enter the following into the interactive shell:\n\n>>> from PIL import Image \u278a >>> im = Image.new('RGBA', (100, 200), 'purple') >>> im.save('purpleImage.png') \u278b >>> im2 = Image.new('RGBA', (20, 20)) >>> im2.save('transparentImage.png')\n\nHere we create an Image object for an image that\u2019s 100 pixels wide and 200 pixels tall, with a purple background \u278a . This image is then saved to the file purpleImage.png . We call Image.new() again to create another Image object, this time passing (20, 20) for the dimensions and nothing for the background color \u278b . Invisible black, (0, 0, 0, 0) , is the default color used if no color argument is specified, so the second image has a transparent background; we save this 20\u00d720 transparent square in transparentImage.png .\n\nCropping an image means selecting a rectangular region inside an image and removing everything outside the rectangle. The crop() method on Image objects takes a box tuple and returns an Image object representing the cropped image. The cropping does not happen in place\u2014that is, the original Image object is left untouched, and the crop() method returns a new Image object. Remember that a boxed tuple\u2014in this case, the cropped section\u2014includes the left column and top row of pixels but only goes up to and does not include the right column and bottom row of pixels.\n\nEnter the following into the interactive shell:\n\n>>> from PIL import Image >>> catIm = Image.open('zophie.png') >>> croppedIm = catIm.crop((335, 345, 565, 560)) >>> croppedIm.save('cropped.png')\n\nThis makes a new Image object for the cropped image, stores the object in croppedIm , and then calls save() on croppedIm to save the cropped image in cropped.png . The new file cropped.png will be created from the original image, like in Figure 19-4.\n\nFigure 19-4: The new image will be just the cropped section of the original image.\n\nThe copy() method will return a new Image object with the same image as the Image object it was called on. This is useful if you need to make changes to an image but also want to keep an untouched version of the original. For example, enter the following into the interactive shell:\n\n>>> from PIL import Image >>> catIm = Image.open('zophie.png') >>> catCopyIm = catIm.copy()\n\nThe catIm and catCopyIm variables contain two separate Image objects, which both have the same image on them. Now that you have an Image object stored in catCopyIm , you can modify catCopyIm as you like and save it to a new filename, leaving zophie.png untouched. For example, let\u2019s try modifying catCopyIm with the paste() method.\n\nThe paste() method is called on an Image object and pastes another image on top of it. Let\u2019s continue the shell example by pasting a smaller image onto catCopyIm .\n\n>>> faceIm = catIm.crop((335, 345, 565, 560)) >>> faceIm.size (230, 215) >>> catCopyIm.paste(faceIm, (0, 0)) >>> catCopyIm.paste(faceIm, (400, 500)) >>> catCopyIm.save('pasted.png')\n\nFirst we pass crop() a box tuple for the rectangular area in zophie.png that contains Zophie\u2019s face. This creates an Image object representing a 230\u00d7215 crop, which we store in faceIm . Now we can paste faceIm onto catCopyIm . The paste() method takes two arguments: a \u201csource\u201d Image object and a tuple of the x- and y-coordinates where you want to paste the top-left corner of the source Image object onto the main Image object. Here we call paste() twice on catCopyIm , passing (0, 0) the first time and (400, 500) the second time. This pastes faceIm onto catCopyIm twice: once with the top-left corner of faceIm at (0, 0) on catCopyIm , and once with the top-left corner of faceIm at (400, 500). Finally, we save the modified catCopyIm to pasted.png . The pasted.png image looks like Figure 19-5.\n\nNote that the paste() method modifies its Image object in place ; it does not return an Image object with the pasted image. If you want to call paste() but also keep an untouched version of the original image around, you\u2019ll need to first copy the image and then call paste() on that copy.\n\nFigure 19-5: Zophie the cat, with her face pasted twice\n\nSay you want to tile Zophie\u2019s head across the entire image, as in Figure 19-6. You can achieve this effect with just a couple for loops. Continue the interactive shell example by entering the following:\n\n>>> catImWidth, catImHeight = catIm.size >>> faceImWidth, faceImHeight = faceIm.size \u278a >>> catCopyTwo = catIm.copy() \u278b >>> for left in range(0, catImWidth, faceImWidth): \u278c for top in range(0, catImHeight, faceImHeight): print(left, top) catCopyTwo.paste(faceIm, (left, top)) 0 0 0 215 0 430 0 645 0 860 0 1075 230 0 230 215 -- snip -- 690 860 690 1075 >>> catCopyTwo.save('tiled.png')\n\nFigure 19-6: Nested for loops used with paste() to duplicate the cat\u2019s face (a dupli-cat, if you will)\n\nHere we store the width of height of catIm in catImWidth and catImHeight . At \u278a we make a copy of catIm and store it in catCopyTwo . Now that we have a copy that we can paste onto, we start looping to paste faceIm onto catCopyTwo . The outer for loop\u2019s left variable starts at 0 and increases by faceImWidth(230) \u278b . The inner for loop\u2019s top variable start at 0 and increases by faceImHeight(215) \u278c . These nested for loops produce values for left and top to paste a grid of faceIm images over the catCopyTwo Image object, as in Figure 19-6. To see our nested loops working, we print left and top . After the pasting is complete, we save the modified catCopyTwo to tiled.png .\n\nThe resize() method is called on an Image object and returns a new Image object of the specified width and height. It accepts a two-integer tuple argument, representing the new width and height of the returned image. Enter the following into the interactive shell:\n\n>>> from PIL import Image >>> catIm = Image.open('zophie.png') \u278a >>> width, height = catIm.size \u278b >>> quartersizedIm = catIm.resize((int(width / 2), int(height / 2))) >>> quartersizedIm.save('quartersized.png') \u278c >>> svelteIm = catIm.resize((width, height + 300)) >>> svelteIm.save('svelte.png')\n\nHere we assign the two values in the catIm.size tuple to the variables width and height \u278a . Using width and height instead of catIm.size[0] and catIm.size[1] makes the rest of the code more readable.\n\nThe first resize() call passes int(width / 2) for the new width and int(height / 2) for the new height \u278b , so the Image object returned from resize() will be half the length and width of the original image, or one-quarter of the original image size overall. The resize() method accepts only integers in its tuple argument, which is why you needed to wrap both divisions by 2 in an int() call.\n\nThis resizing keeps the same proportions for the width and height. But the new width and height passed to resize() do not have to be proportional to the original image. The svelteIm variable contains an Image object that has the original width but a height that is 300 pixels taller \u278c , giving Zophie a more slender look.\n\nNote that the resize() method does not edit the Image object in place but instead returns a new Image object.\n\nImages can be rotated with the rotate() method, which returns a new Image object of the rotated image and leaves the original Image object unchanged. The argument to rotate() is a single integer or float representing the number of degrees to rotate the image counterclockwise. Enter the following into the interactive shell:\n\n>>> from PIL import Image >>> catIm = Image.open('zophie.png') >>> catIm.rotate(90).save('rotated90.png') >>> catIm.rotate(180).save('rotated180.png') >>> catIm.rotate(270).save('rotated270.png')\n\nNote how you can chain method calls by calling save() directly on the Image object returned from rotate() . The first rotate() and save() call makes a new Image object representing the image rotated counterclockwise by 90 degrees and saves the rotated image to rotated90.png . The second and third calls do the same, but with 180 degrees and 270 degrees. The results look like Figure 19-7.\n\nFigure 19-7: The original image (left) and the image rotated counterclockwise by 90, 180, and 270 degrees\n\nNotice that the width and height of the image change when the image is rotated 90 or 270 degrees. If you rotate an image by some other amount, the original dimensions of the image are maintained. On Windows, a black background is used to fill in any gaps made by the rotation, like in Figure 19-8. On macOS, transparent pixels are used for the gaps instead.\n\nThe rotate() method has an optional expand keyword argument that can be set to True to enlarge the dimensions of the image to fit the entire rotated new image. For example, enter the following into the interactive shell:\n\n>>> catIm.rotate(6).save('rotated6.png') >>> catIm.rotate(6, expand=True).save('rotated6_expanded.png')\n\nThe first call rotates the image 6 degrees and saves it to rotate6.png (see the image on the left of Figure 19-8). The second call rotates the image 6 degrees with expand set to True and saves it to rotate6_expanded.png (see the image on the right of Figure 19-8).\n\nFigure 19-8: The image rotated 6 degrees normally (left) and with expand=True (right)\n\nYou can also get a \u201cmirror flip\u201d of an image with the transpose() method. You must pass either Image.FLIP_LEFT_RIGHT or Image.FLIP_TOP_BOTTOM to the transpose() method. Enter the following into the interactive shell:\n\n>>> catIm.transpose(Image.FLIP_LEFT_RIGHT).save('horizontal_flip.png') >>> catIm.transpose(Image.FLIP_TOP_BOTTOM).save('vertical_flip.png')\n\nLike rotate() , transpose() creates a new Image object. Here we pass Image.FLIP_LEFT_RIGHT to flip the image horizontally and then save the result to horizontal_flip.png . To flip the image vertically, we pass Image.FLIP_TOP_BOTTOM and save to vertical_flip.png . The results look like Figure 19-9.\n\nFigure 19-9: The original image (left), horizontal flip (center), and vertical flip (right)\n\nThe color of an individual pixel can be retrieved or set with the getpixel() and putpixel() methods. These methods both take a tuple representing the x- and y-coordinates of the pixel. The putpixel() method also takes an additional tuple argument for the color of the pixel. This color argument is a four-integer RGBA tuple or a three-integer RGB tuple. Enter the following into the interactive shell:\n\n>>> from PIL import Image \u278a >>> im = Image.new('RGBA', (100, 100)) \u278b >>> im.getpixel((0, 0)) (0, 0, 0, 0) \u278c >>> for x in range(100): for y in range(50): \u278d im.putpixel((x, y), (210, 210, 210)) >>> from PIL import ImageColor \u278e >>> for x in range(100): for y in range(50, 100): \u278f im.putpixel((x, y), ImageColor.getcolor('darkgray', 'RGBA')) >>> im.getpixel((0, 0)) (210, 210, 210, 255) >>> im.getpixel((0, 50)) (169, 169, 169, 255) >>> im.save('putPixel.png')\n\nAt \u278a we make a new image that is a 100\u00d7100 transparent square. Calling getpixel() on some coordinates in this image returns (0, 0, 0, 0) because the image is transparent \u278b . To color pixels in this image, we can use nested for loops to go through all the pixels in the top half of the image \u278c and color each pixel using putpixel() \u278d . Here we pass putpixel() the RGB tuple (210, 210, 210) , a light gray.\n\nSay we want to color the bottom half of the image dark gray but don\u2019t know the RGB tuple for dark gray. The putpixel() method doesn\u2019t accept a standard color name like 'darkgray' , so you have to use ImageColor.getcolor() to get a color tuple from 'darkgray' . Loop through the pixels in the bottom half of the image \u278e and pass putpixel() the return value of ImageColor.getcolor() \u278f , and you should now have an image that is light gray in its top half and dark gray in the bottom half, as shown in Figure 19-10. You can call getpixel() on some coordinates to confirm that the color at any given pixel is what you expect. Finally, save the image to putPixel.png .\n\nFigure 19-10: The putPixel.png image\n\nOf course, drawing one pixel at a time onto an image isn\u2019t very convenient. If you need to draw shapes, use the ImageDraw functions explained later in this chapter.", "source": "https://automatetheboringstuff.com/2e/chapter19/", "category": "19MANIPULATING IMAGES"}
{"instruction": "What is 'Project: Adding a Logo' and how does it work in Python?", "input": "", "output": "Say you have the boring job of resizing thousands of images and adding a small logo watermark to the corner of each. Doing this with a basic graphics program such as Paintbrush or Paint would take forever. A fancier graphics application such as Photoshop can do batch processing, but that software costs hundreds of dollars. Let\u2019s write a script to do it instead.\n\nSay that Figure 19-11 is the logo you want to add to the bottom-right corner of each image: a black cat icon with a white border, with the rest of the image transparent.\n\nFigure 19-11: The logo to be added to the image\n\nAt a high level, here\u2019s what the program should do:\n\n1. Load the logo image.\n2. Loop over all .png and .jpg files in the working directory.\n3. Check whether the image is wider or taller than 300 pixels.\n4. If so, reduce the width or height (whichever is larger) to 300 pixels and scale down the other dimension proportionally.\n5. Paste the logo image into the corner.\n6. Save the altered images to another folder.\n\nThis means the code will need to do the following:\n\n1. Open the catlogo.png file as an Image object.\n2. Loop over the strings returned from os.listdir('.') .\n3. Get the width and height of the image from the size attribute.\n4. Calculate the new width and height of the resized image.\n5. Call the resize() method to resize the image.\n6. Call the paste() method to paste the logo.\n7. Call the save() method to save the changes, using the original filename.\n\nFor this project, open a new file editor tab, enter the following code, and save it as resizeAndAddLogo.py :\n\n#! python3 # resizeAndAddLogo.py - Resizes all images in current working directory to fit # in a 300x300 square, and adds catlogo.png to the lower-right corner. import os from PIL import Image \u278a SQUARE_FIT_SIZE = 300 \u278b LOGO_FILENAME = 'catlogo.png' \u278c logoIm = Image.open(LOGO_FILENAME) \u278d logoWidth, logoHeight = logoIm.size # TODO: Loop over all files in the working directory. # TODO: Check if image needs to be resized. # TODO: Calculate the new width and height to resize to. # TODO: Resize the image. # TODO: Add the logo. # TODO: Save changes.\n\nBy setting up the SQUARE_FIT_SIZE \u278a and LOGO_FILENAME \u278b constants at the start of the program, we\u2019ve made it easy to change the program later. Say the logo that you\u2019re adding isn\u2019t the cat icon, or say you\u2019re reducing the output images\u2019 largest dimension to something other than 300 pixels. With these constants at the start of the program, you can just open the code, change those values once, and you\u2019re done. (Or you can make it so that the values for these constants are taken from the command line arguments.) Without these constants, you\u2019d instead have to search the code for all instances of 300 and 'catlogo.png' and replace them with the values for your new project. In short, using constants makes your program more generalized.\n\nThe logo Image object is returned from Image.open() \u278c . For readability, logoWidth and logoHeight are assigned to the values from logoIm.size \u278d .\n\nThe rest of the program is a skeleton of TODO comments for now.\n\nNow you need to find every .png file and .jpg file in the current working directory. You don\u2019t want to add the logo image to the logo image itself, so the program should skip any image with a filename that\u2019s the same as LOGO_FILENAME . Add the following to your code:\n\n#! python3 # resizeAndAddLogo.py - Resizes all images in current working directory to fit # in a 300x300 square, and adds catlogo.png to the lower-right corner. import os from PIL import Image -- snip -- os.makedirs('withLogo', exist_ok=True) # Loop over all files in the working directory. \u278a for filename in os.listdir('.'): \u278b if not (filename.endswith('.png') or filename.endswith('.jpg')) \\ or filename == LOGO_FILENAME: \u278c continue\u00a0\u00a0\u00a0\u00a0# skip non-image files and the logo file itself \u278d im = Image.open(filename) width, height = im.size -- snip --\n\nFirst, the os.makedirs() call creates a withLogo folder to store the finished images with logos, instead of overwriting the original image files. The exist_ok=True keyword argument will keep os.makedirs() from raising an exception if withLogo already exists. While looping through all the files in the working directory with os.listdir('.') \u278a , the long if statement \u278b checks whether each filename doesn\u2019t end with .png or .jpg . If so\u2014or if the file is the logo image itself\u2014then the loop should skip it and use continue \u278c to go to the next file. If filename does end with '.png' or '.jpg' (and isn\u2019t the logo file), you can open it as an Image object \u278d and set width and height .\n\nThe program should resize the image only if the width or height is larger than SQUARE_FIT_SIZE (300 pixels, in this case), so put all of the resizing code inside an if statement that checks the width and height variables. Add the following code to your program:\n\n#! python3 # resizeAndAddLogo.py - Resizes all images in current working directory to fit # in a 300x300 square, and adds catlogo.png to the lower-right corner. import os from PIL import Image -- snip -- # Check if image needs to be resized. if width > SQUARE_FIT_SIZE and height > SQUARE_FIT_SIZE: # Calculate the new width and height to resize to. if width > height: \u278a height = int((SQUARE_FIT_SIZE / width) * height) width = SQUARE_FIT_SIZE else: \u278b width = int((SQUARE_FIT_SIZE / height) * width) height = SQUARE_FIT_SIZE # Resize the image. print('Resizing %s...' % (filename)) \u278c im = im.resize((width, height)) -- snip --\n\nIf the image does need to be resized, you need to find out whether it is a wide or tall image. If width is greater than height , then the height should be reduced by the same proportion that the width would be reduced \u278a . This proportion is the SQUARE_FIT_SIZE value divided by the current width. The new height value is this proportion multiplied by the current height value. Since the division operator returns a float value and resize() requires the dimensions to be integers, remember to convert the result to an integer with the int() function. Finally, the new width value will simply be set to SQUARE_FIT_SIZE .\n\nIf the height is greater than or equal to the width (both cases are handled in the else clause), then the same calculation is done, except with the height and width variables swapped \u278b .\n\nOnce width and height contain the new image dimensions, pass them to the resize() method and store the returned Image object in im \u278c .\n\nWhether or not the image was resized, the logo should still be pasted to the bottom-right corner. Where exactly the logo should be pasted depends on both the size of the image and the size of the logo. Figure 19-12 shows how to calculate the pasting position. The left coordinate for where to paste the logo will be the image width minus the logo width; the top coordinate for where to paste the logo will be the image height minus the logo height.\n\nFigure 19-12: The left and top coordinates for placing the logo in the bottom-right corner should be the image width/height minus the logo width/height.\n\nAfter your code pastes the logo into the image, it should save the modified Image object. Add the following to your program:\n\n#! python3 # resizeAndAddLogo.py - Resizes all images in current working directory to fit # in a 300x300 square, and adds catlogo.png to the lower-right corner. import os from PIL import Image -- snip -- # Check if image needs to be resized. -- snip -- # Add the logo. \u278a print('Adding logo to %s...' % (filename)) \u278b im.paste(logoIm, (width - logoWidth, height - logoHeight), logoIm) # Save changes. \u278c im.save(os.path.join('withLogo', filename))\n\nThe new code prints a message telling the user that the logo is being added \u278a , pastes logoIm onto im at the calculated coordinates \u278b , and saves the changes to a filename in the withLogo directory \u278c . When you run this program with the zophie.png file as the only image in the working directory, the output will look like this:\n\nResizing zophie.png... Adding logo to zophie.png...\n\nThe image zophie.png will be changed to a 225\u00d7300-pixel image that looks like Figure 19-13. Remember that the paste() method will not paste the transparency pixels if you do not pass the logoIm for the third argument as well. This program can automatically resize and \u201clogo-ify\u201d hundreds of images in just a couple minutes.\n\nFigure 19-13: The image zophie.png resized and the logo added (left). If you forget the third argument, the transparent pixels in the logo will be copied as solid white pixels (right).\n\nBeing able to composite images or modify image sizes in a batch can be useful in many applications. You could write similar programs to do the following:\n\n* Add text or a website URL to images.\n* Add timestamps to images.\n* Copy or move images into different folders based on their sizes.\n* Add a mostly transparent watermark to an image to prevent others from copying it.", "source": "https://automatetheboringstuff.com/2e/chapter19/", "category": "19MANIPULATING IMAGES"}
{"instruction": "How do I use 'Drawing on Images' in Python?", "input": "", "output": "If you need to draw lines, rectangles, circles, or other simple shapes on an image, use Pillow\u2019s ImageDraw module. Enter the following into the interactive shell:\n\n>>> from PIL import Image, ImageDraw >>> im = Image.new('RGBA', (200, 200), 'white') >>> draw = ImageDraw.Draw(im)\n\nFirst, we import Image and ImageDraw . Then we create a new image, in this case, a 200\u00d7200 white image, and store the Image object in im . We pass the Image object to the ImageDraw.Draw() function to receive an ImageDraw object. This object has several methods for drawing shapes and text onto an Image object. Store the ImageDraw object in a variable like draw so you can use it easily in the following example.\n\nThe following ImageDraw methods draw various kinds of shapes on the image. The fill and outline parameters for these methods are optional and will default to white if left unspecified.\n\nThe point( xy , fill ) method draws individual pixels. The xy argument represents a list of the points you want to draw. The list can be a list of x- and y-coordinate tuples, such as [(x, y), (x, y), ...] , or a list of x- and y-coordinates without tuples, such as [x1, y1, x2, y2, ...] . The fill argument is the color of the points and is either an RGBA tuple or a string of a color name, such as 'red' . The fill argument is optional.\n\nThe line( xy , fill , width ) method draws a line or series of lines. xy is either a list of tuples, such as [(x, y), (x, y), ...] , or a list of integers, such as [x1, y1, x2, y2, ...] . Each point is one of the connecting points on the lines you\u2019re drawing. The optional fill argument is the color of the lines, as an RGBA tuple or color name. The optional width argument is the width of the lines and defaults to 1 if left unspecified.\n\nThe rectangle( xy , fill , outline ) method draws a rectangle. The xy argument is a box tuple of the form ( left , top , right , bottom ) . The left and top values specify the x- and y-coordinates of the upper-left corner of the rectangle, while right and bottom specify the lower-right corner. The optional fill argument is the color that will fill the inside of the rectangle. The optional outline argument is the color of the rectangle\u2019s outline.\n\nThe ellipse( xy , fill , outline ) method draws an ellipse. If the width and height of the ellipse are identical, this method will draw a circle. The xy argument is a box tuple ( left , top , right , bottom ) that represents a box that precisely contains the ellipse. The optional fill argument is the color of the inside of the ellipse, and the optional outline argument is the color of the ellipse\u2019s outline.\n\nThe polygon( xy , fill , outline ) method draws an arbitrary polygon. The xy argument is a list of tuples, such as [(x, y), (x, y), ...] , or integers, such as [x1, y1, x2, y2, ...] , representing the connecting points of the polygon\u2019s sides. The last pair of coordinates will be automatically connected to the first pair. The optional fill argument is the color of the inside of the polygon, and the optional outline argument is the color of the polygon\u2019s outline.\n\nEnter the following into the interactive shell:\n\n>>> from PIL import Image, ImageDraw >>> im = Image.new('RGBA', (200, 200), 'white') >>> draw = ImageDraw.Draw(im) \u278a >>> draw.line([(0, 0), (199, 0), (199, 199), (0, 199), (0, 0)], fill='black') \u278b >>> draw.rectangle((20, 30, 60, 60), fill='blue') \u278c >>> draw.ellipse((120, 30, 160, 60), fill='red') \u278d >>> draw.polygon(((57, 87), (79, 62), (94, 85), (120, 90), (103, 113)), fill='brown') \u278e >>> for i in range(100, 200, 10): draw.line([(i, 0), (200, i - 100)], fill='green') >>> im.save('drawing.png')\n\nAfter making an Image object for a 200\u00d7200 white image, passing it to ImageDraw.Draw() to get an ImageDraw object, and storing the ImageDraw object in draw , you can call drawing methods on draw . Here we make a thin, black outline at the edges of the image \u278a , a blue rectangle with its top-left corner at (20, 30) and bottom-right corner at (60, 60) \u278b , a red ellipse defined by a box from (120, 30) to (160, 60) \u278c , a brown polygon with five points \u278d , and a pattern of green lines drawn with a for loop \u278e . The resulting drawing.png file will look like Figure 19-14.\n\nFigure 19-14: The resulting drawing.png image\n\nThere are several other shape-drawing methods for ImageDraw objects. The full documentation is available at https://pillow.readthedocs.io/en/latest/reference/ImageDraw.html .\n\nThe ImageDraw object also has a text() method for drawing text onto an image. The text() method takes four arguments: xy , text , fill , and font .\n\n* The xy argument is a two-integer tuple specifying the upper-left corner of the text box.\n* The text argument is the string of text you want to write.\n* The optional fill argument is the color of the text.\n* The optional font argument is an ImageFont object, used to set the typeface and size of the text. This is described in more detail in the next section.\n\nSince it\u2019s often hard to know in advance what size a block of text will be in a given font, the ImageDraw module also offers a textsize() method. Its first argument is the string of text you want to measure, and its second argument is an optional ImageFont object. The textsize() method will then return a two-integer tuple of the width and height that the text in the given font would be if it were written onto the image. You can use this width and height to help you calculate exactly where you want to put the text on your image.\n\nThe first three arguments for text() are straightforward. Before we use text() to draw text onto an image, let\u2019s look at the optional fourth argument, the ImageFont object.\n\nBoth text() and textsize() take an optional ImageFont object as their final arguments. To create one of these objects, first run the following:\n\n>>> from PIL import ImageFont\n\nNow that you\u2019ve imported Pillow\u2019s ImageFont module, you can call the ImageFont.truetype() function, which takes two arguments. The first argument is a string for the font\u2019s TrueType file \u2014this is the actual font file that lives on your hard drive. A TrueType file has the .ttf file extension and can usually be found in the following folders:\n\n* On Windows: C:\\Windows\\Fonts\n* On macOS: /Library/Fonts and /System/Library/Fonts\n* On Linux: /usr/share/fonts/truetype\n\nYou don\u2019t actually need to enter these paths as part of the TrueType file string because Python knows to automatically search for fonts in these directories. But Python will display an error if it is unable to find the font you specified.\n\nThe second argument to ImageFont.truetype() is an integer for the font size in points (rather than, say, pixels). Keep in mind that Pillow creates PNG images that are 72 pixels per inch by default, and a point is 1/72 of an inch.\n\nEnter the following into the interactive shell, replacing FONT_FOLDER with the actual folder name your operating system uses:\n\n>>> from PIL import Image, ImageDraw, ImageFont >>> import os \u278a >>> im = Image.new('RGBA', (200, 200), 'white') \u278b >>> draw = ImageDraw.Draw(im) \u278c >>> draw.text((20, 150), 'Hello', fill='purple') >>> fontsFolder = 'FONT_FOLDER' # e.g. \u2018/Library/Fonts' \u278d >>> arialFont = ImageFont.truetype(os.path.join(fontsFolder, 'arial.ttf'), 32) \u278e >>> draw.text((100, 150), 'Howdy', fill='gray', font=arialFont) >>> im.save('text.png')\n\nAfter importing Image , ImageDraw , ImageFont , and os , we make an Image object for a new 200\u00d7200 white image \u278a and make an ImageDraw object from the Image object \u278b . We use text() to draw Hello at (20, 150) in purple \u278c . We didn\u2019t pass the optional fourth argument in this text() call, so the typeface and size of this text aren\u2019t customized.\n\nTo set a typeface and size, we first store the folder name (like /Library/Fonts ) in fontsFolder . Then we call ImageFont.truetype() , passing it the .ttf file for the font we want, followed by an integer font size \u278d . Store the Font object you get from ImageFont.truetype() in a variable like arialFont , and then pass the variable to text() in the final keyword argument. The text() call at \u278e draws Howdy at (100, 150) in gray in 32-point Arial.\n\nThe resulting text.png file will look like Figure 19-15.\n\nFigure 19-15: The resulting text.png image", "source": "https://automatetheboringstuff.com/2e/chapter19/", "category": "19MANIPULATING IMAGES"}
{"instruction": "What is '2FLOW CONTROL' and how does it work in Python?", "input": "", "output": "So, you know the basics of individual instructions and that a program is just a series of instructions. But programming\u2019s real strength isn\u2019t just running one instruction after another like a weekend errand list. Based on how expressions evaluate, a program can decide to skip instructions, repeat them, or choose one of several instructions to run. In fact, you almost never want your programs to start from the first line of code and simply execute every line, straight to the end. Flow control statements can decide which Python instructions to execute under which conditions.\n\nThese flow control statements directly correspond to the symbols in a flowchart, so I\u2019ll provide flowchart versions of the code discussed in this chapter. Figure 2-1 shows a flowchart for what to do if it\u2019s raining. Follow the path made by the arrows from Start to End.\n\nFigure 2-1: A flowchart to tell you what to do if it is raining\n\nIn a flowchart, there is usually more than one way to go from the start to the end. The same is true for lines of code in a computer program. Flowcharts represent these branching points with diamonds, while the other steps are represented with rectangles. The starting and ending steps are represented with rounded rectangles.\n\nBut before you learn about flow control statements, you first need to learn how to represent those yes and no options, and you need to understand how to write those branching points as Python code. To that end, let\u2019s explore Boolean values, comparison operators, and Boolean operators.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "What is 'Boolean Values' and how does it work in Python?", "input": "", "output": "While the integer, floating-point, and string data types have an unlimited number of possible values, the Boolean data type has only two values: True and False . (Boolean is capitalized because the data type is named after mathematician George Boole.) When entered as Python code, the Boolean values True and False lack the quotes you place around strings, and they always start with a capital T or F , with the rest of the word in lowercase. Enter the following into the interactive shell. (Some of these instructions are intentionally incorrect, and they\u2019ll cause error messages to appear.)\n\n\u278a >>> spam = True >>> spam True \u278b >>> true Traceback (most recent call last): File \"<pyshell#2>\", line 1, in <module> true NameError: name 'true' is not defined \u278c >>> True = 2 + 2 SyntaxError: can't assign to keyword\n\nLike any other value, Boolean values are used in expressions and can be stored in variables \u278a . If you don\u2019t use the proper case \u278b or you try to use True and False for variable names \u278c , Python will give you an error message.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "Provide a guide on 'Comparison Operators' in Python.", "input": "", "output": "Comparison operators , also called relational operators , compare two values and evaluate down to a single Boolean value. Table 2-1 lists the comparison operators.\n\nTable 2-1: Comparison Operators\n\nThese operators evaluate to True or False depending on the values you give them. Let\u2019s try some operators now, starting with == and != .\n\n>>> 42 == 42 True >>> 42 == 99 False >>> 2 != 3 True >>> 2 != 2 False\n\nAs you might expect, == (equal to) evaluates to True when the values on both sides are the same, and != (not equal to) evaluates to True when the two values are different. The == and != operators can actually work with values of any data type.\n\n>>> 'hello' == 'hello' True >>> 'hello' == 'Hello' False >>> 'dog' != 'cat' True >>> True == True True >>> True != False True >>> 42 == 42.0 True \u278a >>> 42 == '42' False\n\nNote that an integer or floating-point value will always be unequal to a string value. The expression 42 == '42' \u278a evaluates to False because Python considers the integer 42 to be different from the string '42' .\n\nThe < , > , <= , and >= operators, on the other hand, work properly only with integer and floating-point values.\n\n>>> 42 < 100 True >>> 42 > 100 False >>> 42 < 42 False >>> eggCount = 42 \u278a >>> eggCount <= 42 True >>> myAge = 29 \u278b >>> myAge >= 10 True\n\nYou\u2019ll often use comparison operators to compare a variable\u2019s value to some other value, like in the eggCount <= 42 \u278a and myAge >= 10 \u278b examples. (After all, instead of entering 'dog' != 'cat' in your code, you could have just entered True .) You\u2019ll see more examples of this later when you learn about flow control statements.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "How do I use 'Boolean Operators' in Python?", "input": "", "output": "The three Boolean operators ( and , or , and not ) are used to compare Boolean values. Like comparison operators, they evaluate these expressions down to a Boolean value. Let\u2019s explore these operators in detail, starting with the and operator.\n\nThe and and or operators always take two Boolean values (or expressions), so they\u2019re considered binary operators. The and operator evaluates an expression to True if both Boolean values are True ; otherwise, it evaluates to False . Enter some expressions using and into the interactive shell to see it in action.\n\n>>> True and True True >>> True and False False\n\nA truth table shows every possible result of a Boolean operator. Table 2-2 is the truth table for the and operator.\n\nTable 2-2: The and Operator\u2019s Truth Table\n\nOn the other hand, the or operator evaluates an expression to True if either of the two Boolean values is True . If both are False , it evaluates to False .\n\n>>> False or True True >>> False or False False\n\nYou can see every possible outcome of the or operator in its truth table, shown in Table 2-3.\n\nTable 2-3: The or Operator\u2019s Truth Table\n\nUnlike and and or , the not operator operates on only one Boolean value (or expression). This makes it a unary operator. The not operator simply evaluates to the opposite Boolean value.\n\n>>> not True False \u278a >>> not not not not True True\n\nMuch like using double negatives in speech and writing, you can nest not operators \u278a , though there\u2019s never not no reason to do this in real programs. Table 2-4 shows the truth table for not .\n\nTable 2-4: The not Operator\u2019s Truth Table", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "How do I use 'Mixing Boolean and Comparison Operators' in Python?", "input": "", "output": "Since the comparison operators evaluate to Boolean values, you can use them in expressions with the Boolean operators.\n\nRecall that the and , or , and not operators are called Boolean operators because they always operate on the Boolean values True and False . While expressions like 4 < 5 aren\u2019t Boolean values, they are expressions that evaluate down to Boolean values. Try entering some Boolean expressions that use comparison operators into the interactive shell.\n\n>>> ( 4 < 5) and (5 < 6) True >>> ( 4 < 5) and (9 < 6) False >>> ( 1 == 2) or (2 == 2) True\n\nThe computer will evaluate the left expression first, and then it will evaluate the right expression. When it knows the Boolean value for each, it will then evaluate the whole expression down to one Boolean value. You can think of the computer\u2019s evaluation process for (4 < 5) and (5 < 6) as the following:\n\nYou can also use multiple Boolean operators in an expression, along with the comparison operators:\n\n>>> 2 + 2 == 4 and not 2 + 2 == 5 and 2 * 2 == 2 + 2 True\n\nThe Boolean operators have an order of operations just like the math operators do. After any math and comparison operators evaluate, Python evaluates the not operators first, then the and operators, and then the or operators.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "Explain the concept of 'Elements of Flow Control' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Flow control statements often start with a part called the condition and are always followed by a block of code called the clause . Before you learn about Python\u2019s specific flow control statements, I\u2019ll cover what a condition and a block are.\n\nThe Boolean expressions you\u2019ve seen so far could all be considered conditions, which are the same thing as expressions; condition is just a more specific name in the context of flow control statements. Conditions always evaluate down to a Boolean value, True or False . A flow control statement decides what to do based on whether its condition is True or False , and almost every flow control statement uses a condition.\n\nLines of Python code can be grouped together in blocks . You can tell when a block begins and ends from the indentation of the lines of code. There are three rules for blocks.\n\n* Blocks begin when the indentation increases.\n* Blocks can contain other blocks.\n* Blocks end when the indentation decreases to zero or to a containing block\u2019s indentation.\n\nBlocks are easier to understand by looking at some indented code, so let\u2019s find the blocks in part of a small game program, shown here:\n\nname = 'Mary' password = 'swordfish' if name == 'Mary': \u278a print('Hello, Mary') if password == 'swordfish': \u278b print('Access granted.') else: \u278c print('Wrong password.')\n\nYou can view the execution of this program at https://autbor.com/blocks/ . The first block of code \u278a starts at the line print('Hello, Mary') and contains all the lines after it. Inside this block is another block \u278b , which has only a single line in it: print('Access Granted.') . The third block \u278c is also one line long: print('Wrong password.') .", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "How do I use 'Program Execution' in Python?", "input": "", "output": "In the previous chapter\u2019s hello.py program, Python started executing instructions at the top of the program going down, one after another. The program execution (or simply, execution ) is a term for the current instruction being executed. If you print the source code on paper and put your finger on each line as it is executed, you can think of your finger as the program execution.\n\nNot all programs execute by simply going straight down, however. If you use your finger to trace through a program with flow control statements, you\u2019ll likely find yourself jumping around the source code based on conditions, and you\u2019ll probably skip entire clauses.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "What is 'Flow Control Statements' and how does it work in Python?", "input": "", "output": "Now, let\u2019s explore the most important piece of flow control: the statements themselves. The statements represent the diamonds you saw in the flowchart in Figure 2-1, and they are the actual decisions your programs will make.\n\nThe most common type of flow control statement is the if statement. An if statement\u2019s clause (that is, the block following the if statement) will execute if the statement\u2019s condition is True . The clause is skipped if the condition is False .\n\nIn plain English, an if statement could be read as, \u201cIf this condition is true, execute the code in the clause.\u201d In Python, an if statement consists of the following:\n\n* The if keyword\n* A condition (that is, an expression that evaluates to True or False )\n* A colon\n* Starting on the next line, an indented block of code (called the if clause)\n\nFor example, let\u2019s say you have some code that checks to see whether someone\u2019s name is Alice. (Pretend name was assigned some value earlier.)\n\nif name == 'Alice': print('Hi, Alice.')\n\nAll flow control statements end with a colon and are followed by a new block of code (the clause). This if statement\u2019s clause is the block with print('Hi, Alice.') . Figure 2-2 shows what a flowchart of this code would look like.\n\nFigure 2-2: The flowchart for an if statement\n\nAn if clause can optionally be followed by an else statement. The else clause is executed only when the if statement\u2019s condition is False . In plain English, an else statement could be read as, \u201cIf this condition is true, execute this code. Or else, execute that code.\u201d An else statement doesn\u2019t have a condition, and in code, an else statement always consists of the following:\n\n* The else keyword\n* A colon\n* Starting on the next line, an indented block of code (called the else clause)\n\nReturning to the Alice example, let\u2019s look at some code that uses an else statement to offer a different greeting if the person\u2019s name isn\u2019t Alice.\n\nif name == 'Alice': print('Hi, Alice.') else: print('Hello, stranger.')\n\nFigure 2-3 shows what a flowchart of this code would look like.\n\nFigure 2-3: The flowchart for an else statement\n\nWhile only one of the if or else clauses will execute, you may have a case where you want one of many possible clauses to execute. The elif statement is an \u201celse if\u201d statement that always follows an if or another elif statement. It provides another condition that is checked only if all of the previous conditions were False . In code, an elif statement always consists of the following:\n\n* The elif keyword\n* A condition (that is, an expression that evaluates to True or False )\n* A colon\n* Starting on the next line, an indented block of code (called the elif clause)\n\nLet\u2019s add an elif to the name checker to see this statement in action.\n\nif name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.')\n\nThis time, you check the person\u2019s age, and the program will tell them something different if they\u2019re younger than 12. You can see the flowchart for this in Figure 2-4.\n\nFigure 2-4: The flowchart for an elif statement\n\nThe elif clause executes if age < 12 is True and name == 'Alice' is False . However, if both of the conditions are False , then both of the clauses are skipped. It is not guaranteed that at least one of the clauses will be executed. When there is a chain of elif statements, only one or none of the clauses will be executed. Once one of the statements\u2019 conditions is found to be True , the rest of the elif clauses are automatically skipped. For example, open a new file editor window and enter the following code, saving it as vampire.py :\n\nname = 'Carol' age = 3000 if name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.') elif age > 2000: print('Unlike you, Alice is not an undead, immortal vampire.') elif age > 100: print('You are not Alice, grannie.')\n\nYou can view the execution of this program at https://autbor.com/vampire/ . Here, I\u2019ve added two more elif statements to make the name checker greet a person with different answers based on age . Figure 2-5 shows the flowchart for this.\n\nFigure 2-5: The flowchart for multiple elif statements in the vampire.py program\n\nThe order of the elif statements does matter, however. Let\u2019s rearrange them to introduce a bug. Remember that the rest of the elif clauses are automatically skipped once a True condition has been found, so if you swap around some of the clauses in vampire.py , you run into a problem. Change the code to look like the following, and save it as vampire2.py :\n\nname = 'Carol' age = 3000 if name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.') \u278a elif age > 100: print('You are not Alice, grannie.') elif age > 2000: print('Unlike you, Alice is not an undead, immortal vampire.')\n\nYou can view the execution of this program at https://autbor.com/vampire2/ . Say the age variable contains the value 3000 before this code is executed. You might expect the code to print the string 'Unlike you, Alice is not an undead, immortal vampire.' . However, because the age > 100 condition is True (after all, 3,000 is greater than 100) \u278a , the string 'You are not Alice, grannie.' is printed, and the rest of the elif statements are automatically skipped. Remember that at most only one of the clauses will be executed, and for elif statements, the order matters!\n\nFigure 2-6 shows the flowchart for the previous code. Notice how the diamonds for age > 100 and age > 2000 are swapped.\n\nOptionally, you can have an else statement after the last elif statement. In that case, it is guaranteed that at least one (and only one) of the clauses will be executed. If the conditions in every if and elif statement are False , then the else clause is executed. For example, let\u2019s re-create the Alice program to use if , elif , and else clauses.\n\nname = 'Carol' age = 3000 if name == 'Alice': print('Hi, Alice.') elif age < 12: print('You are not Alice, kiddo.') else: print('You are neither Alice nor a little kid.')\n\nYou can view the execution of this program at https://autbor.com/littlekid/ . Figure 2-7 shows the flowchart for this new code, which we\u2019ll save as littleKid.py .\n\nIn plain English, this type of flow control structure would be \u201cIf the first condition is true, do this. Else, if the second condition is true, do that. Otherwise, do something else.\u201d When you use if , elif , and else statements together, remember these rules about how to order them to avoid bugs like the one in Figure 2-6. First, there is always exactly one if statement. Any elif statements you need should follow the if statement. Second, if you want to be sure that at least one clause is executed, close the structure with an else statement.\n\nFigure 2-6: The flowchart for the vampire2.py program. The X path will logically never happen, because if age were greater than 2000 , it would have already been greater than 100 .\n\nFigure 2-7: Flowchart for the previous littleKid.py program\n\nYou can make a block of code execute over and over again using a while statement. The code in a while clause will be executed as long as the while statement\u2019s condition is True . In code, a while statement always consists of the following:\n\n* The while keyword\n* A condition (that is, an expression that evaluates to True or False )\n* A colon\n* Starting on the next line, an indented block of code (called the while clause)\n\nYou can see that a while statement looks similar to an if statement. The difference is in how they behave. At the end of an if clause, the program execution continues after the if statement. But at the end of a while clause, the program execution jumps back to the start of the while statement. The while clause is often called the while loop or just the loop .\n\nLet\u2019s look at an if statement and a while loop that use the same condition and take the same actions based on that condition. Here is the code with an if statement:\n\nspam = 0 if spam < 5: print('Hello, world.') spam = spam + 1\n\nHere is the code with a while statement:\n\nspam = 0 while spam < 5: print('Hello, world.') spam = spam + 1\n\nThese statements are similar\u2014both if and while check the value of spam , and if it\u2019s less than 5, they print a message. But when you run these two code snippets, something very different happens for each one. For the if statement, the output is simply \"Hello, world.\" . But for the while statement, it\u2019s \"Hello, world.\" repeated five times! Take a look at the flowcharts for these two pieces of code, Figures 2-8 and 2-9, to see why this happens.\n\nFigure 2-8: The flowchart for the if statement code\n\nFigure 2-9: The flowchart for the while statement code\n\nThe code with the if statement checks the condition, and it prints Hello, world. only once if that condition is true. The code with the while loop, on the other hand, will print it five times. The loop stops after five prints because the integer in spam increases by one at the end of each loop iteration, which means that the loop will execute five times before spam < 5 is False .\n\nIn the while loop, the condition is always checked at the start of each iteration (that is, each time the loop is executed). If the condition is True , then the clause is executed, and afterward, the condition is checked again. The first time the condition is found to be False , the while clause is skipped.\n\nHere\u2019s a small example program that will keep asking you to type, literally, your name . Select File \u25b8 New to open a new file editor window, enter the following code, and save the file as yourName.py :\n\n\u278a name = '' \u278b while name != 'your name': print('Please type your name.') \u278c name = input() \u278d print('Thank you!')\n\nYou can view the execution of this program at https://autbor.com/yourname/ . First, the program sets the name variable \u278a to an empty string. This is so that the name != 'your name' condition will evaluate to True and the program execution will enter the while loop\u2019s clause \u278b .\n\nThe code inside this clause asks the user to type their name, which is assigned to the name variable \u278c . Since this is the last line of the block, the execution moves back to the start of the while loop and reevaluates the condition. If the value in name is not equal to the string 'your name' , then the condition is True , and the execution enters the while clause again.\n\nBut once the user types your name , the condition of the while loop will be 'your name' != 'your name' , which evaluates to False . The condition is now False , and instead of the program execution reentering the while loop\u2019s clause, Python skips past it and continues running the rest of the program \u278d . Figure 2-10 shows a flowchart for the yourName.py program.\n\nFigure 2-10: A flowchart of the yourName.py program\n\nNow, let\u2019s see yourName.py in action. Press F5 to run it, and enter something other than your name a few times before you give the program what it wants.\n\nPlease type your name. Al Please type your name. Albert Please type your name. %#@#%*(^&!!! Please type your name. your name Thank you!\n\nIf you never enter your name , then the while loop\u2019s condition will never be False , and the program will just keep asking forever. Here, the input() call lets the user enter the right string to make the program move on. In other programs, the condition might never actually change, and that can be a problem. Let\u2019s look at how you can break out of a while loop.\n\nThere is a shortcut to getting the program execution to break out of a while loop\u2019s clause early. If the execution reaches a break statement, it immediately exits the while loop\u2019s clause. In code, a break statement simply contains the break keyword.\n\nPretty simple, right? Here\u2019s a program that does the same thing as the previous program, but it uses a break statement to escape the loop. Enter the following code, and save the file as yourName2.py :\n\n\u278a while True: print('Please type your name.') \u278b name = input() \u278c if name == 'your name': \u278d break \u278e print('Thank you!')\n\nYou can view the execution of this program at https://autbor.com/yourname2/ . The first line \u278a creates an infinite loop ; it is a while loop whose condition is always True . (The expression True , after all, always evaluates down to the value True .) After the program execution enters this loop, it will exit the loop only when a break statement is executed. (An infinite loop that never exits is a common programming bug.)\n\nJust like before, this program asks the user to enter your name \u278b . Now, however, while the execution is still inside the while loop, an if statement checks \u278c whether name is equal to 'your name' . If this condition is True , the break statement is run \u278d , and the execution moves out of the loop to print('Thank you!') \u278e . Otherwise, the if statement\u2019s clause that contains the break statement is skipped, which puts the execution at the end of the while loop. At this point, the program execution jumps back to the start of the while statement \u278a to recheck the condition. Since this condition is merely the True Boolean value, the execution enters the loop to ask the user to type your name again. See Figure 2-11 for this program\u2019s flowchart.\n\nRun yourName2.py , and enter the same text you entered for yourName.py . The rewritten program should respond in the same way as the original.\n\nFigure 2-11: The flowchart for the yourName2.py program with an infinite loop. Note that the X path will logically never happen, because the loop condition is always True .\n\nLike break statements, continue statements are used inside loops. When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop and reevaluates the loop\u2019s condition. (This is also what happens when the execution reaches the end of the loop.)\n\nLet\u2019s use continue to write a program that asks for a name and password. Enter the following code into a new file editor window and save the program as swordfish.py .\n\nwhile True: print('Who are you?') name = input() \u278a if name != 'Joe': \u278b continue print('Hello, Joe. What is the password? (It is a fish.)') \u278c password = input() if password == 'swordfish': \u278d break \u278e print('Access granted.')\n\nIf the user enters any name besides Joe \u278a , the continue statement \u278b causes the program execution to jump back to the start of the loop. When the program reevaluates the condition, the execution will always enter the loop, since the condition is simply the value True . Once the user makes it past that if statement, they are asked for a password \u278c . If the password entered is swordfish , then the break statement \u278d is run, and the execution jumps out of the while loop to print Access granted \u278e . Otherwise, the execution continues to the end of the while loop, where it then jumps back to the start of the loop. See Figure 2-12 for this program\u2019s flowchart.\n\nFigure 2-12: A flowchart for swordfish.py. The X path will logically never happen, because the loop condition is always True .\n\nRun this program and give it some input. Until you claim to be Joe, the program shouldn\u2019t ask for a password, and once you enter the correct password, it should exit.\n\nWho are you? I'm fine, thanks. Who are you? Who are you? Joe Hello, Joe. What is the password? (It is a fish.) Mary Who are you? Joe Hello, Joe. What is the password? (It is a fish.) swordfish Access granted.\n\nYou can view the execution of this program at https://autbor.com/hellojoe/ .\n\nThe while loop keeps looping while its condition is True (which is the reason for its name), but what if you want to execute a block of code only a certain number of times? You can do this with a for loop statement and the range() function.\n\nIn code, a for statement looks something like for i in range(5): and includes the following:\n\n* The for keyword\n* A variable name\n* The in keyword\n* A call to the range() method with up to three integers passed to it\n* A colon\n* Starting on the next line, an indented block of code (called the for clause)\n\nLet\u2019s create a new program called fiveTimes.py to help you see a for loop in action.\n\nprint('My name is') for i in range(5): print('Jimmy Five Times (' + str(i) + ')')\n\nYou can view the execution of this program at https://autbor.com/fivetimesfor/ . The code in the for loop\u2019s clause is run five times. The first time it is run, the variable i is set to 0 . The print() call in the clause will print Jimmy Five Times (0) . After Python finishes an iteration through all the code inside the for loop\u2019s clause, the execution goes back to the top of the loop, and the for statement increments i by one. This is why range(5) results in five iterations through the clause, with i being set to 0 , then 1 , then 2 , then 3 , and then 4 . The variable i will go up to, but will not include, the integer passed to range() . Figure 2-13 shows a flowchart for the fiveTimes.py program.\n\nWhen you run this program, it should print Jimmy Five Times followed by the value of i five times before leaving the for loop.\n\nMy name is Jimmy Five Times (0) Jimmy Five Times (1) Jimmy Five Times (2) Jimmy Five Times (3) Jimmy Five Times (4)\n\nFigure 2-13: The flowchart for fiveTimes.py\n\nAs another for loop example, consider this story about the mathematician Carl Friedrich Gauss. When Gauss was a boy, a teacher wanted to give the class some busywork. The teacher told them to add up all the numbers from 0 to 100. Young Gauss came up with a clever trick to figure out the answer in a few seconds, but you can write a Python program with a for loop to do this calculation for you.\n\n\u278a total = 0 \u278b for num in range(101): \u278c total = total + num \u278d print(total)\n\nThe result should be 5,050. When the program first starts, the total variable is set to 0 \u278a . The for loop \u278b then executes total = total + num \u278c 100 times. By the time the loop has finished all of its 100 iterations, every integer from 0 to 100 will have been added to total . At this point, total is printed to the screen \u278d . Even on the slowest computers, this program takes less than a second to complete.\n\n(Young Gauss figured out a way to solve the problem in seconds. There are 50 pairs of numbers that add up to 101: 1 + 100, 2 + 99, 3 + 98, and so on, until 50 + 51. Since 50 \u00d7 101 is 5,050, the sum of all the numbers from 0 to 100 is 5,050. Clever kid!)\n\nYou can actually use a while loop to do the same thing as a for loop; for loops are just more concise. Let\u2019s rewrite fiveTimes.py to use a while loop equivalent of a for loop.\n\nprint('My name is') i = 0 while i < 5: print('Jimmy Five Times (' + str(i) + ')') i = i + 1\n\nYou can view the execution of this program at https://autbor.com/fivetimeswhile/ . If you run this program, the output should look the same as the fiveTimes.py program, which uses a for loop.\n\nSome functions can be called with multiple arguments separated by a comma, and range() is one of them. This lets you change the integer passed to range() to follow any sequence of integers, including starting at a number other than zero.\n\nfor i in range(12, 16): print(i)\n\nThe first argument will be where the for loop\u2019s variable starts, and the second argument will be up to, but not including, the number to stop at.\n\n12 13 14 15\n\nThe range() function can also be called with three arguments. The first two arguments will be the start and stop values, and the third will be the step argument . The step is the amount that the variable is increased by after each iteration.\n\nfor i in range(0, 10, 2): print(i)\n\nSo calling range(0, 10, 2) will count from zero to eight by intervals of two.\n\n0 2 4 6 8\n\nThe range() function is flexible in the sequence of numbers it produces for for loops. For example (I never apologize for my puns), you can even use a negative number for the step argument to make the for loop count down instead of up.\n\nfor i in range(5, -1, -1): print(i)\n\nThis for loop would have the following output:\n\n5 4 3 2 1 0\n\nRunning a for loop to print i with range(5, -1, -1) should print from five down to zero.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "Explain the concept of 'Importing Modules' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "All Python programs can call a basic set of functions called built-in functions , including the print() , input() , and len() functions you\u2019ve seen before. Python also comes with a set of modules called the standard library . Each module is a Python program that contains a related group of functions that can be embedded in your programs. For example, the math module has mathematics-related functions, the random module has random number-related functions, and so on.\n\nBefore you can use the functions in a module, you must import the module with an import statement. In code, an import statement consists of the following:\n\n* The import keyword\n* The name of the module\n* Optionally, more module names, as long as they are separated by commas\n\nOnce you import a module, you can use all the cool functions of that module. Let\u2019s give it a try with the random module, which will give us access to the random.randint() function.\n\nEnter this code into the file editor, and save it as printRandom.py :\n\nimport random for i in range(5): print(random.randint(1, 10))\n\nWhen you run this program, the output will look something like this:\n\n4 1 8 4 1\n\nYou can view the execution of this program at https://autbor.com/printrandom/ . The random.randint() function call evaluates to a random integer value between the two integers that you pass it. Since randint() is in the random module, you must first type random. in front of the function name to tell Python to look for this function inside the random module.\n\nHere\u2019s an example of an import statement that imports four different modules:\n\nimport random, sys, os, math\n\nNow we can use any of the functions in these four modules. We\u2019ll learn more about them later in the book.\n\nAn alternative form of the import statement is composed of the from keyword, followed by the module name, the import keyword, and a star; for example, from random import * .\n\nWith this form of import statement, calls to functions in random will not need the random. prefix. However, using the full name makes for more readable code, so it is better to use the import random form of the statement.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "How do I use 'Ending a Program Early with the sys.exit() Function' in Python?", "input": "", "output": "The last flow control concept to cover is how to terminate the program. Programs always terminate if the program execution reaches the bottom of the instructions. However, you can cause the program to terminate, or exit, before the last instruction by calling the sys.exit() function. Since this function is in the sys module, you have to import sys before your program can use it.\n\nOpen a file editor window and enter the following code, saving it as exitExample.py :\n\nimport sys while True: print('Type exit to exit.') response = input() if response == 'exit': sys.exit() print('You typed ' + response + '.')\n\nRun this program in IDLE. This program has an infinite loop with no break statement inside. The only way this program will end is if the execution reaches the sys.exit() call. When response is equal to exit , the line containing the sys.exit() call is executed. Since the response variable is set by the input() function, the user must enter exit in order to stop the program.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "Explain the concept of 'A Short Program: Guess the Number' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "The examples I\u2019ve shown you so far are useful for introducing basic concepts, but now let\u2019s see how everything you\u2019ve learned comes together in a more complete program. In this section, I\u2019ll show you a simple \u201cguess the number\u201d game. When you run this program, the output will look something like this:\n\nI am thinking of a number between 1 and 20. Take a guess. 10 Your guess is too low. Take a guess. 15 Your guess is too low. Take a guess. 17 Your guess is too high. Take a guess. 16 Good job! You guessed my number in 4 guesses!\n\nEnter the following source code into the file editor, and save the file as guessTheNumber.py :\n\n# This is a guess the number game. import random secretNumber = random.randint(1, 20) print('I am thinking of a number between 1 and 20.') # Ask the player to guess 6 times. for guessesTaken in range(1, 7): print('Take a guess.') guess = int(input()) if guess < secretNumber: print('Your guess is too low.') elif guess > secretNumber: print('Your guess is too high.') else: break\u00a0\u00a0\u00a0\u00a0# This condition is the correct guess! if guess == secretNumber: print('Good job! You guessed my number in ' + str(guessesTaken) + ' guesses!') else: print('Nope. The number I was thinking of was ' + str(secretNumber))\n\nYou can view the execution of this program at https://autbor.com/guessthenumber/ . Let\u2019s look at this code line by line, starting at the top.\n\n# This is a guess the number game. import random secretNumber = random.randint(1, 20)\n\nFirst, a comment at the top of the code explains what the program does. Then, the program imports the random module so that it can use the random.randint() function to generate a number for the user to guess. The return value, a random integer between 1 and 20, is stored in the variable secretNumber .\n\nprint('I am thinking of a number between 1 and 20.') # Ask the player to guess 6 times. for guessesTaken in range(1, 7): print('Take a guess.') guess = int(input())\n\nThe program tells the player that it has come up with a secret number and will give the player six chances to guess it. The code that lets the player enter a guess and checks that guess is in a for loop that will loop at most six times. The first thing that happens in the loop is that the player types in a guess. Since input() returns a string, its return value is passed straight into int() , which translates the string into an integer value. This gets stored in a variable named guess .\n\nif guess < secretNumber: print('Your guess is too low.') elif guess > secretNumber: print('Your guess is too high.')\n\nThese few lines of code check to see whether the guess is less than or greater than the secret number. In either case, a hint is printed to the screen.\n\nelse: break\u00a0\u00a0\u00a0\u00a0# This condition is the correct guess!\n\nIf the guess is neither higher nor lower than the secret number, then it must be equal to the secret number\u2014in which case, you want the program execution to break out of the for loop.\n\nif guess == secretNumber: print('Good job! You guessed my number in ' + str(guessesTaken) + ' guesses!') else: print('Nope. The number I was thinking of was ' + str(secretNumber))\n\nAfter the for loop, the previous if...else statement checks whether the player has correctly guessed the number and then prints an appropriate message to the screen. In both cases, the program displays a variable that contains an integer value ( guessesTaken and secretNumber ). Since it must concatenate these integer values to strings, it passes these variables to the str() function, which returns the string value form of these integers. Now these strings can be concatenated with the + operators before finally being passed to the print() function call.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "How do I use 'A Short Program: Rock, Paper, Scissors' in Python?", "input": "", "output": "Let\u2019s use the programming concepts we\u2019ve learned so far to create a simple rock, paper, scissors game. The output will look like this:\n\nROCK, PAPER, SCISSORS 0 Wins, 0 Losses, 0 Ties Enter your move: (r)ock (p)aper (s)cissors or (q)uit p PAPER versus... PAPER It is a tie! 0 Wins, 1 Losses, 1 Ties Enter your move: (r)ock (p)aper (s)cissors or (q)uit s SCISSORS versus... PAPER You win! 1 Wins, 1 Losses, 1 Ties Enter your move: (r)ock (p)aper (s)cissors or (q)uit q\n\nType the following source code into the file editor, and save the file as rpsGame.py :\n\nimport random, sys print('ROCK, PAPER, SCISSORS') # These variables keep track of the number of wins, losses, and ties. wins = 0 losses = 0 ties = 0 while True: # The main game loop. print('%s Wins, %s Losses, %s Ties' % (wins, losses, ties)) while True: # The player input loop. print('Enter your move: (r)ock (p)aper (s)cissors or (q)uit') playerMove = input() if playerMove == 'q': sys.exit() # Quit the program. if playerMove == 'r' or playerMove == 'p' or playerMove == 's': break # Break out of the player input loop. print('Type one of r, p, s, or q.') # Display what the player chose: if playerMove == 'r': print('ROCK versus...') elif playerMove == 'p': print('PAPER versus...') elif playerMove == 's': print('SCISSORS versus...') # Display what the computer chose: randomNumber = random.randint(1, 3) if randomNumber == 1: computerMove = 'r' print('ROCK') elif randomNumber == 2: computerMove = 'p' print('PAPER') elif randomNumber == 3: computerMove = 's' print('SCISSORS') # Display and record the win/loss/tie: if playerMove == computerMove: print('It is a tie!') ties = ties + 1 elif playerMove == 'r' and computerMove == 's': print('You win!') wins = wins + 1 elif playerMove == 'p' and computerMove == 'r': print('You win!') wins = wins + 1 elif playerMove == 's' and computerMove == 'p': print('You win!') wins = wins + 1 elif playerMove == 'r' and computerMove == 'p': print('You lose!') losses = losses + 1 elif playerMove == 'p' and computerMove == 's': print('You lose!') losses = losses + 1 elif playerMove == 's' and computerMove == 'r': print('You lose!') losses = losses + 1\n\nLet\u2019s look at this code line by line, starting at the top.\n\nimport random, sys print('ROCK, PAPER, SCISSORS') # These variables keep track of the number of wins, losses, and ties. wins = 0 losses = 0 ties = 0\n\nFirst, we import the random and sys module so that our program can call the random.randint() and sys.exit() functions. We also set up three variables to keep track of how many wins, losses, and ties the player has had.\n\nwhile True: # The main game loop. print('%s Wins, %s Losses, %s Ties' % (wins, losses, ties)) while True: # The player input loop. print('Enter your move: (r)ock (p)aper (s)cissors or (q)uit') playerMove = input() if playerMove == 'q': sys.exit() # Quit the program. if playerMove == 'r' or playerMove == 'p' or playerMove == 's': break # Break out of the player input loop. print('Type one of r, p, s, or q.')\n\nThis program uses a while loop inside of another while loop. The first loop is the main game loop, and a single game of rock, paper, scissors is played on each iteration through this loop. The second loop asks for input from the player, and keeps looping until the player has entered an r , p , s , or q for their move. The r , p , and s correspond to rock, paper, and scissors, respectively, while the q means the player intends to quit. In that case, sys.exit() is called and the program exits. If the player has entered r , p , or s , the execution breaks out of the loop. Otherwise, the program reminds the player to enter r , p , s , or q and goes back to the start of the loop.\n\n# Display what the player chose: if playerMove == 'r': print('ROCK versus...') elif playerMove == 'p': print('PAPER versus...') elif playerMove == 's': print('SCISSORS versus...')\n\nThe player\u2019s move is displayed on the screen.\n\n# Display what the computer chose: randomNumber = random.randint(1, 3) if randomNumber == 1: computerMove = 'r' print('ROCK') elif randomNumber == 2: computerMove = 'p' print('PAPER') elif randomNumber == 3: computerMove = 's' print('SCISSORS')\n\nNext, the computer\u2019s move is randomly selected. Since random.randint() can only return a random number, the 1 , 2 , or 3 integer value it returns is stored in a variable named randomNumber . The program stores a 'r' , 'p' , or 's' string in computerMove based on the integer in randomNumber , as well as displays the computer\u2019s move.\n\n# Display and record the win/loss/tie: if playerMove == computerMove: print('It is a tie!') ties = ties + 1 elif playerMove == 'r' and computerMove == 's': print('You win!') wins = wins + 1 elif playerMove == 'p' and computerMove == 'r': print('You win!') wins = wins + 1 elif playerMove == 's' and computerMove == 'p': print('You win!') wins = wins + 1 elif playerMove == 'r' and computerMove == 'p': print('You lose!') losses = losses + 1 elif playerMove == 'p' and computerMove == 's': print('You lose!') losses = losses + 1 elif playerMove == 's' and computerMove == 'r': print('You lose!') losses = losses + 1\n\nFinally, the program compares the strings in playerMove and computerMove , and displays the results on the screen. It also increments the wins , losses , or ties variable appropriately. Once the execution reaches the end, it jumps back to the start of the main program loop to begin another game.", "source": "https://automatetheboringstuff.com/2e/chapter2/", "category": "2FLOW CONTROL"}
{"instruction": "How do I use '20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION' in Python?", "input": "", "output": "Knowing various Python modules for editing spreadsheets, downloading files, and launching programs is useful, but sometimes there just aren\u2019t any modules for the applications you need to work with. The ultimate tools for automating tasks on your computer are pro\u00adgrams you write that directly control the keyboard and mouse. These programs can control other applications by sending them virtual keystrokes and mouse clicks, just as if you were sitting at your computer and interacting with the applications yourself.\n\nThis technique is known as graphical user interface automation , or GUI automation for short. With GUI automation, your programs can do anything that a human user sitting at the computer can do, except spill coffee on the keyboard. Think of GUI automation as programming a robotic arm. You can program the robotic arm to type at your keyboard and move your mouse for you. This technique is particularly useful for tasks that involve a lot of mindless clicking or filling out of forms.\n\nSome companies sell innovative (and pricey) \u201cautomation solutions,\u201d usually marketed as robotic process automation (RPA) . These products are effectively no different than the Python scripts you can make yourself with the pyautogui module, which has functions for simulating mouse movements, button clicks, and mouse wheel scrolls. This chapter covers only a subset of PyAutoGUI\u2019s features; you can find the full documentation at https://pyautogui.readthedocs.io/ .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "What is 'Installing the pyautogui Module' and how does it work in Python?", "input": "", "output": "The pyautogui module can send virtual keypresses and mouse clicks to Windows, macOS, and Linux. Windows and macOS users can simply use pip to install PyAutoGUI. However, Linux users will first have to install some software that PyAutoGUI depends on. Open a terminal window and enter the following commands:\n\n* sudo apt-get install scrot\n* sudo apt-get install python3-tk\n* sudo apt-get install python3-dev\n\nTo install PyAutoGUI, run pip install --user pyautogui . Don\u2019t use sudo with pip ; you may install modules to the Python installation that the operating system uses, causing conflicts with any scripts that rely on its original configuration. However, you should use the sudo command when installing applications with apt-get .\n\nAppendix A has complete information on installing third-party modules. To test whether PyAutoGUI has been installed correctly, run import pyautogui from the interactive shell and check for any error messages.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Explain the concept of 'Setting Up Accessibility Apps on macOS' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "As a security measure, macOS doesn\u2019t normally let programs control the mouse or keyboard. To make PyAutoGUI work on macOS, you must set the program running your Python script to be an accessibility application. Without this step, your PyAutoGUI function calls will have no effect.\n\nWhether you run your Python programs from Mu, IDLE, or the Terminal, have that application open. Then open the System Preferences and go to the Accessibility tab. The currently open applications will appear under the \u201cAllow the apps below to control your computer\u201d label. Check Mu, IDLE, Terminal, or whichever app you use to run your Python scripts. You\u2019ll be prompted to enter your password to confirm these changes.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Explain the concept of 'Staying on Track' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Before you jump into a GUI automation, you should know how to escape problems that may arise. Python can move your mouse and type keystrokes at an incredible speed. In fact, it might be too fast for other programs to keep up with. Also, if something goes wrong but your program keeps moving the mouse around, it will be hard to tell what exactly the program is doing or how to recover from the problem. Like the enchanted brooms from Disney\u2019s The Sorcerer\u2019s Apprentice , which kept filling\u2014and then overfilling\u2014Mickey\u2019s tub with water, your program could get out of control even though it\u2019s following your instructions perfectly. Stopping the program can be difficult if the mouse is moving around on its own, preventing you from clicking the Mu Editor window to close it. Fortunately, there are several ways to prevent or recover from GUI automation problems.\n\nIf your program has a bug and you\u2019re unable to use the keyboard and mouse to shut it down, you can use PyAutoGUI\u2019s fail-safe feature. Quickly slide the mouse to one of the four corners of the screen. Every PyAutoGUI function call has a 10th-of-a-second delay after performing its action to give you enough time to move the mouse to a corner. If PyAutoGUI then finds that the mouse cursor is in a corner, it raises the pyautogui.FailSafeException exception. Non-PyAutoGUI instructions will not have this 10th-of-a-second delay.\n\nIf you find yourself in a situation where you need to stop your PyAutoGUI program, just slam the mouse toward a corner to stop it.\n\nPerhaps the simplest way to stop an out-of-control GUI automation program is to log out, which will shut down all running programs. On Windows and Linux, the logout hotkey is CTRL - ALT - DEL . On macOS, it is - SHIFT - OPTION -Q. By logging out, you\u2019ll lose any unsaved work, but at least you won\u2019t have to wait for a full reboot of the computer.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Explain the concept of 'Controlling Mouse Movement' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "In this section, you\u2019ll learn how to move the mouse and track its position on the screen using PyAutoGUI, but first you need to understand how PyAutoGUI works with coordinates.\n\nThe mouse functions of PyAutoGUI use x- and y-coordinates. Figure 20-1 shows the coordinate system for the computer screen; it\u2019s similar to the coordinate system used for images, discussed in Chapter 19. The origin , where x and y are both zero, is at the upper-left corner of the screen. The x-coordinates increase going to the right, and the y-coordinates increase going down. All coordinates are positive integers; there are no negative coordinates.\n\nFigure 20-1: The coordinates of a computer screen with 1920\u00d71080 resolution\n\nYour resolution is how many pixels wide and tall your screen is. If your screen\u2019s resolution is set to 1920\u00d71080, then the coordinate for the upper-left corner will be (0, 0), and the coordinate for the bottom-right corner will be (1919, 1079).\n\nThe pyautogui.size() function returns a two-integer tuple of the screen\u2019s width and height in pixels. Enter the following into the interactive shell:\n\n>>> import pyautogui >>> wh = pyautogui.size() # Obtain the screen resolution. >>> wh Size(width=1920, height=1080) >>> wh[0] 1920 >>> wh.width 1920\n\nThe pyautogui.size() function returns (1920, 1080) on a computer with a 1920\u00d71080 resolution; depending on your screen\u2019s resolution, your return value may be different. The Size object returned by size() is a named tuple. Named tuples have numeric indexes, like regular tuples, and attribute names, like objects: both wh[0] and wh.width evaluate to the width of the screen. (Named tuples are beyond the scope of this book. Just remember that you can use them the same way you use tuples.)\n\nNow that you understand screen coordinates, let\u2019s move the mouse. The pyautogui.moveTo() function will instantly move the mouse cursor to a specified position on the screen. Integer values for the x- and y-coordinates make up the function\u2019s first and second arguments, respectively. An optional duration integer or float keyword argument specifies the number of seconds it should take to move the mouse to the destination. If you leave it out, the default is 0 for instantaneous movement. (All of the duration keyword arguments in PyAutoGUI functions are optional.) Enter the following into the interactive shell:\n\n>>> import pyautogui >>> for i in range(10): # Move mouse in a square. ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.moveTo(100, 100, duration=0.25) ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.moveTo(200, 100, duration=0.25) ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.moveTo(200, 200, duration=0.25) ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.moveTo(100, 200, duration=0.25)\n\nThis example moves the mouse cursor clockwise in a square pattern among the four coordinates provided a total of 10 times. Each movement takes a quarter of a second, as specified by the duration=0.25 keyword argument. If you hadn\u2019t passed a third argument to any of the pyautogui.moveTo() calls, the mouse cursor would have instantly teleported from point to point.\n\nThe pyautogui.move() function moves the mouse cursor relative to its current position . The following example moves the mouse in the same square pattern, except it begins the square from wherever the mouse happens to be on the screen when the code starts running:\n\n>>> import pyautogui >>> for i in range(10): ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.move(100, 0, duration=0.25) # right ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.move(0, 100, duration=0.25) # down ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.move(-100, 0, duration=0.25) # left ...\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pyautogui.move(0, -100, duration=0.25) # up\n\nThe pyautogui.move() function also takes three arguments: how many pixels to move horizontally to the right, how many pixels to move vertically downward, and (optionally) how long it should take to complete the movement. A negative integer for the first or second argument will cause the mouse to move left or upward, respectively.\n\nYou can determine the mouse\u2019s current position by calling the pyautogui.position() function, which will return a Point named tuple of the mouse cursor\u2019s x and y positions at the time of the function call. Enter the following into the interactive shell, moving the mouse around after each call:\n\n>>> pyautogui.position() # Get current mouse position. Point(x=311, y=622) >>> pyautogui.position() # Get current mouse position again. Point(x=377, y=481) >>> p = pyautogui.position() # And again. >>> p Point(x=1536, y=637) >>> p[0] # The x-coordinate is at index 0. 1536 >>> p.x # The x-coordinate is also in the x attribute. 1536\n\nOf course, your return values will vary depending on where your mouse cursor is.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "What is 'Controlling Mouse Interaction' and how does it work in Python?", "input": "", "output": "Now that you know how to move the mouse and figure out where it is on the screen, you\u2019re ready to start clicking, dragging, and scrolling.\n\nTo send a virtual mouse click to your computer, call the pyautogui.click() method. By default, this click uses the left mouse button and takes place wherever the mouse cursor is currently located. You can pass x- and y-coordinates of the click as optional first and second arguments if you want it to take place somewhere other than the mouse\u2019s current position.\n\nIf you want to specify which mouse button to use, include the button keyword argument, with a value of 'left' , 'middle' , or 'right' . For example, pyautogui.click(100, 150, button='left') will click the left mouse button at the coordinates (100, 150), while pyautogui.click(200, 250, button='right') will perform a right-click at (200, 250).\n\nEnter the following into the interactive shell:\n\n>>> import pyautogui >>> pyautogui.click(10, 5) # Move mouse to (10, 5) and click.\n\nYou should see the mouse pointer move to near the top-left corner of your screen and click once. A full \u201cclick\u201d is defined as pushing a mouse button down and then releasing it back up without moving the cursor. You can also perform a click by calling pyautogui.mouseDown() , which only pushes the mouse button down, and pyautogui.mouseUp() , which only releases the button. These functions have the same arguments as click() , and in fact, the click() function is just a convenient wrapper around these two function calls.\n\nAs a further convenience, the pyautogui.doubleClick() function will perform two clicks with the left mouse button, while the pyautogui.rightClick() and pyautogui.middleClick() functions will perform a click with the right and middle mouse buttons, respectively.\n\nDragging means moving the mouse while holding down one of the mouse buttons. For example, you can move files between folders by dragging the folder icons, or you can move appointments around in a calendar app.\n\nPyAutoGUI provides the pyautogui.dragTo() and pyautogui.drag() functions to drag the mouse cursor to a new location or a location relative to its current one. The arguments for dragTo() and drag() are the same as moveTo() and move() : the x-coordinate/horizontal movement, the y-coordinate/vertical movement, and an optional duration of time. (macOS does not drag correctly when the mouse moves too quickly, so passing a duration keyword argument is recommended.)\n\nTo try these functions, open a graphics-drawing application such as MS Paint on Windows, Paintbrush on macOS, or GNU Paint on Linux. (If you don\u2019t have a drawing application, you can use the online one at https://sumopaint.com/ .) I will use PyAutoGUI to draw in these applications.\n\nWith the mouse cursor over the drawing application\u2019s canvas and the Pencil or Brush tool selected, enter the following into a new file editor window and save it as spiralDraw.py :\n\nimport pyautogui, time ? time.sleep(5) ? pyautogui.click()\u00a0\u00a0\u00a0\u00a0# Click to make the window active. distance = 300 change = 20 while distance > 0: ? pyautogui.drag(distance, 0, duration=0.2)\u00a0\u00a0\u00a0# Move right. ? distance = distance \u2013 change ? pyautogui.drag(0, distance, duration=0.2)\u00a0\u00a0\u00a0# Move down. ? pyautogui.drag(-distance, 0, duration=0.2)\u00a0\u00a0# Move left. distance = distance \u2013 change pyautogui.drag(0, -distance, duration=0.2)\u00a0\u00a0# Move up.\n\nWhen you run this program, there will be a five-second delay ? for you to move the mouse cursor over the drawing program\u2019s window with the Pencil or Brush tool selected. Then spiralDraw.py will take control of the mouse and click to make the drawing program\u2019s window active ? . The active window is the window that currently accepts keyboard input, and the actions you take\u2014like typing or, in this case, dragging the mouse\u2014will affect that window. The active window is also known as the focused or foreground window . Once the drawing program is active, spiralDraw.py draws a square spiral pattern like the one on the left of Figure 20-2. While you can also create a square spiral image by using the Pillow module discussed in Chapter 19, creating the image by controlling the mouse to draw it in MS Paint lets you make use of this program\u2019s various brush styles, like in Figure 20-2 on the right, as well as other advanced features, like gradients or the fill bucket. You can preselect the brush settings yourself (or have your Python code select these settings) and then run the spiral-drawing program.\n\nFigure 20-2: The results from the pyautogui.drag() example, drawn with MS Paint\u2019s different brushes\n\nThe distance variable starts at 200 , so on the first iteration of the while loop, the first drag() call drags the cursor 200 pixels to the right, taking 0.2 seconds ? . distance is then decreased to 195 ? , and the second drag() call drags the cursor 195 pixels down ? . The third drag() call drags the cursor \u2013195 horizontally (195 to the left) ? , distance is decreased to 190, and the last drag() call drags the cursor 190 pixels up. On each iteration, the mouse is dragged right, down, left, and up, and distance is slightly smaller than it was in the previous iteration. By looping over this code, you can move the mouse cursor to draw a square spiral.\n\nYou could draw this spiral by hand (or rather, by mouse), but you\u2019d have to work slowly to be so precise. PyAutoGUI can do it in a few seconds!\n\nThe final PyAutoGUI mouse function is scroll() , which you pass an integer argument for how many units you want to scroll the mouse up or down. The size of a unit varies for each operating system and application, so you\u2019ll have to experiment to see exactly how far it scrolls in your particular situation. The scrolling takes place at the mouse cursor\u2019s current position. Passing a positive integer scrolls up, and passing a negative integer scrolls down. Run the following in Mu Editor\u2019s interactive shell while the mouse cursor is over the Mu Editor window:\n\n>>> pyautogui.scroll(200)\n\nYou\u2019ll see Mu scroll upward if the mouse cursor is over a text field that can be scrolled up.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Provide a guide on 'Planning Your Mouse Movements' in Python.", "input": "", "output": "One of the difficulties of writing a program that will automate clicking the screen is finding the x- and y-coordinates of the things you\u2019d like to click. The pyautogui.mouseInfo() function can help you with this.\n\nThe pyautogui.mouseInfo() function is meant to be called from the interactive shell, rather than as part of your program. It launches a small application named MouseInfo that\u2019s included with PyAutoGUI. The window for the application looks like Figure 20-3.\n\nFigure 20-3: The MouseInfo application\u2019s window\n\nEnter the following into the interactive shell:\n\n>>> import pyautogui >>> pyautogui.mouseInfo()\n\nThis makes the MouseInfo window appear. This window gives you information about the mouse\u2019s cursor current position, as well the color of the pixel underneath the mouse cursor, as a three-integer RGB tuple and as a hex value. The color itself appears in the color box in the window.\n\nTo help you record this coordinate or pixel information, you can click one of the eight Copy or Log buttons. The Copy All, Copy XY, Copy RGB, and Copy RGB Hex buttons will copy their respective information to the clipboard. The Log All, Log XY, Log RGB, and Log RGB Hex buttons will write their respective information to the large text field in the window. You can save the text in this log text field by clicking the Save Log button.\n\nBy default, the 3 Sec. Button Delay checkbox is checked, causing a three-second delay between clicking a Copy or Log button and the copying or logging taking place. This gives you a short amount of time in which to click the button and then move the mouse into your desired position. It may be easier to uncheck this box, move the mouse into position, and press the F1 to F8 keys to copy or log the mouse position. You can look at the Copy and Log menus at the top of the MouseInfo window to find out which key maps to which buttons.\n\nFor example, uncheck the 3 Sec. Button Delay, then move the mouse around the screen while pressing the F6 button, and notice how the x- and y-coordinates of the mouse are recorded in the large text field in the middle of the window. You can later use these coordinates in your PyAutoGUI scripts.\n\nFor more information on MouseInfo, review the complete documentation at https://mouseinfo.readthedocs.io/ .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Provide a guide on 'Working with the Screen' in Python.", "input": "", "output": "Your GUI automation programs don\u2019t have to click and type blindly. PyAutoGUI has screenshot features that can create an image file based on the current contents of the screen. These functions can also return a Pillow Image object of the current screen\u2019s appearance. If you\u2019ve been skipping around in this book, you\u2019ll want to read Chapter 17 and install the pillow module before continuing with this section.\n\nOn Linux computers, the scrot program needs to be installed to use the screenshot functions in PyAutoGUI. In a Terminal window, run sudo apt-get install scrot to install this program. If you\u2019re on Windows or macOS, skip this step and continue with the section.\n\nTo take screenshots in Python, call the pyautogui.screenshot() function. Enter the following into the interactive shell:\n\n>>> import pyautogui >>> im = pyautogui.screenshot()\n\nThe im variable will contain the Image object of the screenshot. You can now call methods on the Image object in the im variable, just like any other Image object. Chapter 19 has more information about Image objects.\n\nSay that one of the steps in your GUI automation program is to click a gray button. Before calling the click() method, you could take a screenshot and look at the pixel where the script is about to click. If it\u2019s not the same gray as the gray button, then your program knows something is wrong. Maybe the window moved unexpectedly, or maybe a pop-up dialog has blocked the button. At this point, instead of continuing\u2014and possibly wreaking havoc by clicking the wrong thing\u2014your program can \u201csee\u201d that it isn\u2019t clicking the right thing and stop itself.\n\nYou can obtain the RGB color value of a particular pixel on the screen with the pixel() function. Enter the following into the interactive shell:\n\n>>> import pyautogui >>> pyautogui.pixel((0, 0)) (176, 176, 175) >>> pyautogui.pixel((50, 200)) (130, 135, 144)\n\nPass pixel() a tuple of coordinates, like (0, 0) or (50, 200), and it\u2019ll tell you the color of the pixel at those coordinates in your image. The return value from pixel() is an RGB tuple of three integers for the amount of red, green, and blue in the pixel. (There is no fourth value for alpha, because screenshot images are fully opaque.)\n\nPyAutoGUI\u2019s pixelMatchesColor() function will return True if the pixel at the given x- and y-coordinates on the screen matches the given color. The first and second arguments are integers for the x- and y-coordinates, and the third argument is a tuple of three integers for the RGB color the screen pixel must match. Enter the following into the interactive shell:\n\n>>> import pyautogui ? >>> pyautogui.pixel((50, 200)) (130, 135, 144) ? >>> pyautogui.pixelMatchesColor(50, 200, (130, 135, 144)) True ? >>> pyautogui.pixelMatchesColor(50, 200, (255, 135, 144)) False\n\nAfter using pixel() to get an RGB tuple for the color of a pixel at specific coordinates ? , pass the same coordinates and RGB tuple to pixelMatchesColor() ? , which should return True . Then change a value in the RGB tuple and call pixelMatchesColor() again for the same coordinates ? . This should return false . This method can be useful to call whenever your GUI automation programs are about to call click() . Note that the color at the given coordinates must exactly match. If it is even slightly different\u2014for example, (255, 255, 254) instead of (255, 255, 255) \u2014then pixelMatchesColor() will return False .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "What is 'Image Recognition' and how does it work in Python?", "input": "", "output": "But what if you do not know beforehand where PyAutoGUI should click? You can use image recognition instead. Give PyAutoGUI an image of what you want to click, and let it figure out the coordinates.\n\nFor example, if you have previously taken a screenshot to capture the image of a Submit button in submit.png , the locateOnScreen() function will return the coordinates where that image is found. To see how locateOnScreen() works, try taking a screenshot of a small area on your screen; then save the image and enter the following into the interactive shell, replacing 'submit.png' with the filename of your screenshot:\n\n>>> import pyautogui >>> b = pyautogui.locateOnScreen('submit.png') >>> b Box(left=643, top=745, width=70, height=29) >>> b[0] 643 >>> b.left 643\n\nThe Box object is a named tuple that locateOnScreen() returns and has the x-coordinate of the left edge, the y-coordinate of the top edge, the width, and the height for the first place on the screen the image was found. If you\u2019re trying this on your computer with your own screenshot, your return value will be different from the one shown here.\n\nIf the image cannot be found on the screen, locateOnScreen() returns None . Note that the image on the screen must match the provided image perfectly in order to be recognized. If the image is even a pixel off, locateOnScreen() raises an ImageNotFoundException exception. If you\u2019ve changed your screen resolution, images from previous screenshots might not match the images on your current screen. You can change the scaling in the display settings of your operating system, as shown in Figure 20-4.\n\nFigure 20-4: The scale display settings in Windows 10 (left) and macOS (right)\n\nIf the image can be found in several places on the screen, locateAllOnScreen() will return a Generator object. Generators are beyond the scope of this book, but you can pass them to list() to return a list of four-integer tuples. There will be one four-integer tuple for each location where the image is found on the screen. Continue the interactive shell example by entering the following (and replacing 'submit.png' with your own image filename):\n\n>>> list(pyautogui.locateAllOnScreen('submit.png')) [(643, 745, 70, 29), (1007, 801, 70, 29)]\n\nEach of the four-integer tuples represents an area on the screen. In the example above, the image appears in two locations. If your image is only found in one area, then using list() and locateAllOnScreen() returns a list containing just one tuple.\n\nOnce you have the four-integer tuple for the specific image you want to select, you can click the center of this area by passing the tuple to click() . Enter the following into the interactive shell:\n\n>>> pyautogui.click((643, 745, 70, 29))\n\nAs a shortcut, you can also pass the image filename directly to the click() function:\n\n>>> pyautogui.click('submit.png')\n\nThe moveTo() and dragTo() functions also accept image filename arguments. Remember locateOnScreen() raises an exception if it can\u2019t find the image on the screen, so you should call it from inside a try statement:\n\ntry: location = pyautogui.locateOnScreen('submit.png') except: print('Image could not be found.')\n\nWithout the try and except statements, the uncaught exception would crash your program. Since you can\u2019t be sure that your program will always find the image, it\u2019s a good idea to use the try and except statements when calling locateOnScreen() .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "What is 'Getting Window Information' and how does it work in Python?", "input": "", "output": "Image recognition is a fragile way to find things on the screen; if a single pixel is a different color, then pyautogui.locateOnScreen() won\u2019t find the image. If you need to find where a particular window is on the screen, it\u2019s faster and more reliable to use PyAutoGUI\u2019s window features.\n\nThe active window on your screen is the window currently in the foreground and accepting keyboard input. If you\u2019re currently writing code in the Mu Editor, the Mu Editor\u2019s window is the active window. Of all the windows on your screen, only one will be active at a time.\n\nIn the interactive shell, call the pyautogui.getActiveWindow() function to get a Window object (technically a Win32Window object when run on Windows).\n\nOnce you have that Window object, you can retrieve any of the object\u2019s attributes, which describe its size, position, and title:\n\nleft, right, top, bottom A single integer for the x- or y-coordinate of the window\u2019s side\n\ntopleft, topright, bottomleft, bottomright A named tuple of two integers for the (x, y) coordinates of the window\u2019s corner\n\nmidleft, midright, midleft, midright A named tuple of two integers for the (x, y) coordinate of the middle of the window\u2019s side\n\nwidth, height A single integer for one of the window\u2019s dimensions, in pixels\n\nsize A named tuple of two integers for the (width, height) of the window\n\narea A single integer representing the area of the window, in pixels\n\ncenter A named tuple of two integers for the (x, y) coordinate of the window\u2019s center\n\ncenterx, centery A single integer for the x- or y-coordinate of the window\u2019s center\n\nbox A named tuple of four integers for the (left, top, width, height) measurements of the window\n\ntitle A string of the text in the title bar at the top of the window\n\nTo get the window\u2019s position, size, and title information from the window object, for example, enter the following into the interactive shell:\n\n>>> import pyautogui >>> fw = pyautogui.getActiveWindow() >>> fw Win32Window(hWnd=2034368) >>> str(fw) '<Win32Window left=\"500\", top=\"300\", width=\"2070\", height=\"1208\", title=\"Mu 1.0.1 \u2013 test1.py\">' >>> fw.title 'Mu 1.0.1 \u2013 test1.py' >>> fw.size (2070, 1208) >>> fw.left, fw.top, fw.right, fw.bottom (500, 300, 2070, 1208) >>> fw.topleft (256, 144) >>> fw.area 2500560 >>> pyautogui.click(fw.left + 10, fw.top + 20)\n\nYou can now use these attributes to calculate precise coordinates within a window. If you know that a button you want to click is always 10 pixels to the right of and 20 pixels down from the window\u2019s top-left corner, and the window\u2019s top-left corner is at screen coordinates (300, 500), then calling pyautogui.click(310, 520) (or pyautogui.click(fw.left + 10, fw.top + 20) if fw contains the Window object for the window) will click the button. This way, you won\u2019t have to rely on the slower, less reliable locateOnScreen() function to find the button for you.\n\nWhile getActiveWindow() is useful for obtaining the window that is active at the time of the function call, you\u2019ll need to use some other function to obtain Window objects for the other windows on the screen.\n\nThe following four functions return a list of Window objects. If they\u2019re unable to find any windows, they return an empty list:\n\npyautogui.getAllWindows() Returns a list of Window objects for every visible window on the screen.\n\npyautogui.getWindowsAt(x, y) Returns a list of Window objects for every visible window that includes the point (x, y).\n\npyautogui.getWindowsWithTitle(title) Returns a list of Window objects for every visible window that includes the string title in its title bar.\n\npyautogui.getActiveWindow() Returns the Window object for the window that is currently receiving keyboard focus.\n\nPyAutoGUI also has a pyautogui.getAllTitles() function, which returns a list of strings of every visible window.\n\nWindows attributes can do more than just tell you the size and position of the window. You can also set their values in order to resize or move the window. For example, enter the following into the interactive shell:\n\n>>> import pyautogui >>> fw = pyautogui.getActiveWindow() ? >>> fw.width # Gets the current width of the window. 1669 ? >>> fw.topleft # Gets the current position of the window. (174, 153) ? >>> fw.width = 1000 # Resizes the width. ? >>> fw.topleft = (800, 400) # Moves the window.\n\nFirst, we use the Window object\u2019s attributes to find out information about the window\u2019s size ? and position ? . After calling these functions in Mu Editor, the window should move ? and become narrower ? , as in Figure 20-5.\n\nFigure 20-5: The Mu Editor window before (top) and after (bottom) using the Window object attributes to move and resize it\n\nYou can also find out and change the window\u2019s minimized, maximized, and activated states. Try entering the following into the interactive shell:\n\n>>> import pyautogui >>> fw = pyautogui.getActiveWindow() ? >>> fw.isMaximized # Returns True if window is maximized. False ? >>> fw.isMinimized # Returns True if window is minimized. False ? >>> fw.isActive # Returns True if window is the active window. True ? >>> fw.maximize() # Maximizes the window. >>> fw.isMaximized True ? >>> fw.restore() # Undoes a minimize/maximize action. ? >>> fw.minimize() # Minimizes the window. >>> import time >>> # Wait 5 seconds while you activate a different window: ? >>> time.sleep(5); fw.activate() ? >>> fw.close() # This will close the window you're typing in.\n\nThe isMaximized ? , isMinimized ? , and isActive ? attributes contain Boolean values that indicate whether the window is currently in that state. The maximize() ? , minimize() ? , activate() ? , and restore() ? methods change the window\u2019s state. After you maximize or minimize the window with maximize() or minimize() , the restore() method will restore the window to its former size and position.\n\nThe close() method ? will close a window. Be careful with this method, as it may bypass any message dialogs asking you to save your work before quitting the application.\n\nThe complete documentation for PyAutoGUI\u2019s window-controlling feature can be found at https://pyautogui.readthedocs.io/ . You can also use these features separately from PyAutoGUI with the PyGetWindow module, documented at https://pygetwindow.readthedocs.io/ .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "How do I use 'Controlling the Keyboard' in Python?", "input": "", "output": "PyAutoGUI also has functions for sending virtual keypresses to your computer, which enables you to fill out forms or enter text into applications.\n\nThe pyautogui.write() function sends virtual keypresses to the computer. What these keypresses do depends on what window is active and what text field has focus. You may want to first send a mouse click to the text field you want in order to ensure that it has focus.\n\nAs a simple example, let\u2019s use Python to automatically type the words Hello, world! into a file editor window. First, open a new file editor window and position it in the upper-left corner of your screen so that PyAutoGUI will click in the right place to bring it into focus. Next, enter the following into the interactive shell:\n\n>>> pyautogui.click(100, 200); pyautogui.write('Hello, world!')\n\nNotice how placing two commands on the same line, separated by a semicolon, keeps the interactive shell from prompting you for input between running the two instructions. This prevents you from accidentally bringing a new window into focus between the click() and write() calls, which would mess up the example.\n\nPython will first send a virtual mouse click to the coordinates (100, 200), which should click the file editor window and put it in focus. The write() call will send the text Hello, world! to the window, making it look like Figure 20-6. You now have code that can type for you!\n\nFigure 20-6: Using PyAutogGUI to click the file editor window and type Hello, world! into it\n\nBy default, the write() function will type the full string instantly. However, you can pass an optional second argument to add a short pause between each character. This second argument is an integer or float value of the number of seconds to pause. For example, pyautogui.write('Hello, world!', 0.25) will wait a quarter-second after typing H , another quarter-second after e , and so on. This gradual typewriter effect may be useful for slower applications that can\u2019t process keystrokes fast enough to keep up with PyAutoGUI.\n\nFor characters such as A or ! , PyAutoGUI will automatically simulate holding down the SHIFT key as well.\n\nNot all keys are easy to represent with single text characters. For example, how do you represent SHIFT or the left arrow key as a single character? In PyAutoGUI, these keyboard keys are represented by short string values instead: 'esc' for the ESC key or 'enter' for the ENTER key.\n\nInstead of a single string argument, a list of these keyboard key strings can be passed to write() . For example, the following call presses the A key, then the B key, then the left arrow key twice, and finally the X and Y keys:\n\n>>> pyautogui.write(['a', 'b', 'left', 'left', 'X', 'Y'])\n\nBecause pressing the left arrow key moves the keyboard cursor, this will output XYab . Table 20-1 lists the PyAutoGUI keyboard key strings that you can pass to write() to simulate pressing any combination of keys.\n\nYou can also examine the pyautogui.KEYBOARD_KEYS list to see all possible keyboard key strings that PyAutoGUI will accept. The 'shift' string refers to the left SHIFT key and is equivalent to 'shiftleft' . The same applies for 'ctrl' , 'alt' , and 'win' strings; they all refer to the left-side key.\n\nTable 20-1: PyKeyboard Attributes\n\nMuch like the mouseDown() and mouseUp() functions, pyautogui.keyDown() and pyautogui.keyUp() will send virtual keypresses and releases to the computer. They are passed a keyboard key string (see Table 20-1) for their argument. For convenience, PyAutoGUI provides the pyautogui.press() function, which calls both of these functions to simulate a complete keypress.\n\nRun the following code, which will type a dollar sign character (obtained by holding the SHIFT key and pressing 4):\n\n>>> pyautogui.keyDown('shift'); pyautogui.press('4'); pyautogui.keyUp('shift')\n\nThis line presses down SHIFT , presses (and releases) 4, and then releases SHIFT . If you need to type a string into a text field, the write() function is more suitable. But for applications that take single-key commands, the press() function is the simpler approach.\n\nA hotkey or shortcut is a combination of keypresses to invoke some application function. The common hotkey for copying a selection is CTRL -C (on Windows and Linux) or -C (on macOS). The user presses and holds the CTRL key, then presses the C key, and then releases the C and CTRL keys. To do this with PyAutoGUI\u2019s keyDown() and keyUp() functions, you would have to enter the following:\n\npyautogui.keyDown('ctrl') pyautogui.keyDown('c') pyautogui.keyUp('c') pyautogui.keyUp('ctrl')\n\nThis is rather complicated. Instead, use the pyautogui.hotkey() function, which takes multiple keyboard key string arguments, presses them in order, and releases them in the reverse order. For the CTRL -C example, the code would simply be as follows:\n\npyautogui.hotkey('ctrl', 'c')\n\nThis function is especially useful for larger hotkey combinations. In Word, the CTRL - ALT - SHIFT -S hotkey combination displays the Style pane. Instead of making eight different function calls (four keyDown() calls and four keyUp() calls), you can just call hotkey('ctrl', 'alt', 'shift', 's') .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "How do I use 'Setting Up Your GUI Automation Scripts' in Python?", "input": "", "output": "GUI automation scripts are a great way to automate the boring stuff, but your scripts can also be finicky. If a window is in the wrong place on a desktop or some pop-up appears unexpectedly, your script could be clicking on the wrong things on the screen. Here are some tips for setting up your GUI automation scripts:\n\n* Use the same screen resolution each time you run the script so that the position of windows doesn\u2019t change.\n* The application window that your script clicks should be maximized so that its buttons and menus are in the same place each time you run the script.\n* Add generous pauses while waiting for content to load; you don\u2019t want your script to begin clicking before the application is ready.\n* Use locateOnScreen() to find buttons and menus to click, rather than relying on XY coordinates. If your script can\u2019t find the thing it needs to click, stop the program rather than let it continue blindly clicking.\n* Use getWindowsWithTitle() to ensure that the application window you think your script is clicking on exists, and use the activate() method to put that window in the foreground.\n* Use the logging module from Chapter 11 to keep a log file of what your script has done. This way, if you have to stop your script halfway through a process, you can change it to pick up from where it left off.\n* Add as many checks as you can to your script. Think about how it could fail if an unexpected pop-up window appears or if your computer loses its internet connection.\n* You may want to supervise the script when it first begins to ensure that it\u2019s working correctly.\n\nYou might also want to put a pause at the start of your script so the user can set up the window the script will click on. PyAutoGUI has a sleep() function that acts identically to time.sleep() (it just frees you from having to also add import time to your scripts). There is also a countdown() function that prints numbers counting down to give the user a visual indication that the script will continue soon. Enter the following into the interactive shell:\n\n>>> import pyautogui >>> pyautogui.sleep(3) # Pauses the program for 3 seconds. >>> pyautogui.countdown(10) # Counts down over 10 seconds. 10 9 8 7 6 5 4 3 2 1 >>> print('Starting in ', end=''); pyautogui.countdown(3) Starting in 3 2 1\n\nThese tips can help make your GUI automation scripts easier to use and more able to recover from unforeseen circumstances.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Explain the concept of 'Review of the PyAutoGUI Functions' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Since this chapter covered many different functions, here is a quick summary reference:\n\nmoveTo( x , y ) Moves the mouse cursor to the given x and y coordinates.\n\nmove( xOffset , yOffset ) Moves the mouse cursor relative to its current position.\n\ndragTo( x , y ) Moves the mouse cursor while the left button is held down.\n\ndrag( xOffset , yOffset ) Moves the mouse cursor relative to its current position while the left button is held down.\n\nclick( x , y , button ) Simulates a click (left button by default).\n\nrightClick() Simulates a right-button click.\n\nmiddleClick() Simulates a middle-button click.\n\ndoubleClick() Simulates a double left-button click.\n\nmouseDown( x , y , button ) Simulates pressing down the given button at the position x , y .\n\nmouseUp( x , y , button ) Simulates releasing the given button at the position x , y .\n\nscroll( units ) Simulates the scroll wheel. A positive argument scrolls up; a negative argument scrolls down.\n\nwrite( message ) Types the characters in the given message string.\n\nwrite([ key1 , key2 , key3 ]) Types the given keyboard key strings.\n\npress( key ) Presses the given keyboard key string.\n\nkeyDown( key ) Simulates pressing down the given keyboard key.\n\nkeyUp( key ) Simulates releasing the given keyboard key.\n\nhotkey([ key1 , key2 , key3 ]) Simulates pressing the given keyboard key strings down in order and then releasing them in reverse order.\n\nscreenshot() Returns a screenshot as an Image object. (See Chapter 19 for information on Image objects.)\n\ngetActiveWindow(), getAllWindows(), getWindowsAt() , and getWindowsWithTitle() These functions return Window objects that can resize and reposition application windows on the desktop.\n\ngetAllTitles() Returns a list of strings of the title bar text of every window on the desktop.", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "How do I use 'Project: Automatic Form Filler' in Python?", "input": "", "output": "Of all the boring tasks, filling out forms is the most dreaded of chores. It\u2019s only fitting that now, in the final chapter project, you will slay it. Say you have a huge amount of data in a spreadsheet, and you have to tediously retype it into some other application\u2019s form interface\u2014with no intern to do it for you. Although some applications will have an Import feature that will allow you to upload a spreadsheet with the information, sometimes it seems that there is no other way than mindlessly clicking and typing for hours on end. You\u2019ve come this far in this book; you know that of course must be a way to automate this boring task.\n\nThe form for this project is a Google Docs form that you can find at https://autbor.com/form . It looks like Figure 20-7.\n\nFigure 20-7: The form used for this project\n\nAt a high level, here\u2019s what your program should do:\n\n1. Click the first text field of the form.\n2. Move through the form, typing information into each field.\n3. Click the Submit button.\n4. Repeat the process with the next set of data.\n\nThis means your code will need to do the following:\n\n1. Call pyautogui.click() to click the form and Submit button.\n2. Call pyautogui.write() to enter text into the fields.\n3. Handle the KeyboardInterrupt exception so the user can press CTRL -C to quit.\n\nOpen a new file editor window and save it as formFiller.py .\n\nBefore writing code, you need to figure out the exact keystrokes and mouse clicks that will fill out the form once. The application launched by calling pyautogui.mouseInfo() can help you figure out specific mouse coordinates. You need to know only the coordinates of the first text field. After clicking the first field, you can just press TAB to move focus to the next field. This will save you from having to figure out the x- and y-coordinates to click for every field.\n\nHere are the steps for entering data into the form:\n\n1. Put the keyboard focus on the Name field so that pressing keys types text into the field.\n2. Type a name and then press TAB .\n3. Type a greatest fear and then press TAB .\n4. Press the down arrow key the correct number of times to select the wizard power source: once for wand , twice for amulet , three times for crystal ball , and four times for money . Then press TAB . (Note that on macOS, you will have to press the down arrow key one more time for each option. For some browsers, you may need to press ENTER as well.)\n5. Press the right arrow key to select the answer to the RoboCop question. Press it once for 2 , twice for 3 , three times for 4 , or four times for 5 or just press the spacebar to select 1 (which is highlighted by default). Then press TAB .\n6. Type an additional comment and then press TAB .\n7. Press ENTER to \u201cclick\u201d the Submit button.\n8. After submitting the form, the browser will take you to a page where you will need to follow a link to return to the form page.\n\nDifferent browsers on different operating systems might work slightly differently from the steps given here, so check that these keystroke combinations work for your computer before running your program.\n\nLoad the example form you downloaded (Figure 20-7) in a browser by going to https://autbor.com/form .\n\nMake your source code look like the following:\n\n#! python3 # formFiller.py - Automatically fills in the form. import pyautogui, time # TODO: Give the user a chance to kill the script. # TODO: Wait until the form page has loaded. # TODO: Fill out the Name Field. # TODO: Fill out the Greatest Fear(s) field. # TODO: Fill out the Source of Wizard Powers field. # TODO: Fill out the RoboCop field. # TODO: Fill out the Additional Comments field. # TODO: Click Submit. # TODO: Wait until form page has loaded. # TODO: Click the Submit another response link.\n\nNow you need the data you actually want to enter into this form. In the real world, this data might come from a spreadsheet, a plaintext file, or a website, and it would require additional code to load into the program. But for this project, you\u2019ll just hardcode all this data in a variable. Add the following to your program:\n\n#! python3 # formFiller.py - Automatically fills in the form. -- snip -- formData = [{'name': 'Alice', 'fear': 'eavesdroppers', 'source': 'wand', 'robocop': 4, 'comments': 'Tell Bob I said hi.'}, {'name': 'Bob', 'fear': 'bees', 'source': 'amulet', 'robocop': 4, 'comments': 'n/a'}, {'name': 'Carol', 'fear': 'puppets', 'source': 'crystal ball', 'robocop': 1, 'comments': 'Please take the puppets out of the break room.'}, {'name': 'Alex Murphy', 'fear': 'ED-209', 'source': 'money', 'robocop': 5, 'comments': 'Protect the innocent. Serve the public trust. Uphold the law.'}, ] -- snip --\n\nThe formData list contains four dictionaries for four different names. Each dictionary has names of text fields as keys and responses as values. The last bit of setup is to set PyAutoGUI\u2019s PAUSE variable to wait half a second after each function call. Also, remind the user to click on the browser to make it the active window. Add the following to your program after the formData assignment statement:\n\npyautogui.PAUSE = 0.5 print('Ensure that the browser window is active and the form is loaded!')\n\nA for loop will iterate over each of the dictionaries in the formData list, passing the values in the dictionary to the PyAutoGUI functions that will virtually type in the text fields.\n\nAdd the following code to your program:\n\n#! python3 # formFiller.py - Automatically fills in the form. -- snip -- for person in formData: # Give the user a chance to kill the script. print('>>> 5-SECOND PAUSE TO LET USER PRESS CTRL-C <<<') ? time.sleep(5) -- snip --\n\nAs a small safety feature, the script has a five-second pause ? that gives the user a chance to hit CTRL -C (or move the mouse cursor to the upper-left corner of the screen to raise the FailSafeException exception) to shut the program down in case it\u2019s doing something unexpected. After the code that waits to give the page time to load, add the following:\n\n#! python3 # formFiller.py - Automatically fills in the form. -- snip -- ? print('Entering %s info...' % (person['name'])) ? pyautogui.write(['\\t', '\\t']) # Fill out the Name field. ? pyautogui.write(person['name'] + '\\t') # Fill out the Greatest Fear(s) field. ? pyautogui.write(person['fear'] + '\\t') -- snip --\n\nWe add an occasional print() call to display the program\u2019s status in its Terminal window to let the user know what\u2019s going on ? .\n\nSince the form has had time to load, call pyautogui.write(['\\t', '\\t']) to press TAB twice and put the Name field into focus ? . Then call write() again to enter the string in person['name'] ? . The '\\t' character is added to the end of the string passed to write() to simulate pressing TAB , which moves the keyboard focus to the next field, Greatest Fear(s). Another call to write() will type the string in person['fear'] into this field and then tab to the next field in the form ? .\n\nThe drop-down menu for the \u201cwizard powers\u201d question and the radio buttons for the RoboCop field are trickier to handle than the text fields. To click these options with the mouse, you would have to figure out the x- and y-coordinates of each possible option. It\u2019s easier to use the keyboard arrow keys to make a selection instead.\n\nAdd the following to your program:\n\n#! python3 # formFiller.py - Automatically fills in the form. -- snip -- # Fill out the Source of Wizard Powers field. ? if person['source'] == 'wand': ? pyautogui.write(['down', '\\t'] , 0.5) elif person['source'] == 'amulet': pyautogui.write(['down', 'down', '\\t'] , 0.5) elif person['source'] == 'crystal ball': pyautogui.write(['down', 'down', 'down', '\\t'] , 0.5) elif person['source'] == 'money': pyautogui.write(['down', 'down', 'down', 'down', '\\t'] , 0.5) # Fill out the RoboCop field. ? if person['robocop'] == 1: ? pyautogui.write([' ', '\\t'] , 0.5) elif person['robocop'] == 2: pyautogui.write(['right', '\\t'] , 0.5) elif person['robocop'] == 3: pyautogui.write(['right', 'right', '\\t'] , 0.5) elif person['robocop'] == 4: pyautogui.write(['right', 'right', 'right', '\\t'] , 0.5) elif person['robocop'] == 5: pyautogui.write(['right', 'right', 'right', 'right', '\\t'] , 0.5) -- snip --\n\nOnce the drop-down menu has focus (remember that you wrote code to simulate pressing TAB after filling out the Greatest Fear(s) field), pressing the down arrow key will move to the next item in the selection list. Depending on the value in person['source'] , your program should send a number of down arrow keypresses before tabbing to the next field. If the value at the 'source' key in this user\u2019s dictionary is 'wand' ? , we simulate pressing the down arrow key once (to select Wand ) and pressing TAB ? . If the value at the 'source' key is 'amulet' , we simulate pressing the down arrow key twice and pressing TAB , and so on for the other possible answers. The 0.5 argument in these write() calls add a half-second pause in between each key so that our program doesn\u2019t move too fast for the form.\n\nThe radio buttons for the RoboCop question can be selected with the right arrow keys\u2014or, if you want to select the first choice ? , by just pressing the spacebar ? .\n\nYou can fill out the Additional Comments field with the write() function by passing person['comments'] as an argument. You can type an additional '\\t' to move the keyboard focus to the next field or the Submit button. Once the Submit button is in focus, calling pyautogui.press('enter') will simulate pressing the ENTER key and submit the form. After submitting the form, your program will wait five seconds for the next page to load.\n\nOnce the new page has loaded, it will have a Submit another response link that will direct the browser to a new, empty form page. You stored the coordinates of this link as a tuple in submitAnotherLink in step 2, so pass these coordinates to pyautogui.click() to click this link.\n\nWith the new form ready to go, the script\u2019s outer for loop can continue to the next iteration and enter the next person\u2019s information into the form.\n\nComplete your program by adding the following code:\n\n#! python3 # formFiller.py - Automatically fills in the form. -- snip -- # Fill out the Additional Comments field. pyautogui.write(person['comments'] + '\\t') # \"Click\" Submit button by pressing Enter. time.sleep(0.5) # Wait for the button to activate. pyautogui.press('enter') # Wait until form page has loaded. print('Submitted form.') time.sleep(5) # Click the Submit another response link. pyautogui.click(submitAnotherLink[0], submitAnotherLink[1])\n\nOnce the main for loop has finished, the program will have plugged in the information for each person. In this example, there are only four people to enter. But if you had 4,000 people, then writing a program to do this would save you a lot of time and typing!", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Provide a guide on 'Displaying Message Boxes' in Python.", "input": "", "output": "The programs you\u2019ve been writing so far all tend to use plaintext output (with the print() function) and input (with the input() function). However, PyAutoGUI programs will use your entire desktop as its playground. The text-based window that your program runs in, whether it\u2019s Mu or a Terminal window, will probably be lost as your PyAutoGUI program clicks and interacts with other windows. This can make getting input and output from the user hard if the Mu or Terminal windows get hidden under other windows.\n\nTo solve this, PyAutoGUI offers pop-up message boxes to provide notifications to the user and receive input from them. There are four message box functions:\n\npyautogui.alert(text) Displays text and has a single OK button.\n\npyautogui.confirm(text) Displays text and has OK and Cancel buttons, returning either 'OK' or 'Cancel' depending on the button clicked.\n\npyautogui.prompt(text) Displays text and has a text field for the user to type in, which it returns as a string.\n\npyautogui.password(text) Is the same as prompt() , but displays asterisks so the user can enter sensitive information such as a password.\n\nThese functions also have an optional second parameter that accepts a string value to use as the title in the title bar of the message box. The functions won\u2019t return until the user has clicked a button on them, so they can also be used to introduce pauses into your PyAutoGUI programs. Enter the following into the interactive shell:\n\n>>> import pyautogui >>> pyautogui.alert('This is a message.', 'Important') 'OK' >>> pyautogui.confirm('Do you want to continue?') # Click Cancel 'Cancel' >>> pyautogui.prompt(\"What is your cat's name?\") 'Zophie' >>> pyautogui.password('What is the password?') 'hunter2'\n\nThe pop-up message boxes that these lines produce look like Figure 20-8.\n\nFigure 20-8: From top left to bottom right, the windows created by alert() , confirm() , prompt() , and password()\n\nThese functions can be used to provide notifications or ask the user questions while the rest of the program interacts with the computer through the mouse and keyboard. The full online documentation can be found at https://pymsgbox.readthedocs.io .", "source": "https://automatetheboringstuff.com/2e/chapter20/", "category": "20CONTROLLING THE KEYBOARD AND MOUSE WITH GUI AUTOMATION"}
{"instruction": "Explain the concept of '3FUNCTIONS' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "You\u2019re already familiar with the print() , input() , and len() functions from the previous chapters. Python provides several built-in functions like these, but you can also write your own functions. A function is like a miniprogram within a program.\n\nTo better understand how functions work, let\u2019s create one. Enter this program into the file editor and save it as helloFunc.py :\n\n\u278a def hello(): \u278b print('Howdy!') print('Howdy!!!') print('Hello there.') \u278c hello() hello() hello()\n\nYou can view the execution of this program at https://autbor.com/hellofunc/ . The first line is a def statement \u278a , which defines a function named hello() . The code in the block that follows the def statement \u278b is the body of the function. This code is executed when the function is called, not when the function is first defined.\n\nThe hello() lines after the function \u278c are function calls. In code, a function call is just the function\u2019s name followed by parentheses, possibly with some number of arguments in between the parentheses. When the program execution reaches these calls, it will jump to the top line in the function and begin executing the code there. When it reaches the end of the function, the execution returns to the line that called the function and continues moving through the code as before.\n\nSince this program calls hello() three times, the code in the hello() function is executed three times. When you run this program, the output looks like this:\n\nHowdy! Howdy!!! Hello there. Howdy! Howdy!!! Hello there. Howdy! Howdy!!! Hello there.\n\nA major purpose of functions is to group code that gets executed multiple times. Without a function defined, you would have to copy and paste this code each time, and the program would look like this:\n\nprint('Howdy!') print('Howdy!!!') print('Hello there.') print('Howdy!') print('Howdy!!!') print('Hello there.') print('Howdy!') print('Howdy!!!') print('Hello there.')\n\nIn general, you always want to avoid duplicating code because if you ever decide to update the code\u2014if, for example, you find a bug you need to fix\u2014you\u2019ll have to remember to change the code everywhere you copied it.\n\nAs you get more programming experience, you\u2019ll often find yourself deduplicating code, which means getting rid of duplicated or copy-and-pasted code. Deduplication makes your programs shorter, easier to read, and easier to update.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "Provide a guide on 'def Statements with Parameters' in Python.", "input": "", "output": "When you call the print() or len() function, you pass them values, called arguments , by typing them between the parentheses. You can also define your own functions that accept arguments. Type this example into the file editor and save it as helloFunc2.py :\n\n\u278a def hello(name): \u278b print('Hello, ' + name) \u278c hello('Alice') hello('Bob')\n\nWhen you run this program, the output looks like this:\n\nHello, Alice Hello, Bob\n\nYou can view the execution of this program at https://autbor.com/hellofunc2/ . The definition of the hello() function in this program has a parameter called name \u278a . Parameters are variables that contain arguments. When a function is called with arguments, the arguments are stored in the parameters. The first time the hello() function is called, it is passed the argument 'Alice' \u278c . The program execution enters the function, and the parameter name is automatically set to 'Alice' , which is what gets printed by the print() statement \u278b .\n\nOne special thing to note about parameters is that the value stored in a parameter is forgotten when the function returns. For example, if you added print(name) after hello('Bob') in the previous program, the program would give you a NameError because there is no variable named name . This variable is destroyed after the function call hello('Bob') returns, so print(name) would refer to a name variable that does not exist.\n\nThis is similar to how a program\u2019s variables are forgotten when the program terminates. I\u2019ll talk more about why that happens later in the chapter, when I discuss what a function\u2019s local scope is.\n\nThe terms define , call , pass , argument , and parameter can be confusing. Let\u2019s look at a code example to review these terms:\n\n\u278a def sayHello(name): print('Hello, ' + name) \u278b sayHello('Al')\n\nTo define a function is to create it, just like an assignment statement like spam = 42 creates the spam variable. The def statement defines the sayHello() function \u278a . The sayHello('Al') line \u278b calls the now-created function, sending the execution to the top of the function\u2019s code. This function call is also known as passing the string value 'Al' to the function. A value being passed to a function in a function call is an argument . The argument 'Al' is assigned to a local variable named name . Variables that have arguments assigned to them are parameters .\n\nIt\u2019s easy to mix up these terms, but keeping them straight will ensure that you know precisely what the text in this chapter means.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "What is 'Return Values and return Statements' and how does it work in Python?", "input": "", "output": "When you call the len() function and pass it an argument such as 'Hello' , the function call evaluates to the integer value 5 , which is the length of the string you passed it. In general, the value that a function call evaluates to is called the return value of the function.\n\nWhen creating a function using the def statement, you can specify what the return value should be with a return statement. A return statement consists of the following:\n\n* The return keyword\n* The value or expression that the function should return\n\nWhen an expression is used with a return statement, the return value is what this expression evaluates to. For example, the following program defines a function that returns a different string depending on what number it is passed as an argument. Enter this code into the file editor and save it as magic8Ball.py :\n\n\u278a import random \u278b def getAnswer(answerNumber): \u278c if answerNumber == 1: return 'It is certain' elif answerNumber == 2: return 'It is decidedly so' elif answerNumber == 3: return 'Yes' elif answerNumber == 4: return 'Reply hazy try again' elif answerNumber == 5: return 'Ask again later' elif answerNumber == 6: return 'Concentrate and ask again' elif answerNumber == 7: return 'My reply is no' elif answerNumber == 8: return 'Outlook not so good' elif answerNumber == 9: return 'Very doubtful' \u278d r = random.randint(1, 9) \u278e fortune = getAnswer(r) \u278f print(fortune)\n\nYou can view the execution of this program at https://autbor.com/magic8ball/ . When this program starts, Python first imports the random module \u278a . Then the getAnswer() function is defined \u278b . Because the function is being defined (and not called), the execution skips over the code in it. Next, the random.randint() function is called with two arguments: 1 and 9 \u278d . It evaluates to a random integer between 1 and 9 (including 1 and 9 themselves), and this value is stored in a variable named r .\n\nThe getAnswer() function is called with r as the argument \u278e . The program execution moves to the top of the getAnswer() function \u278c , and the value r is stored in a parameter named answerNumber . Then, depending on the value in answerNumber , the function returns one of many possible string values. The program execution returns to the line at the bottom of the program that originally called getAnswer() \u278e . The returned string is assigned to a variable named fortune , which then gets passed to a print() call \u278f and is printed to the screen.\n\nNote that since you can pass return values as an argument to another function call, you could shorten these three lines:\n\nr = random.randint(1, 9) fortune = getAnswer(r) print(fortune)\n\nto this single equivalent line:\n\nprint(getAnswer(random.randint(1, 9)))\n\nRemember, expressions are composed of values and operators. A function call can be used in an expression because the call evaluates to its return value.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "How do I use 'The None Value' in Python?", "input": "", "output": "In Python, there is a value called None , which represents the absence of a value. The None value is the only value of the NoneType data type. (Other programming languages might call this value null , nil , or undefined .) Just like the Boolean True and False values, None must be typed with a capital N .\n\nThis value-without-a-value can be helpful when you need to store something that won\u2019t be confused for a real value in a variable. One place where None is used is as the return value of print() . The print() function displays text on the screen, but it doesn\u2019t need to return anything in the same way len() or input() does. But since all function calls need to evaluate to a return value, print() returns None . To see this in action, enter the following into the interactive shell:\n\n>>> spam = print('Hello!') Hello! >>> None == spam True\n\nBehind the scenes, Python adds return None to the end of any function definition with no return statement. This is similar to how a while or for loop implicitly ends with a continue statement. Also, if you use a return statement without a value (that is, just the return keyword by itself), then None is returned.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "Provide a guide on 'Keyword Arguments and the print() Function' in Python.", "input": "", "output": "Most arguments are identified by their position in the function call. For example, random.randint(1, 10) is different from random.randint(10, 1) . The function call random.randint(1, 10) will return a random integer between 1 and 10 because the first argument is the low end of the range and the second argument is the high end (while random.randint(10, 1) causes an error).\n\nHowever, rather than through their position, keyword arguments are identified by the keyword put before them in the function call. Keyword arguments are often used for optional parameters . For example, the print() function has the optional parameters end and sep to specify what should be printed at the end of its arguments and between its arguments (separating them), respectively.\n\nIf you ran a program with the following code:\n\nprint('Hello') print('World')\n\nthe output would look like this:\n\nHello World\n\nThe two outputted strings appear on separate lines because the print() function automatically adds a newline character to the end of the string it is passed. However, you can set the end keyword argument to change the newline character to a different string. For example, if the code were this:\n\nprint('Hello', end='') print('World')\n\nthe output would look like this:\n\nHelloWorld\n\nThe output is printed on a single line because there is no longer a newline printed after 'Hello' . Instead, the blank string is printed. This is useful if you need to disable the newline that gets added to the end of every print() function call.\n\nSimilarly, when you pass multiple string values to print() , the function will automatically separate them with a single space. Enter the following into the interactive shell:\n\n>>> print('cats', 'dogs', 'mice') cats dogs mice\n\nBut you could replace the default separating string by passing the sep keyword argument a different string. Enter the following into the interactive shell:\n\n>>> print('cats', 'dogs', 'mice', sep=',') cats,dogs,mice\n\nYou can add keyword arguments to the functions you write as well, but first you\u2019ll have to learn about the list and dictionary data types in the next two chapters. For now, just know that some functions have optional keyword arguments that can be specified when the function is called.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "What is 'The Call Stack' and how does it work in Python?", "input": "", "output": "Imagine that you have a meandering conversation with someone. You talk about your friend Alice, which then reminds you of a story about your coworker Bob, but first you have to explain something about your cousin Carol. You finish you story about Carol and go back to talking about Bob, and when you finish your story about Bob, you go back to talking about Alice. But then you are reminded about your brother David, so you tell a story about him, and then get back to finishing your original story about Alice. Your conversation followed a stack -like structure, like in Figure 3-1. The conversation is stack-like because the current topic is always at the top of the stack.\n\nFigure 3-1: Your meandering conversation stack\n\nSimilar to our meandering conversation, calling a function doesn\u2019t send the execution on a one-way trip to the top of a function. Python will remember which line of code called the function so that the execution can return there when it encounters a return statement. If that original function called other functions, the execution would return to those function calls first, before returning from the original function call.\n\nOpen a file editor window and enter the following code, saving it as abcdCallStack.py :\n\ndef a(): print('a() starts') \u278a b() \u278b d() print('a() returns') def b(): print('b() starts') \u278c c() print('b() returns') def c(): \u278d print('c() starts') print('c() returns') def d(): print('d() starts') print('d() returns') \u278e a()\n\nIf you run this program, the output will look like this:\n\na() starts b() starts c() starts c() returns b() returns d() starts d() returns a() returns\n\nYou can view the execution of this program at https://autbor.com/abcdcallstack/ . When a() is called \u278e , it calls b() \u278a , which in turn calls c() \u278c . The c() function doesn\u2019t call anything; it just displays c() starts \u278d and c() returns before returning to the line in b() that called it \u278c . Once execution returns to the code in b() that called c() , it returns to the line in a() that called b() \u278a . The execution continues to the next line in the b() function \u278b , which is a call to d() . Like the c() function, the d() function also doesn\u2019t call anything. It just displays d() starts and d() returns before returning to the line in b() that called it. Since b() contains no other code, the execution returns to the line in a() that called b() \u278b . The last line in a() displays a() returns before returning to the original a() call at the end of the program \u278e .\n\nThe call stack is how Python remembers where to return the execution after each function call. The call stack isn\u2019t stored in a variable in your program; rather, Python handles it behind the scenes. When your program calls a function, Python creates a frame object on the top of the call stack. Frame objects store the line number of the original function call so that Python can remember where to return. If another function call is made, Python puts another frame object on the call stack above the other one.\n\nWhen a function call returns, Python removes a frame object from the top of the stack and moves the execution to the line number stored in it. Note that frame objects are always added and removed from the top of the stack and not from any other place. Figure 3-2 illustrates the state of the call stack in abcdCallStack.py as each function is called and returns.\n\nFigure 3-2: The frame objects of the call stack as abcdCallStack.py calls and returns from functions\n\nThe top of the call stack is which function the execution is currently in. When the call stack is empty, the execution is on a line outside of all functions.\n\nThe call stack is a technical detail that you don\u2019t strictly need to know about to write programs. It\u2019s enough to understand that function calls return to the line number they were called from. However, understanding call stacks makes it easier to understand local and global scopes, described in the next section.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "Explain the concept of 'Local and Global Scope' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Parameters and variables that are assigned in a called function are said to exist in that function\u2019s local scope . Variables that are assigned outside all functions are said to exist in the global scope . A variable that exists in a local scope is called a local variable , while a variable that exists in the global scope is called a global variable . A variable must be one or the other; it cannot be both local and global.\n\nThink of a scope as a container for variables. When a scope is destroyed, all the values stored in the scope\u2019s variables are forgotten. There is only one global scope, and it is created when your program begins. When your program terminates, the global scope is destroyed, and all its variables are forgotten. Otherwise, the next time you ran a program, the variables would remember their values from the last time you ran it.\n\nA local scope is created whenever a function is called. Any variables assigned in the function exist within the function\u2019s local scope. When the function returns, the local scope is destroyed, and these variables are forgotten. The next time you call the function, the local variables will not remember the values stored in them from the last time the function was called. Local variables are also stored in frame objects on the call stack.\n\nScopes matter for several reasons:\n\n* Code in the global scope, outside of all functions, cannot use any local variables.\n* However, code in a local scope can access global variables.\n* Code in a function\u2019s local scope cannot use variables in any other local scope.\n* You can use the same name for different variables if they are in different scopes. That is, there can be a local variable named spam and a global variable also named spam .\n\nThe reason Python has different scopes instead of just making everything a global variable is so that when variables are modified by the code in a particular call to a function, the function interacts with the rest of the program only through its parameters and the return value. This narrows down the number of lines of code that may be causing a bug. If your program contained nothing but global variables and had a bug because of a variable being set to a bad value, then it would be hard to track down where this bad value was set. It could have been set from anywhere in the program, and your program could be hundreds or thousands of lines long! But if the bug is caused by a local variable with a bad value, you know that only the code in that one function could have set it incorrectly.\n\nWhile using global variables in small programs is fine, it is a bad habit to rely on global variables as your programs get larger and larger.\n\nConsider this program, which will cause an error when you run it:\n\ndef spam(): \u278a eggs = 31337 spam() print(eggs)\n\nIf you run this program, the output will look like this:\n\nTraceback (most recent call last): File \"C:/test1.py\", line 4, in <module> print(eggs) NameError: name 'eggs' is not defined\n\nThe error happens because the eggs variable exists only in the local scope created when spam() is called \u278a . Once the program execution returns from spam , that local scope is destroyed, and there is no longer a variable named eggs . So when your program tries to run print(eggs) , Python gives you an error saying that eggs is not defined. This makes sense if you think about it; when the program execution is in the global scope, no local scopes exist, so there can\u2019t be any local variables. This is why only global variables can be used in the global scope.\n\nA new local scope is created whenever a function is called, including when a function is called from another function. Consider this program:\n\ndef spam(): \u278a eggs = 99 \u278b bacon() \u278c print(eggs) def bacon(): ham = 101 \u278d eggs = 0 \u278e spam()\n\nYou can view the execution of this program at https://autbor.com/otherlocalscopes/ . When the program starts, the spam() function is called \u278e , and a local scope is created. The local variable eggs \u278a is set to 99 . Then the bacon() function is called \u278b , and a second local scope is created. Multiple local scopes can exist at the same time. In this new local scope, the local variable ham is set to 101 , and a local variable eggs \u2014which is different from the one in spam() \u2019s local scope\u2014is also created \u278d and set to 0 .\n\nWhen bacon() returns, the local scope for that call is destroyed, including its eggs variable. The program execution continues in the spam() function to print the value of eggs \u278c . Since the local scope for the call to spam() still exists, the only eggs variable is the spam() function\u2019s eggs variable, which was set to 99 . This is what the program prints.\n\nThe upshot is that local variables in one function are completely separate from the local variables in another function.\n\nConsider the following program:\n\ndef spam(): print(eggs) eggs = 42 spam() print(eggs)\n\nYou can view the execution of this program at https://autbor.com/readglobal/ . Since there is no parameter named eggs or any code that assigns eggs a value in the spam() function, when eggs is used in spam() , Python considers it a reference to the global variable eggs . This is why 42 is printed when the previous program is run.\n\nTechnically, it\u2019s perfectly acceptable to use the same variable name for a global variable and local variables in different scopes in Python. But, to simplify your life, avoid doing this. To see what happens, enter the following code into the file editor and save it as localGlobalSameName.py :\n\ndef spam(): \u278a eggs = 'spam local' print(eggs)\u00a0\u00a0\u00a0\u00a0# prints 'spam local' def bacon(): \u278b eggs = 'bacon local' print(eggs)\u00a0\u00a0\u00a0\u00a0# prints 'bacon local' spam() print(eggs)\u00a0\u00a0\u00a0\u00a0# prints 'bacon local' \u278c eggs = 'global' bacon() print(eggs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# prints 'global'\n\nWhen you run this program, it outputs the following:\n\nbacon local spam local bacon local global\n\nYou can view the execution of this program at https://autbor.com/localglobalsamename/ . There are actually three different variables in this program, but confusingly they are all named eggs . The variables are as follows:\n\n\u278a A variable named eggs that exists in a local scope when spam() is called.\n\n\u278b A variable named eggs that exists in a local scope when bacon() is called.\n\n\u278c A variable named eggs that exists in the global scope.\n\nSince these three separate variables all have the same name, it can be confusing to keep track of which one is being used at any given time. This is why you should avoid using the same variable name in different scopes.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "Explain the concept of 'The global Statement' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "If you need to modify a global variable from within a function, use the global statement. If you have a line such as global eggs at the top of a function, it tells Python, \u201cIn this function, eggs refers to the global variable, so don\u2019t create a local variable with this name.\u201d For example, enter the following code into the file editor and save it as globalStatement.py :\n\ndef spam(): \u278a global eggs \u278b eggs = 'spam' eggs = 'global' spam() print(eggs)\n\nWhen you run this program, the final print() call will output this:\n\nspam\n\nYou can view the execution of this program at https://autbor.com/globalstatement/ . Because eggs is declared global at the top of spam() \u278a , when eggs is set to 'spam' \u278b , this assignment is done to the globally scoped eggs . No local eggs variable is created.\n\nThere are four rules to tell whether a variable is in a local scope or global scope:\n\n* If a variable is being used in the global scope (that is, outside of all functions), then it is always a global variable.\n* If there is a global statement for that variable in a function, it is a global variable.\n* Otherwise, if the variable is used in an assignment statement in the function, it is a local variable.\n* But if the variable is not used in an assignment statement, it is a global variable.\n\nTo get a better feel for these rules, here\u2019s an example program. Enter the following code into the file editor and save it as sameNameLocalGlobal.py :\n\ndef spam(): \u278a global eggs eggs = 'spam' # this is the global def bacon(): \u278b eggs = 'bacon' # this is a local def ham(): \u278c print(eggs) # this is the global eggs = 42 # this is the global spam() print(eggs)\n\nIn the spam() function, eggs is the global eggs variable because there\u2019s a global statement for eggs at the beginning of the function \u278a . In bacon() , eggs is a local variable because there\u2019s an assignment statement for it in that function \u278b . In ham() \u278c , eggs is the global variable because there is no assignment statement or global statement for it in that function. If you run sameNameLocalGlobal.py , the output will look like this:\n\nspam\n\nYou can view the execution of this program at https://autbor.com/sameNameLocalGlobal/ . In a function, a variable will either always be global or always be local. The code in a function can\u2019t use a local variable named eggs and then use the global eggs variable later in that same function.\n\nIf you try to use a local variable in a function before you assign a value to it, as in the following program, Python will give you an error. To see this, enter the following into the file editor and save it as sameNameError.py :\n\ndef spam(): print(eggs) # ERROR! \u278a eggs = 'spam local' \u278b eggs = 'global' spam()\n\nIf you run the previous program, it produces an error message.\n\nTraceback (most recent call last): File \"C:/sameNameError.py\", line 6, in <module> spam() File \"C:/sameNameError.py\", line 2, in spam print(eggs) # ERROR! UnboundLocalError: local variable 'eggs' referenced before assignment\n\nYou can view the execution of this program at https://autbor.com/sameNameError/ . This error happens because Python sees that there is an assignment statement for eggs in the spam() function \u278a and, therefore, considers eggs to be local. But because print(eggs) is executed before eggs is assigned anything, the local variable eggs doesn\u2019t exist. Python will not fall back to using the global eggs variable \u278b .", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "Provide a guide on 'Exception Handling' in Python.", "input": "", "output": "Right now, getting an error, or exception , in your Python program means the entire program will crash. You don\u2019t want this to happen in real-world programs. Instead, you want the program to detect errors, handle them, and then continue to run.\n\nFor example, consider the following program, which has a divide-by-zero error. Open a file editor window and enter the following code, saving it as zeroDivide.py :\n\ndef spam(divideBy): return 42 / divideBy print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))\n\nWe\u2019ve defined a function called spam , given it a parameter, and then printed the value of that function with various parameters to see what happens. This is the output you get when you run the previous code:\n\n21.0 3.5 Traceback (most recent call last): File \"C:/zeroDivide.py\", line 6, in <module> print(spam(0)) File \"C:/zeroDivide.py\", line 2, in spam return 42 / divideBy ZeroDivisionError: division by zero\n\nYou can view the execution of this program at https://autbor.com/zerodivide/ . A ZeroDivisionError happens whenever you try to divide a number by zero. From the line number given in the error message, you know that the return statement in spam() is causing an error.\n\nErrors can be handled with try and except statements. The code that could potentially have an error is put in a try clause. The program execution moves to the start of a following except clause if an error happens.\n\nYou can put the previous divide-by-zero code in a try clause and have an except clause contain code to handle what happens when this error occurs.\n\ndef spam(divideBy): try: return 42 / divideBy except ZeroDivisionError: print('Error: Invalid argument.') print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1))\n\nWhen code in a try clause causes an error, the program execution immediately moves to the code in the except clause. After running that code, the execution continues as normal. The output of the previous program is as follows:\n\n21.0 3.5 Error: Invalid argument. None 42.0\n\nYou can view the execution of this program at https://autbor.com/tryexceptzerodivide/ . Note that any errors that occur in function calls in a try block will also be caught. Consider the following program, which instead has the spam() calls in the try block:\n\ndef spam(divideBy): return 42 / divideBy try: print(spam(2)) print(spam(12)) print(spam(0)) print(spam(1)) except ZeroDivisionError: print('Error: Invalid argument.')\n\nWhen this program is run, the output looks like this:\n\n21.0 3.5 Error: Invalid argument.\n\nYou can view the execution of this program at https://autbor.com/spamintry/ . The reason print(spam(1)) is never executed is because once the execution jumps to the code in the except clause, it does not return to the try clause. Instead, it just continues moving down the program as normal.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "How do I use 'A Short Program: Zigzag' in Python?", "input": "", "output": "Let\u2019s use the programming concepts you\u2019ve learned so far to create a small animation program. This program will create a back-and-forth, zigzag pattern until the user stops it by pressing the Mu editor\u2019s Stop button or by pressing CTRL-C . When you run this program, the output will look something like this:\n\n******** ******** ******** ******** ******** ******** ******** ******** ********\n\nType the following source code into the file editor, and save the file as zigzag.py :\n\nimport time, sys indent = 0 # How many spaces to indent. indentIncreasing = True # Whether the indentation is increasing or not. try: while True: # The main program loop. print(' ' * indent, end='') print('********') time.sleep(0.1) # Pause for 1/10 of a second. if indentIncreasing: # Increase the number of spaces: indent = indent + 1 if indent == 20: # Change direction: indentIncreasing = False else: # Decrease the number of spaces: indent = indent - 1 if indent == 0: # Change direction: indentIncreasing = True except KeyboardInterrupt: sys.exit()\n\nLet\u2019s look at this code line by line, starting at the top.\n\nimport time, sys indent = 0 # How many spaces to indent. indentIncreasing = True # Whether the indentation is increasing or not.\n\nFirst, we\u2019ll import the time and sys modules. Our program uses two variables: the indent variable keeps track of how many spaces of indentation are before the band of eight asterisks and indentIncreasing contains a Boolean value to determine if the amount of indentation is increasing or decreasing.\n\ntry: while True: # The main program loop. print(' ' * indent, end='') print('********') time.sleep(0.1) # Pause for 1/10 of a second.\n\nNext, we place the rest of the program inside a try statement. When the user presses CTRL-C while a Python program is running, Python raises the KeyboardInterrupt exception. If there is no try - except statement to catch this exception, the program crashes with an ugly error message. However, for our program, we want it to cleanly handle the KeyboardInterrupt exception by calling sys.exit() . (The code for this is in the except statement at the end of the program.)\n\nThe while True: infinite loop will repeat the instructions in our program forever. This involves using ' ' * indent to print the correct amount of spaces of indentation. We don\u2019t want to automatically print a newline after these spaces, so we also pass end='' to the first print() call. A second print() call prints the band of asterisks. The time.sleep() function hasn\u2019t been covered yet, but suffice it to say that it introduces a one-tenth-second pause in our program at this point.\n\nif indentIncreasing: # Increase the number of spaces: indent = indent + 1 if indent == 20: indentIncreasing = False # Change direction.\n\nNext, we want to adjust the amount of indentation for the next time we print asterisks. If indentIncreasing is True , then we want to add one to indent . But once indent reaches 20 , we want the indentation to decrease.\n\nelse: # Decrease the number of spaces: indent = indent - 1 if indent == 0: indentIncreasing = True # Change direction.\n\nMeanwhile, if indentIncreasing was False , we want to subtract one from indent . Once indent reaches 0 , we want the indentation to increase once again. Either way, the program execution will jump back to the start of the main program loop to print the asterisks again.\n\nexcept KeyboardInterrupt: sys.exit()\n\nIf the user presses CTRL-C at any point that the program execution is in the try block, the KeyboardInterrrupt exception is raised and handled by this except statement. The program execution moves inside the except block, which runs sys.exit() and quits the program. This way, even though the main program loop is an infinite loop, the user has a way to shut down the program.", "source": "https://automatetheboringstuff.com/2e/chapter3/", "category": "3FUNCTIONS"}
{"instruction": "What is '4LISTS' and how does it work in Python?", "input": "", "output": "One more topic you\u2019ll need to understand before you can begin writing programs in earnest is the list data type and its cousin, the tuple. Lists and tuples can contain multiple values, which makes writing programs that handle large amounts of data easier. And since lists themselves can contain other lists, you can use them to arrange data into hierarchical structures.\n\nIn this chapter, I\u2019ll discuss the basics of lists. I\u2019ll also teach you about methods, which are functions that are tied to values of a certain data type. Then I\u2019ll briefly cover the sequence data types (lists, tuples, and strings) and show how they compare with each other. In the next chapter, I\u2019ll introduce you to the dictionary data type.", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "What is 'The List Data Type' and how does it work in Python?", "input": "", "output": "A list is a value that contains multiple values in an ordered sequence. The term list value refers to the list itself (which is a value that can be stored in a variable or passed to a function like any other value), not the values inside the list value. A list value looks like this: ['cat', 'bat', 'rat', 'elephant'] . Just as string values are typed with quote characters to mark where the string begins and ends, a list begins with an opening square bracket and ends with a closing square bracket, [] . Values inside the list are also called items . Items are separated with commas (that is, they are comma-delimited ). For example, enter the following into the interactive shell:\n\n>>> [1, 2, 3] [1, 2, 3] >>> ['cat', 'bat', 'rat', 'elephant'] ['cat', 'bat', 'rat', 'elephant'] >>> ['hello', 3.1415, True, None, 42] ['hello', 3.1415, True, None, 42] \u278a >>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam ['cat', 'bat', 'rat', 'elephant']\n\nThe spam variable \u278a is still assigned only one value: the list value. But the list value itself contains other values. The value [] is an empty list that contains no values, similar to '' , the empty string.\n\nSay you have the list ['cat', 'bat', 'rat', 'elephant'] stored in a variable named spam . The Python code spam[0] would evaluate to 'cat' , and spam[1] would evaluate to 'bat' , and so on. The integer inside the square brackets that follows the list is called an index . The first value in the list is at index 0 , the second value is at index 1 , the third value is at index 2 , and so on. Figure 4-1 shows a list value assigned to spam , along with what the index expressions would evaluate to. Note that because the first index is 0 , the last index is one less than the size of the list; a list of four items has 3 as its last index.\n\nFigure 4-1: A list value stored in the variable spam , showing which value each index refers to\n\nFor example, enter the following expressions into the interactive shell. Start by assigning a list to the variable spam .\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[0] 'cat' >>> spam[1] 'bat' >>> spam[2] 'rat' >>> spam[3] 'elephant' >>> ['cat', 'bat', 'rat', 'elephant'][3] 'elephant' \u278a >>> 'Hello, ' + spam[0] \u278b 'Hello, cat' >>> 'The ' + spam[1] + ' ate the ' + spam[0] + '.' 'The bat ate the cat.'\n\nNotice that the expression 'Hello, ' + spam[0] \u278a evaluates to 'Hello, ' + 'cat' because spam[0] evaluates to the string 'cat' . This expression in turn evaluates to the string value 'Hello, cat' \u278b .\n\nPython will give you an IndexError error message if you use an index that exceeds the number of values in your list value.\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[10000] Traceback (most recent call last): File \"<pyshell#9>\", line 1, in <module> spam[10000] IndexError: list index out of range\n\nIndexes can be only integer values, not floats. The following example will cause a TypeError error:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[1] 'bat' >>> spam[1.0] Traceback (most recent call last): File \"<pyshell#13>\", line 1, in <module> spam[1.0] TypeError: list indices must be integers or slices, not float >>> spam[int(1.0)] 'bat'\n\nLists can also contain other list values. The values in these lists of lists can be accessed using multiple indexes, like so:\n\n>>> spam = [['cat', 'bat'], [10, 20, 30, 40, 50]] >>> spam[0] ['cat', 'bat'] >>> spam[0][1] 'bat' >>> spam[1][4] 50\n\nThe first index dictates which list value to use, and the second indicates the value within the list value. For example, spam[0][1] prints 'bat' , the second value in the first list. If you only use one index, the program will print the full list value at that index.\n\nWhile indexes start at 0 and go up, you can also use negative integers for the index. The integer value -1 refers to the last index in a list, the value -2 refers to the second-to-last index in a list, and so on. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[-1] 'elephant' >>> spam[-3] 'bat' >>> 'The ' + spam[-1] + ' is afraid of the ' + spam[-3] + '.' 'The elephant is afraid of the bat.'\n\nJust as an index can get a single value from a list, a slice can get several values from a list, in the form of a new list. A slice is typed between square brackets, like an index, but it has two integers separated by a colon. Notice the difference between indexes and slices.\n\n* spam[2] is a list with an index (one integer).\n* spam[1:4] is a list with a slice (two integers).\n\nIn a slice, the first integer is the index where the slice starts. The second integer is the index where the slice ends. A slice goes up to, but will not include, the value at the second index. A slice evaluates to a new list value. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[0:4] ['cat', 'bat', 'rat', 'elephant'] >>> spam[1:3] ['bat', 'rat'] >>> spam[0:-1] ['cat', 'bat', 'rat']\n\nAs a shortcut, you can leave out one or both of the indexes on either side of the colon in the slice. Leaving out the first index is the same as using 0 , or the beginning of the list. Leaving out the second index is the same as using the length of the list, which will slice to the end of the list. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[:2] ['cat', 'bat'] >>> spam[1:] ['bat', 'rat', 'elephant'] >>> spam[:] ['cat', 'bat', 'rat', 'elephant']\n\nThe len() function will return the number of values that are in a list value passed to it, just like it can count the number of characters in a string value. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'dog', 'moose'] >>> len(spam) 3\n\nNormally, a variable name goes on the left side of an assignment statement, like spam = 42 . However, you can also use an index of a list to change the value at that index. For example, spam[1] = 'aardvark' means \u201cAssign the value at index 1 in the list spam to the string 'aardvark' .\u201d Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam[1] = 'aardvark' >>> spam ['cat', 'aardvark', 'rat', 'elephant'] >>> spam[2] = spam[1] >>> spam ['cat', 'aardvark', 'aardvark', 'elephant'] >>> spam[-1] = 12345 >>> spam ['cat', 'aardvark', 'aardvark', 12345]\n\nLists can be concatenated and replicated just like strings. The + operator combines two lists to create a new list value and the * operator can be used with a list and an integer value to replicate the list. Enter the following into the interactive shell:\n\n>>> [1, 2, 3] + ['A', 'B', 'C'] [1, 2, 3, 'A', 'B', 'C'] >>> ['X', 'Y', 'Z'] * 3 ['X', 'Y', 'Z', 'X', 'Y', 'Z', 'X', 'Y', 'Z'] >>> spam = [1, 2, 3] >>> spam = spam + ['A', 'B', 'C'] >>> spam [1, 2, 3, 'A', 'B', 'C']\n\nThe del statement will delete values at an index in a list. All of the values in the list after the deleted value will be moved up one index. For example, enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> del spam[2] >>> spam ['cat', 'bat', 'elephant'] >>> del spam[2] >>> spam ['cat', 'bat']\n\nThe del statement can also be used on a simple variable to delete it, as if it were an \u201cunassignment\u201d statement. If you try to use the variable after deleting it, you will get a NameError error because the variable no longer exists. In practice, you almost never need to delete simple variables. The del statement is mostly used to delete values from lists.", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "Explain the concept of 'Working with Lists' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "When you first begin writing programs, it\u2019s tempting to create many individual variables to store a group of similar values. For example, if I wanted to store the names of my cats, I might be tempted to write code like this:\n\ncatName1 = 'Zophie' catName2 = 'Pooka' catName3 = 'Simon' catName4 = 'Lady Macbeth' catName5 = 'Fat-tail' catName6 = 'Miss Cleo'\n\nIt turns out that this is a bad way to write code. (Also, I don\u2019t actually own this many cats, I swear.) For one thing, if the number of cats changes, your program will never be able to store more cats than you have variables. These types of programs also have a lot of duplicate or nearly identical code in them. Consider how much duplicate code is in the following program, which you should enter into the file editor and save as allMyCats1.py :\n\nprint('Enter the name of cat 1:') catName1 = input() print('Enter the name of cat 2:') catName2 = input() print('Enter the name of cat 3:') catName3 = input() print('Enter the name of cat 4:') catName4 = input() print('Enter the name of cat 5:') catName5 = input() print('Enter the name of cat 6:') catName6 = input() print('The cat names are:') print(catName1 + ' ' + catName2 + ' ' + catName3 + ' ' + catName4 + ' ' + catName5 + ' ' + catName6)\n\nInstead of using multiple, repetitive variables, you can use a single variable that contains a list value. For example, here\u2019s a new and improved version of the allMyCats1.py program. This new version uses a single list and can store any number of cats that the user types in. In a new file editor window, enter the following source code and save it as allMyCats2.py :\n\ncatNames = [] while True: print('Enter the name of cat ' + str(len(catNames) + 1) + ' (Or enter nothing to stop.):') name = input() if name == '': break catNames = catNames + [name]\u00a0\u00a0# list concatenation print('The cat names are:') for name in catNames: print('\u00a0\u00a0' + name)\n\nWhen you run this program, the output will look something like this:\n\nEnter the name of cat 1 (Or enter nothing to stop.): Zophie Enter the name of cat 2 (Or enter nothing to stop.): Pooka Enter the name of cat 3 (Or enter nothing to stop.): Simon Enter the name of cat 4 (Or enter nothing to stop.): Lady Macbeth Enter the name of cat 5 (Or enter nothing to stop.): Fat-tail Enter the name of cat 6 (Or enter nothing to stop.): Miss Cleo Enter the name of cat 7 (Or enter nothing to stop.): The cat names are: Zophie Pooka Simon Lady Macbeth Fat-tail Miss Cleo\n\nYou can view the execution of these programs at https://autbor.com/allmycats1/ and https://autbor.com/allmycats2/ . The benefit of using a list is that your data is now in a structure, so your program is much more flexible in processing the data than it would be with several repetitive variables.\n\nIn Chapter 2, you learned about using for loops to execute a block of code a certain number of times. Technically, a for loop repeats the code block once for each item in a list value. For example, if you ran this code:\n\nfor i in range(4): print(i)\n\nthe output of this program would be as follows:\n\n0 1 2 3\n\nThis is because the return value from range(4) is a sequence value that Python considers similar to [0, 1, 2, 3] . (Sequences are described in \u201cSequence Data Types\u201d on page 93.) The following program has the same output as the previous one:\n\nfor i in [0, 1, 2, 3]: print(i)\n\nThe previous for loop actually loops through its clause with the variable i set to a successive value in the [0, 1, 2, 3] list in each iteration.\n\nA common Python technique is to use range(len( someList )) with a for loop to iterate over the indexes of a list. For example, enter the following into the interactive shell:\n\n>>> supplies = ['pens', 'staplers', 'flamethrowers', 'binders'] >>> for i in range(len(supplies)): ... print('Index ' + str(i) + ' in supplies is: ' + supplies[i]) Index 0 in supplies is: pens Index 1 in supplies is: staplers Index 2 in supplies is: flamethrowers Index 3 in supplies is: binders\n\nUsing range(len(supplies)) in the previously shown for loop is handy because the code in the loop can access the index (as the variable i ) and the value at that index (as supplies[i] ). Best of all, range(len(supplies)) will iterate through all the indexes of supplies , no matter how many items it contains.\n\nYou can determine whether a value is or isn\u2019t in a list with the in and not in operators. Like other operators, in and not in are used in expressions and connect two values: a value to look for in a list and the list where it may be found. These expressions will evaluate to a Boolean value. Enter the following into the interactive shell:\n\n>>> 'howdy' in ['hello', 'hi', 'howdy', 'heyas'] True >>> spam = ['hello', 'hi', 'howdy', 'heyas'] >>> 'cat' in spam False >>> 'howdy' not in spam False >>> 'cat' not in spam True\n\nFor example, the following program lets the user type in a pet name and then checks to see whether the name is in a list of pets. Open a new file editor window, enter the following code, and save it as myPets.py :\n\nmyPets = ['Zophie', 'Pooka', 'Fat-tail'] print('Enter a pet name:') name = input() if name not in myPets: print('I do not have a pet named ' + name) else: print(name + ' is my pet.')\n\nThe output may look something like this:\n\nEnter a pet name: Footfoot I do not have a pet named Footfoot\n\nYou can view the execution of this program at https://autbor.com/mypets/ .\n\nThe multiple assignment trick (technically called tuple unpacking ) is a shortcut that lets you assign multiple variables with the values in a list in one line of code. So instead of doing this:\n\n>>> cat = ['fat', 'gray', 'loud'] >>> size = cat[0] >>> color = cat[1] >>> disposition = cat[2]\n\nyou could type this line of code:\n\n>>> cat = ['fat', 'gray', 'loud'] >>> size, color, disposition = cat\n\nThe number of variables and the length of the list must be exactly equal, or Python will give you a ValueError :\n\n>>> cat = ['fat', 'gray', 'loud'] >>> size, color, disposition, name = cat Traceback (most recent call last): File \"<pyshell#84>\", line 1, in <module> size, color, disposition, name = cat ValueError: not enough values to unpack (expected 4, got 3)\n\nInstead of using the range(len( someList )) technique with a for loop to obtain the integer index of the items in the list, you can call the enumerate() function instead. On each iteration of the loop, enumerate() will return two values: the index of the item in the list, and the item in the list itself. For example, this code is equivalent to the code in the \u201cUsing for Loops with Lists\u201d on page 84:\n\n>>> supplies = ['pens', 'staplers', 'flamethrowers', 'binders'] >>> for index, item in enumerate(supplies): ... print('Index ' + str(index) + ' in supplies is: ' + item) Index 0 in supplies is: pens Index 1 in supplies is: staplers Index 2 in supplies is: flamethrowers Index 3 in supplies is: binders\n\nThe enumerate() function is useful if you need both the item and the item\u2019s index in the loop\u2019s block.\n\nThe random module has a couple functions that accept lists for arguments. The random.choice() function will return a randomly selected item from the list. Enter the following into the interactive shell:\n\n>>> import random >>> pets = ['Dog', 'Cat', 'Moose'] >>> random.choice(pets) 'Dog' >>> random.choice(pets) 'Cat' >>> random.choice(pets) 'Cat'\n\nYou can consider random.choice(someList) to be a shorter form of someList[random.randint(0, len(someList) \u2013 1] .\n\nThe random.shuffle() function will reorder the items in a list. This function modifies the list in place, rather than returning a new list. Enter the following into the interactive shell:\n\n>>> import random >>> people = ['Alice', 'Bob', 'Carol', 'David'] >>> random.shuffle(people) >>> people ['Carol', 'David', 'Alice', 'Bob'] >>> random.shuffle(people) >>> people ['Alice', 'David', 'Bob', 'Carol']", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "How do I use 'Augmented Assignment Operators' in Python?", "input": "", "output": "When assigning a value to a variable, you will frequently use the variable itself. For example, after assigning 42 to the variable spam , you would increase the value in spam by 1 with the following code:\n\n>>> spam = 42 >>> spam = spam + 1 >>> spam 43\n\nAs a shortcut, you can use the augmented assignment operator += to do the same thing:\n\n>>> spam = 42 >>> spam += 1 >>> spam 43\n\nThere are augmented assignment operators for the + , - , * , / , and % operators, described in Table 4-1.\n\nTable 4-1: The Augmented Assignment Operators\n\nThe += operator can also do string and list concatenation, and the *= operator can do string and list replication. Enter the following into the interactive shell:\n\n>>> spam = 'Hello,' >>> spam += ' world!' >>> spam 'Hello world!' >>> bacon = ['Zophie'] >>> bacon *= 3 >>> bacon ['Zophie', 'Zophie', 'Zophie']", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "Explain the concept of 'Methods' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "A method is the same thing as a function, except it is \u201ccalled on\u201d a value. For example, if a list value were stored in spam , you would call the index() list method (which I\u2019ll explain shortly) on that list like so: spam.index('hello') . The method part comes after the value, separated by a period.\n\nEach data type has its own set of methods. The list data type, for example, has several useful methods for finding, adding, removing, and otherwise manipulating values in a list.\n\nList values have an index() method that can be passed a value, and if that value exists in the list, the index of the value is returned. If the value isn\u2019t in the list, then Python produces a ValueError error. Enter the following into the interactive shell:\n\n>>> spam = ['hello', 'hi', 'howdy', 'heyas'] >>> spam.index('hello') 0 >>> spam.index('heyas') 3 >>> spam.index('howdy howdy howdy') Traceback (most recent call last): File \"<pyshell#31>\", line 1, in <module> spam.index('howdy howdy howdy') ValueError: 'howdy howdy howdy' is not in list\n\nWhen there are duplicates of the value in the list, the index of its first appearance is returned. Enter the following into the interactive shell, and notice that index() returns 1 , not 3 :\n\n>>> spam = ['Zophie', 'Pooka', 'Fat-tail', 'Pooka'] >>> spam.index('Pooka') 1\n\nTo add new values to a list, use the append() and insert() methods. Enter the following into the interactive shell to call the append() method on a list value stored in the variable spam :\n\n>>> spam = ['cat', 'dog', 'bat'] >>> spam.append('moose') >>> spam ['cat', 'dog', 'bat', 'moose']\n\nThe previous append() method call adds the argument to the end of the list. The insert() method can insert a value at any index in the list. The first argument to insert() is the index for the new value, and the second argument is the new value to be inserted. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'dog', 'bat'] >>> spam.insert(1, 'chicken' ) >>> spam ['cat', 'chicken', 'dog', 'bat']\n\nNotice that the code is spam.append('moose') and spam.insert(1, 'chicken') , not spam = spam.append('moose') and spam = spam.insert(1, 'chicken') . Neither append() nor insert() gives the new value of spam as its return value. (In fact, the return value of append() and insert() is None , so you definitely wouldn\u2019t want to store this as the new variable value.) Rather, the list is modified in place . Modifying a list in place is covered in more detail later in \u201cMutable and Immutable Data Types\u201d on page 94.\n\nMethods belong to a single data type. The append() and insert() methods are list methods and can be called only on list values, not on other values such as strings or integers. Enter the following into the interactive shell, and note the AttributeError error messages that show up:\n\n>>> eggs = 'hello' >>> eggs.append('world') Traceback (most recent call last): File \"<pyshell#19>\", line 1, in <module> eggs.append('world') AttributeError: 'str' object has no attribute 'append' >>> bacon = 42 >>> bacon.insert(1, 'world') Traceback (most recent call last): File \"<pyshell#22>\", line 1, in <module> bacon.insert(1, 'world') AttributeError: 'int' object has no attribute 'insert'\n\nThe remove() method is passed the value to be removed from the list it is called on. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam.remove('bat') >>> spam ['cat', 'rat', 'elephant']\n\nAttempting to delete a value that does not exist in the list will result in a ValueError error. For example, enter the following into the interactive shell and notice the error that is displayed:\n\n>>> spam = ['cat', 'bat', 'rat', 'elephant'] >>> spam.remove('chicken') Traceback (most recent call last): File \"<pyshell#11>\", line 1, in <module> spam.remove('chicken') ValueError: list.remove(x): x not in list\n\nIf the value appears multiple times in the list, only the first instance of the value will be removed. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'bat', 'rat', 'cat', 'hat', 'cat'] >>> spam.remove('cat') >>> spam ['bat', 'rat', 'cat', 'hat', 'cat']\n\nThe del statement is good to use when you know the index of the value you want to remove from the list. The remove() method is useful when you know the value you want to remove from the list.\n\nLists of number values or lists of strings can be sorted with the sort() method. For example, enter the following into the interactive shell:\n\n>>> spam = [2, 5, 3.14, 1, -7] >>> spam.sort() >>> spam [-7, 1, 2, 3.14, 5] >>> spam = ['ants', 'cats', 'dogs', 'badgers', 'elephants'] >>> spam.sort() >>> spam ['ants', 'badgers', 'cats', 'dogs', 'elephants']\n\nYou can also pass True for the reverse keyword argument to have sort() sort the values in reverse order. Enter the following into the interactive shell:\n\n>>> spam.sort(reverse=True) >>> spam ['elephants', 'dogs', 'cats', 'badgers', 'ants']\n\nThere are three things you should note about the sort() method. First, the sort() method sorts the list in place; don\u2019t try to capture the return value by writing code like spam = spam.sort() .\n\nSecond, you cannot sort lists that have both number values and string values in them, since Python doesn\u2019t know how to compare these values. Enter the following into the interactive shell and notice the TypeError error:\n\n>>> spam = [1, 3, 2, 4, 'Alice', 'Bob'] >>> spam.sort() Traceback (most recent call last): File \"<pyshell#70>\", line 1, in <module> spam.sort() TypeError: '<' not supported between instances of 'str' and 'int'\n\nThird, sort() uses \u201cASCIIbetical order\u201d rather than actual alphabetical order for sorting strings. This means uppercase letters come before lowercase letters. Therefore, the lowercase a is sorted so that it comes after the uppercase Z . For an example, enter the following into the interactive shell:\n\n>>> spam = ['Alice', 'ants', 'Bob', 'badgers', 'Carol', 'cats'] >>> spam.sort() >>> spam ['Alice', 'Bob', 'Carol', 'ants', 'badgers', 'cats']\n\nIf you need to sort the values in regular alphabetical order, pass str.lower for the key keyword argument in the sort() method call.\n\n>>> spam = ['a', 'z', 'A', 'Z'] >>> spam.sort(key=str.lower) >>> spam ['a', 'A', 'z', 'Z']\n\nThis causes the sort() function to treat all the items in the list as if they were lowercase without actually changing the values in the list.\n\nIf you need to quickly reverse the order of the items in a list, you can call the reverse() list method. Enter the following into the interactive shell:\n\n>>> spam = ['cat', 'dog', 'moose'] >>> spam.reverse() >>> spam ['moose', 'dog', 'cat']\n\nLike the sort() list method, reverse() doesn\u2019t return a list. This is why you write spam.reverse() , instead of spam = spam.reverse() .", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "Provide a guide on 'Example Program: Magic 8 Ball with a List' in Python.", "input": "", "output": "Using lists, you can write a much more elegant version of the previous chapter\u2019s Magic 8 Ball program. Instead of several lines of nearly identical elif statements, you can create a single list that the code works with. Open a new file editor window and enter the following code. Save it as magic8Ball2.py .\n\nimport random messages = ['It is certain', 'It is decidedly so', 'Yes definitely', 'Reply hazy try again', 'Ask again later', 'Concentrate and ask again', 'My reply is no', 'Outlook not so good', 'Very doubtful'] print(messages[random.randint(0, len(messages) - 1)])\n\nYou can view the execution of this program at https://autbor.com/magic8ball2/ .\n\nWhen you run this program, you\u2019ll see that it works the same as the previous magic8Ball.py program.\n\nNotice the expression you use as the index for messages : random.randint (0, len(messages) - 1) . This produces a random number to use for the index, regardless of the size of messages . That is, you\u2019ll get a random number between 0 and the value of len(messages) - 1 . The benefit of this approach is that you can easily add and remove strings to the messages list without changing other lines of code. If you later update your code, there will be fewer lines you have to change and fewer chances for you to introduce bugs.", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "Explain the concept of 'Sequence Data Types' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Lists aren\u2019t the only data types that represent ordered sequences of values. For example, strings and lists are actually similar if you consider a string to be a \u201clist\u201d of single text characters. The Python sequence data types include lists, strings, range objects returned by range() , and tuples (explained in the \u201cThe Tuple Data Type\u201d on page 96). Many of the things you can do with lists can also be done with strings and other values of sequence types: indexing; slicing; and using them with for loops, with len() , and with the in and not in operators. To see this, enter the following into the interactive shell:\n\n>>> name = 'Zophie' >>> name[0] 'Z' >>> name[-2] 'i' >>> name[0:4] 'Zoph' >>> 'Zo' in name True >>> 'z' in name False >>> 'p' not in name False >>> for i in name: ... print('* * * ' + i + ' * * *') * * * Z * * * * * * o * * * * * * p * * * * * * h * * * * * * i * * * * * * e * * *\n\nBut lists and strings are different in an important way. A list value is a mutable data type: it can have values added, removed, or changed. However, a string is immutable : it cannot be changed. Trying to reassign a single character in a string results in a TypeError error, as you can see by entering the following into the interactive shell:\n\n>>> name = 'Zophie a cat' >>> name[7] = 'the' Traceback (most recent call last): File \"<pyshell#50>\", line 1, in <module> name[7] = 'the' TypeError: 'str' object does not support item assignment\n\nThe proper way to \u201cmutate\u201d a string is to use slicing and concatenation to build a new string by copying from parts of the old string. Enter the following into the interactive shell:\n\n>>> name = 'Zophie a cat' >>> newName = name[0:7] + 'the' + name[8:12] >>> name 'Zophie a cat' >>> newName 'Zophie the cat'\n\nWe used [0:7] and [8:12] to refer to the characters that we don\u2019t wish to replace. Notice that the original 'Zophie a cat' string is not modified, because strings are immutable.\n\nAlthough a list value is mutable, the second line in the following code does not modify the list eggs :\n\n>>> eggs = [1, 2, 3] >>> eggs = [4, 5, 6] >>> eggs [4, 5, 6]\n\nThe list value in eggs isn\u2019t being changed here; rather, an entirely new and different list value ( [4, 5, 6] ) is overwriting the old list value ( [1, 2, 3] ). This is depicted in Figure 4-2.\n\nIf you wanted to actually modify the original list in eggs to contain [4, 5, 6] , you would have to do something like this:\n\n>>> eggs = [1, 2, 3] >>> del eggs[2] >>> del eggs[1] >>> del eggs[0] >>> eggs.append(4) >>> eggs.append(5) >>> eggs.append(6) >>> eggs [4, 5, 6]\n\nFigure 4-2: When eggs = [4, 5, 6] is executed, the contents of eggs are replaced with a new list value.\n\nIn the first example, the list value that eggs ends up with is the same list value it started with. It\u2019s just that this list has been changed, rather than overwritten. Figure 4-3 depicts the seven changes made by the first seven lines in the previous interactive shell example.\n\nFigure 4-3: The del statement and the append() method modify the same list value in place.\n\nChanging a value of a mutable data type (like what the del statement and append() method do in the previous example) changes the value in place, since the variable\u2019s value is not replaced with a new list value.\n\nMutable versus immutable types may seem like a meaningless distinction, but \u201cPassing References\u201d on page 100 will explain the different behavior when calling functions with mutable arguments versus immutable arguments. But first, let\u2019s find out about the tuple data type, which is an immutable form of the list data type.\n\nThe tuple data type is almost identical to the list data type, except in two ways. First, tuples are typed with parentheses, ( and ) , instead of square brackets, [ and ] . For example, enter the following into the interactive shell:\n\n>>> eggs = ('hello', 42, 0.5) >>> eggs[0] 'hello' >>> eggs[1:3] (42, 0.5) >>> len(eggs) 3\n\nBut the main way that tuples are different from lists is that tuples, like strings, are immutable. Tuples cannot have their values modified, appended, or removed. Enter the following into the interactive shell, and look at the TypeError error message:\n\n>>> eggs = ('hello', 42, 0.5) >>> eggs[1] = 99 Traceback (most recent call last): File \"<pyshell#5>\", line 1, in <module> eggs[1] = 99 TypeError: 'tuple' object does not support item assignment\n\nIf you have only one value in your tuple, you can indicate this by placing a trailing comma after the value inside the parentheses. Otherwise, Python will think you\u2019ve just typed a value inside regular parentheses. The comma is what lets Python know this is a tuple value. (Unlike some other programming languages, it\u2019s fine to have a trailing comma after the last item in a list or tuple in Python.) Enter the following type() function calls into the interactive shell to see the distinction:\n\n>>> type(('hello',)) <class 'tuple'> >>> type(('hello')) <class 'str'>\n\nYou can use tuples to convey to anyone reading your code that you don\u2019t intend for that sequence of values to change. If you need an ordered sequence of values that never changes, use a tuple. A second benefit of using tuples instead of lists is that, because they are immutable and their contents don\u2019t change, Python can implement some optimizations that make code using tuples slightly faster than code using lists.\n\nJust like how str(42) will return '42' , the string representation of the integer 42 , the functions list() and tuple() will return list and tuple versions of the values passed to them. Enter the following into the interactive shell, and notice that the return value is of a different data type than the value passed:\n\n>>> tuple(['cat', 'dog', 5]) ('cat', 'dog', 5) >>> list(('cat', 'dog', 5)) ['cat', 'dog', 5] >>> list('hello') ['h', 'e', 'l', 'l', 'o']\n\nConverting a tuple to a list is handy if you need a mutable version of a tuple value.", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "Explain the concept of 'References' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "As you\u2019ve seen, variables \u201cstore\u201d strings and integer values. However, this explanation is a simplification of what Python is actually doing. Technically, variables are storing references to the computer memory locations where the values are stored. Enter the following into the interactive shell:\n\n>>> spam = 42 >>> cheese = spam >>> spam = 100 >>> spam 100 >>> cheese 42\n\nWhen you assign 42 to the spam variable, you are actually creating the 42 value in the computer\u2019s memory and storing a reference to it in the spam variable. When you copy the value in spam and assign it to the variable cheese , you are actually copying the reference. Both the spam and cheese variables refer to the 42 value in the computer\u2019s memory. When you later change the value in spam to 100 , you\u2019re creating a new 100 value and storing a reference to it in spam . This doesn\u2019t affect the value in cheese . Integers are immutable values that don\u2019t change; changing the spam variable is actually making it refer to a completely different value in memory.\n\nBut lists don\u2019t work this way, because list values can change; that is, lists are mutable . Here is some code that will make this distinction easier to understand. Enter this into the interactive shell:\n\n\u278a >>> spam = [0, 1, 2, 3, 4, 5] \u278b >>> cheese = spam # The reference is being copied, not the list. \u278c >>> cheese[1] = 'Hello!' # This changes the list value. >>> spam [0, 'Hello!', 2, 3, 4, 5] >>> cheese # The cheese variable refers to the same list. [0, 'Hello!', 2, 3, 4, 5]\n\nThis might look odd to you. The code touched only the cheese list, but it seems that both the cheese and spam lists have changed.\n\nWhen you create the list \u278a , you assign a reference to it in the spam variable. But the next line \u278b copies only the list reference in spam to cheese , not the list value itself. This means the values stored in spam and cheese now both refer to the same list. There is only one underlying list because the list itself was never actually copied. So when you modify the first element of cheese \u278c , you are modifying the same list that spam refers to.\n\nRemember that variables are like boxes that contain values. The previous figures in this chapter show that lists in boxes aren\u2019t exactly accurate, because list variables don\u2019t actually contain lists\u2014they contain references to lists. (These references will have ID numbers that Python uses internally, but you can ignore them.) Using boxes as a metaphor for variables, Figure 4-4 shows what happens when a list is assigned to the spam variable.\n\nFigure 4-4: spam = [0, 1, 2, 3, 4, 5] stores a reference to a list, not the actual list.\n\nThen, in Figure 4-5, the reference in spam is copied to cheese . Only a new reference was created and stored in cheese , not a new list. Note how both references refer to the same list.\n\nFigure 4-5: spam = cheese copies the reference, not the list.\n\nWhen you alter the list that cheese refers to, the list that spam refers to is also changed, because both cheese and spam refer to the same list. You can see this in Figure 4-6.\n\nFigure 4-6: cheese[1] = 'Hello!' modifies the list that both variables refer to.\n\nAlthough Python variables technically contain references to values, people often casually say that the variable contains the value.\n\nYou may be wondering why the weird behavior with mutable lists in the previous section doesn\u2019t happen with immutable values like integers or strings. We can use Python\u2019s id() function to understand this. All values in Python have a unique identity that can be obtained with the id() function. Enter the following into the interactive shell:\n\n>>> id('Howdy') # The returned number will be different on your machine. 44491136\n\nWhen Python runs id('Howdy') , it creates the 'Howdy' string in the computer\u2019s memory. The numeric memory address where the string is stored is returned by the id() function. Python picks this address based on which memory bytes happen to be free on your computer at the time, so it\u2019ll be different each time you run this code.\n\nLike all strings, 'Howdy' is immutable and cannot be changed. If you \u201cchange\u201d the string in a variable, a new string object is being made at a different place in memory, and the variable refers to this new string. For example, enter the following into the interactive shell and see how the identity of the string referred to by bacon changes:\n\n>>> bacon = 'Hello' >>> id(bacon) 44491136 >>> bacon += ' world!' # A new string is made from 'Hello' and ' world!'. >>> id(bacon) # bacon now refers to a completely different string. 44609712\n\nHowever, lists can be modified because they are mutable objects. The append() method doesn\u2019t create a new list object; it changes the existing list object. We call this \u201cmodifying the object in-place. \u201d\n\n>>> eggs = ['cat', 'dog'] # This creates a new list. >>> id(eggs) 35152584 >>> eggs.append('moose') # append() modifies the list \"in place\". >>> id(eggs) # eggs still refers to the same list as before. 35152584 >>> eggs = ['bat', 'rat', 'cow'] # This creates a new list, which has a new identity. >>> id(eggs) # eggs now refers to a completely different list. 44409800\n\nIf two variables refer to the same list (like spam and cheese in the previous section) and the list value itself changes, both variables are affected because they both refer to the same list. The append() , extend() , remove() , sort() , reverse() , and other list methods modify their lists in place.\n\nPython\u2019s automatic garbage collector deletes any values not being referred to by any variables to free up memory. You don\u2019t need to worry about how the garbage collector works, which is a good thing: manual memory management in other programming languages is a common source of bugs.\n\nReferences are particularly important for understanding how arguments get passed to functions. When a function is called, the values of the arguments are copied to the parameter variables. For lists (and dictionaries, which I\u2019ll describe in the next chapter), this means a copy of the reference is used for the parameter. To see the consequences of this, open a new file editor window, enter the following code, and save it as passingReference.py :\n\ndef eggs(someParameter): someParameter.append('Hello') spam = [1, 2, 3] eggs(spam) print(spam)\n\nNotice that when eggs() is called, a return value is not used to assign a new value to spam . Instead, it modifies the list in place, directly. When run, this program produces the following output:\n\n[1, 2, 3, 'Hello']\n\nEven though spam and someParameter contain separate references, they both refer to the same list. This is why the append('Hello') method call inside the function affects the list even after the function call has returned.\n\nKeep this behavior in mind: forgetting that Python handles list and dictionary variables this way can lead to confusing bugs.\n\nAlthough passing around references is often the handiest way to deal with lists and dictionaries, if the function modifies the list or dictionary that is passed, you may not want these changes in the original list or dictionary value. For this, Python provides a module named copy that provides both the copy() and deepcopy() functions. The first of these, copy.copy() , can be used to make a duplicate copy of a mutable value like a list or dictionary, not just a copy of a reference. Enter the following into the interactive shell:\n\n>>> import copy >>> spam = ['A', 'B', 'C', 'D'] >>> id(spam) 44684232 >>> cheese = copy.copy(spam) >>> id(cheese) # cheese is a different list with different identity. 44685832 >>> cheese[1] = 42 >>> spam ['A', 'B', 'C', 'D'] >>> cheese ['A', 42, 'C', 'D']\n\nNow the spam and cheese variables refer to separate lists, which is why only the list in cheese is modified when you assign 42 at index 1 . As you can see in Figure 4-7, the reference ID numbers are no longer the same for both variables because the variables refer to independent lists.\n\nFigure 4-7: cheese = copy.copy(spam) creates a second list that can be modified independently of the first.\n\nIf the list you need to copy contains lists, then use the copy.deepcopy() function instead of copy.copy() . The deepcopy() function will copy these inner lists as well.", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "How do I use 'A Short Program: Conway\u2019s Game of Life' in Python?", "input": "", "output": "Conway\u2019s Game of Life is an example of cellular automata : a set of rules governing the behavior of a field made up of discrete cells. In practice, it creates a pretty animation to look at. You can draw out each step on graph paper, using the squares as cells. A filled-in square will be \u201calive\u201d and an empty square will be \u201cdead.\u201d If a living square has two or three living neighbors, it continues to live on the next step. If a dead square has exactly three living neighbors, it comes alive on the next step. Every other square dies or remains dead on the next step. You can see an example of the progression of steps in Figure 4-8.\n\nFigure 4-8: Four steps in a Conway\u2019s Game of Life simulation\n\nEven though the rules are simple, there are many surprising behaviors that emerge. Patterns in Conway\u2019s Game of Life can move, self-replicate, or even mimic CPUs. But at the foundation of all of this complex, advanced behavior is a rather simple program.\n\nWe can use a list of lists to represent the two-dimensional field. The inner list represents each column of squares and stores a '#' hash string for living squares and a ' ' space string for dead squares. Type the following source code into the file editor, and save the file as conway.py . It\u2019s fine if you don\u2019t quite understand how all of the code works; just enter it and follow along with comments and explanations provided here as close as you can:\n\n# Conway's Game of Life import random, time, copy WIDTH = 60 HEIGHT = 20 # Create a list of list for the cells: nextCells = [] for x in range(WIDTH): column = [] # Create a new column. for y in range(HEIGHT): if random.randint(0, 1) == 0: column.append('#') # Add a living cell. else: column.append(' ') # Add a dead cell. nextCells.append(column) # nextCells is a list of column lists. while True: # Main program loop. print('\\n\\n\\n\\n\\n') # Separate each step with newlines. currentCells = copy.deepcopy(nextCells) # Print currentCells on the screen: for y in range(HEIGHT): for x in range(WIDTH): print(currentCells[x][y], end='') # Print the # or space. print() # Print a newline at the end of the row. # Calculate the next step's cells based on current step's cells: for x in range(WIDTH): for y in range(HEIGHT): # Get neighboring coordinates: # `% WIDTH` ensures leftCoord is always between 0 and WIDTH - 1 leftCoord\u00a0\u00a0= (x - 1) % WIDTH rightCoord = (x + 1) % WIDTH aboveCoord = (y - 1) % HEIGHT belowCoord = (y + 1) % HEIGHT # Count number of living neighbors: numNeighbors = 0 if currentCells[leftCoord][aboveCoord] == '#': numNeighbors += 1 # Top-left neighbor is alive. if currentCells[x][aboveCoord] == '#': numNeighbors += 1 # Top neighbor is alive. if currentCells[rightCoord][aboveCoord] == '#': numNeighbors += 1 # Top-right neighbor is alive. if currentCells[leftCoord][y] == '#': numNeighbors += 1 # Left neighbor is alive. if currentCells[rightCoord][y] == '#': numNeighbors += 1 # Right neighbor is alive. if currentCells[leftCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-left neighbor is alive. if currentCells[x][belowCoord] == '#': numNeighbors += 1 # Bottom neighbor is alive. if currentCells[rightCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-right neighbor is alive. # Set cell based on Conway's Game of Life rules: if currentCells[x][y] == '#' and (numNeighbors == 2 or numNeighbors == 3): # Living cells with 2 or 3 neighbors stay alive: nextCells[x][y] = '#' elif currentCells[x][y] == ' ' and numNeighbors == 3: # Dead cells with 3 neighbors become alive: nextCells[x][y] = '#' else: # Everything else dies or stays dead: nextCells[x][y] = ' ' time.sleep(1) # Add a 1-second pause to reduce flickering.\n\nLet\u2019s look at this code line by line, starting at the top.\n\n# Conway's Game of Life import random, time, copy WIDTH = 60 HEIGHT = 20\n\nFirst we import modules that contain functions we\u2019ll need, namely the random.randint() , time.sleep() , and copy.deepcopy() functions.\n\n# Create a list of list for the cells: nextCells = [] for x in range(WIDTH): column = [] # Create a new column. for y in range(HEIGHT): if random.randint(0, 1) == 0: column.append('#') # Add a living cell. else: column.append(' ') # Add a dead cell. nextCells.append(column) # nextCells is a list of column lists.\n\nThe very first step of our cellular automata will be completely random. We need to create a list of lists data structure to store the '#' and ' ' strings that represent a living or dead cell, and their place in the list of lists reflects their position on the screen. The inner lists each represent a column of cells. The random.randint(0, 1) call gives an even 50/50 chance between the cell starting off alive or dead.\n\nWe put this list of lists in a variable called nextCells , because the first step in our main program loop will be to copy nextCells into currentCells . For our list of lists data structure, the x-coordinates start at 0 on the left and increase going right, while the y-coordinates start at 0 at the top and increase going down. So nextCells[0][0] will represent the cell at the top left of the screen, while nextCells[1][0] represents the cell to the right of that cell and nextCells[0][1] represents the cell beneath it.\n\nwhile True: # Main program loop. print('\\n\\n\\n\\n\\n') # Separate each step with newlines. currentCells = copy.deepcopy(nextCells)\n\nEach iteration of our main program loop will be a single step of our cellular automata. On each step, we\u2019ll copy nextCells to currentCells , print currentCells on the screen, and then use the cells in currentCells to calculate the cells in nextCells .\n\n# Print currentCells on the screen: for y in range(HEIGHT): for x in range(WIDTH): print(currentCells[x][y], end='') # Print the # or space. print() # Print a newline at the end of the row.\n\nThese nested for loops ensure that we print a full row of cells to the screen, followed by a newline character at the end of the row. We repeat this for each row in nextCells .\n\n# Calculate the next step's cells based on current step's cells: for x in range(WIDTH): for y in range(HEIGHT): # Get neighboring coordinates: # `% WIDTH` ensures leftCoord is always between 0 and WIDTH - 1 leftCoord\u00a0\u00a0= (x - 1) % WIDTH rightCoord = (x + 1) % WIDTH aboveCoord = (y - 1) % HEIGHT belowCoord = (y + 1) % HEIGHT\n\nNext, we need to use two nested for loops to calculate each cell for the next step. The living or dead state of the cell depends on the neighbors, so let\u2019s first calculate the index of the cells to the left, right, above, and below the current x- and y-coordinates.\n\nThe % mod operator performs a \u201cwraparound.\u201d The left neighbor of a cell in the leftmost column 0 would be 0 - 1 or -1 . To wrap this around to the rightmost column\u2019s index, 59 , we calculate (0 - 1) % WIDTH . Since WIDTH is 60 , this expression evaluates to 59 . This mod-wraparound technique works for the right, above, and below neighbors as well.\n\n# Count number of living neighbors: numNeighbors = 0 if currentCells[leftCoord][aboveCoord] == '#': numNeighbors += 1 # Top-left neighbor is alive. if currentCells[x][aboveCoord] == '#': numNeighbors += 1 # Top neighbor is alive. if currentCells[rightCoord][aboveCoord] == '#': numNeighbors += 1 # Top-right neighbor is alive. if currentCells[leftCoord][y] == '#': numNeighbors += 1 # Left neighbor is alive. if currentCells[rightCoord][y] == '#': numNeighbors += 1 # Right neighbor is alive. if currentCells[leftCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-left neighbor is alive. if currentCells[x][belowCoord] == '#': numNeighbors += 1 # Bottom neighbor is alive. if currentCells[rightCoord][belowCoord] == '#': numNeighbors += 1 # Bottom-right neighbor is alive.\n\nTo decide if the cell at nextCells[x][y] should be living or dead, we need to count the number of living neighbors currentCells[x][y] has. This series of if statements checks each of the eight neighbors of this cell, and adds 1 to numNeighbors for each living one.\n\n# Set cell based on Conway's Game of Life rules: if currentCells[x][y] == '#' and (numNeighbors == 2 or numNeighbors == 3): # Living cells with 2 or 3 neighbors stay alive: nextCells[x][y] = '#' elif currentCells[x][y] == ' ' and numNeighbors == 3: # Dead cells with 3 neighbors become alive: nextCells[x][y] = '#' else: # Everything else dies or stays dead: nextCells[x][y] = ' ' time.sleep(1) # Add a 1-second pause to reduce flickering.\n\nNow that we know the number of living neighbors for the cell at currentCells[x][y] , we can set nextCells[x][y] to either '#' or ' ' . After we loop over every possible x- and y-coordinate, the program takes a 1-second pause by calling time.sleep(1) . Then the program execution goes back to the start of the main program loop to continue with the next step.\n\nSeveral patterns have been discovered with names such as \u201cglider,\u201d \u201cpropeller,\u201d or \u201cheavyweight spaceship.\u201d The glider pattern, pictured in Figure 4-8, results in a pattern that \u201cmoves\u201d diagonally every four steps. You can create a single glider by replacing this line in our conway.py program:\n\nif random.randint(0, 1) == 0:\n\nwith this line:\n\nif (x, y) in ((1, 0), (2, 1), (0, 2), (1, 2), (2, 2)):\n\nYou can find out more about the intriguing devices made using Conway\u2019s Game of Life by searching the web. And you can find other short, text-based Python programs like this one at https://github.com/asweigart/pythonstdiogames .", "source": "https://automatetheboringstuff.com/2e/chapter4/", "category": "4LISTS"}
{"instruction": "Explain the concept of '5DICTIONARIES AND STRUCTURING DATA' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "In this chapter, I will cover the dictionary data type, which provides a flexible way to access and organize data. Then, combining dictionaries with your knowledge of lists from the previous chapter, you\u2019ll learn how to create a data structure to model a tic-tac-toe board.", "source": "https://automatetheboringstuff.com/2e/chapter5/", "category": "5DICTIONARIES AND STRUCTURING DATA"}
{"instruction": "Provide a guide on 'The Dictionary Data Type' in Python.", "input": "", "output": "Like a list, a dictionary is a mutable collection of many values. But unlike indexes for lists, indexes for dictionaries can use many different data types, not just integers. Indexes for dictionaries are called keys , and a key with its associated value is called a key-value pair .\n\nIn code, a dictionary is typed with braces, {} . Enter the following into the interactive shell:\n\n>>> myCat = {'size': 'fat', 'color': 'gray', 'disposition': 'loud'}\n\nThis assigns a dictionary to the myCat variable. This dictionary\u2019s keys are 'size' , 'color' , and 'disposition' . The values for these keys are 'fat' , 'gray' , and 'loud' , respectively. You can access these values through their keys:\n\n>>> myCat['size'] 'fat' >>> 'My cat has ' + myCat['color'] + ' fur.' 'My cat has gray fur.'\n\nDictionaries can still use integer values as keys, just like lists use integers for indexes, but they do not have to start at 0 and can be any number.\n\n>>> spam = {12345: 'Luggage Combination', 42: 'The Answer'}\n\nUnlike lists, items in dictionaries are unordered. The first item in a list named spam would be spam[0] . But there is no \u201cfirst\u201d item in a dictionary. While the order of items matters for determining whether two lists are the same, it does not matter in what order the key-value pairs are typed in a dictionary. Enter the following into the interactive shell:\n\n>>> spam = ['cats', 'dogs', 'moose'] >>> bacon = ['dogs', 'moose', 'cats'] >>> spam == bacon False >>> eggs = {'name': 'Zophie', 'species': 'cat', 'age': '8'} >>> ham = {'species': 'cat', 'age': '8', 'name': 'Zophie'} >>> eggs == ham True\n\nBecause dictionaries are not ordered, they can\u2019t be sliced like lists.\n\nTrying to access a key that does not exist in a dictionary will result in a KeyError error message, much like a list\u2019s \u201cout-of-range\u201d IndexError error message. Enter the following into the interactive shell, and notice the error message that shows up because there is no 'color' key:\n\n>>> spam = {'name': 'Zophie', 'age': 7} >>> spam['color'] Traceback (most recent call last): File \"<pyshell#1>\", line 1, in <module> spam['color'] KeyError: 'color'\n\nThough dictionaries are not ordered, the fact that you can have arbitrary values for the keys allows you to organize your data in powerful ways. Say you wanted your program to store data about your friends\u2019 birthdays. You can use a dictionary with the names as keys and the birthdays as values. Open a new file editor window and enter the following code. Save it as birthdays.py .\n\n\u278a birthdays = {'Alice': 'Apr 1', 'Bob': 'Dec 12', 'Carol': 'Mar 4'} while True: print('Enter a name: (blank to quit)') name = input() if name == '': break \u278b if name in birthdays: \u278c print(birthdays[name] + ' is the birthday of ' + name) else: print('I do not have birthday information for ' + name) print('What is their birthday?') bday = input() \u278d birthdays[name] = bday print('Birthday database updated.')\n\nYou can view the execution of this program at https://autbor.com/bdaydb . You create an initial dictionary and store it in birthdays \u278a . You can see if the entered name exists as a key in the dictionary with the in keyword \u278b , just as you did for lists. If the name is in the dictionary, you access the associated value using square brackets \u278c ; if not, you can add it using the same square bracket syntax combined with the assignment operator \u278d .\n\nWhen you run this program, it will look like this:\n\nEnter a name: (blank to quit) Alice Apr 1 is the birthday of Alice Enter a name: (blank to quit) Eve I do not have birthday information for Eve What is their birthday? Dec 5 Birthday database updated. Enter a name: (blank to quit) Eve Dec 5 is the birthday of Eve Enter a name: (blank to quit)\n\nOf course, all the data you enter in this program is forgotten when the program terminates. You\u2019ll learn how to save data to files on the hard drive in Chapter 9.\n\nThere are three dictionary methods that will return list-like values of the dictionary\u2019s keys, values, or both keys and values: keys() , values() , and items() . The values returned by these methods are not true lists: they cannot be modified and do not have an append() method. But these data types ( dict_keys , dict_values , and dict_items , respectively) can be used in for loops. To see how these methods work, enter the following into the interactive shell:\n\n>>> spam = {'color': 'red', 'age': 42} >>> for v in spam.values(): ... print(v) red 42\n\nHere, a for loop iterates over each of the values in the spam dictionary. A for loop can also iterate over the keys or both keys and values:\n\n>>> for k in spam.keys(): ... print(k) color age >>> for i in spam.items(): ... print(i) ('color', 'red') ('age', 42)\n\nWhen you use the keys() , values() , and items() methods, a for loop can iterate over the keys, values, or key-value pairs in a dictionary, respectively. Notice that the values in the dict_items value returned by the items() method are tuples of the key and value.\n\nIf you want a true list from one of these methods, pass its list-like return value to the list() function. Enter the following into the interactive shell:\n\n>>> spam = {'color': 'red', 'age': 42} >>> spam.keys() dict_keys(['color', 'age']) >>> list(spam.keys()) ['color', 'age']\n\nThe list(spam.keys()) line takes the dict_keys value returned from keys() and passes it to list() , which then returns a list value of ['color', 'age'] .\n\nYou can also use the multiple assignment trick in a for loop to assign the key and value to separate variables. Enter the following into the interactive shell:\n\n>>> spam = {'color': 'red', 'age': 42} >>> for k, v in spam.items(): ...\u00a0\u00a0\u00a0\u00a0\u00a0print('Key: ' + k + ' Value: ' + str(v)) Key: age Value: 42 Key: color Value: red\n\nRecall from the previous chapter that the in and not in operators can check whether a value exists in a list. You can also use these operators to see whether a certain key or value exists in a dictionary. Enter the following into the interactive shell:\n\n>>> spam = {'name': 'Zophie', 'age': 7} >>> 'name' in spam.keys() True >>> 'Zophie' in spam.values() True >>> 'color' in spam.keys() False >>> 'color' not in spam.keys() True >>> 'color' in spam False\n\nIn the previous example, notice that 'color' in spam is essentially a shorter version of writing 'color' in spam.keys() . This is always the case: if you ever want to check whether a value is (or isn\u2019t) a key in the dictionary, you can simply use the in (or not in ) keyword with the dictionary value itself.\n\nIt\u2019s tedious to check whether a key exists in a dictionary before accessing that key\u2019s value. Fortunately, dictionaries have a get() method that takes two arguments: the key of the value to retrieve and a fallback value to return if that key does not exist.\n\nEnter the following into the interactive shell:\n\n>>> picnicItems = {'apples': 5, 'cups': 2} >>> 'I am bringing ' + str(picnicItems.get('cups', 0)) + ' cups.' 'I am bringing 2 cups.' >>> 'I am bringing ' + str(picnicItems.get('eggs', 0)) + ' eggs.' 'I am bringing 0 eggs.'\n\nBecause there is no 'eggs' key in the picnicItems dictionary, the default value 0 is returned by the get() method. Without using get() , the code would have caused an error message, such as in the following example:\n\n>>> picnicItems = {'apples': 5, 'cups': 2} >>> 'I am bringing ' + str(picnicItems['eggs']) + ' eggs.' Traceback (most recent call last): File \"<pyshell#34>\", line 1, in <module> 'I am bringing ' + str(picnicItems['eggs']) + ' eggs.' KeyError: 'eggs'\n\nYou\u2019ll often have to set a value in a dictionary for a certain key only if that key does not already have a value. The code looks something like this:\n\nspam = {'name': 'Pooka', 'age': 5} if 'color' not in spam: spam['color'] = 'black'\n\nThe setdefault() method offers a way to do this in one line of code. The first argument passed to the method is the key to check for, and the second argument is the value to set at that key if the key does not exist. If the key does exist, the setdefault() method returns the key\u2019s value. Enter the following into the interactive shell:\n\n>>> spam = {'name': 'Pooka', 'age': 5} >>> spam.setdefault('color', 'black') 'black' >>> spam {'color': 'black', 'age': 5, 'name': 'Pooka'} >>> spam.setdefault('color', 'white') 'black' >>> spam {'color': 'black', 'age': 5, 'name': 'Pooka'}\n\nThe first time setdefault() is called, the dictionary in spam changes to {'color': 'black', 'age': 5, 'name': 'Pooka'} . The method returns the value 'black' because this is now the value set for the key 'color' . When spam.setdefault('color', 'white') is called next, the value for that key is not changed to 'white' , because spam already has a key named 'color' .\n\nThe setdefault() method is a nice shortcut to ensure that a key exists. Here is a short program that counts the number of occurrences of each letter in a string. Open the file editor window and enter the following code, saving it as characterCount.py :\n\nmessage = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: \u278a count.setdefault(character, 0) \u278b count[character] = count[character] + 1 print(count)\n\nYou can view the execution of this program at https://autbor.com/setdefault . The program loops over each character in the message variable\u2019s string, counting how often each character appears. The setdefault() method call \u278a ensures that the key is in the count dictionary (with a default value of 0 ) so the program doesn\u2019t throw a KeyError error when count[character] = count[character] + 1 is executed \u278b . When you run this program, the output will look like this:\n\n{' ': 13, ',': 1, '.': 1, 'A': 1, 'I': 1, 'a': 4, 'c': 3, 'b': 1, 'e': 5, 'd': 3, 'g': 2, 'i': 6, 'h': 3, 'k': 2, 'l': 3, 'o': 2, 'n': 4, 'p': 1, 's': 3, 'r': 5, 't': 6, 'w': 2, 'y': 1}\n\nFrom the output, you can see that the lowercase letter c appears 3 times, the space character appears 13 times, and the uppercase letter A appears 1 time. This program will work no matter what string is inside the message variable, even if the string is millions of characters long!", "source": "https://automatetheboringstuff.com/2e/chapter5/", "category": "5DICTIONARIES AND STRUCTURING DATA"}
{"instruction": "Explain the concept of 'Pretty Printing' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "If you import the pprint module into your programs, you\u2019ll have access to the pprint() and pformat() functions that will \u201cpretty print\u201d a dictionary\u2019s values. This is helpful when you want a cleaner display of the items in a dictionary than what print() provides. Modify the previous characterCount.py program and save it as prettyCharacterCount.py .\n\nimport pprint message = 'It was a bright cold day in April, and the clocks were striking thirteen.' count = {} for character in message: count.setdefault(character, 0) count[character] = count[character] + 1 pprint.pprint (count)\n\nYou can view the execution of this program at https://autbor.com/pprint/ . This time, when the program is run, the output looks much cleaner, with the keys sorted.\n\n{' ': 13, ',': 1, '.': 1, 'A': 1, 'I': 1, --snip-- 't': 6, 'w': 2, 'y': 1}\n\nThe pprint.pprint() function is especially helpful when the dictionary itself contains nested lists or dictionaries.\n\nIf you want to obtain the prettified text as a string value instead of displaying it on the screen, call pprint.pformat() instead. These two lines are equivalent to each other:\n\npprint.pprint(someDictionaryValue) print(pprint.pformat(someDictionaryValue))", "source": "https://automatetheboringstuff.com/2e/chapter5/", "category": "5DICTIONARIES AND STRUCTURING DATA"}
{"instruction": "Provide a guide on 'Using Data Structures to Model Real-World Things' in Python.", "input": "", "output": "Even before the internet, it was possible to play a game of chess with someone on the other side of the world. Each player would set up a chessboard at their home and then take turns mailing a postcard to each other describing each move. To do this, the players needed a way to unambiguously describe the state of the board and their moves.\n\nIn algebraic chess notation , the spaces on the chessboard are identified by a number and letter coordinate, as in Figure 5-1.\n\nFigure 5-1: The coordinates of a chessboard in algebraic chess notation\n\nThe chess pieces are identified by letters: K for king, Q for queen, R for rook, B for bishop, and N for knight. Describing a move uses the letter of the piece and the coordinates of its destination. A pair of these moves describes what happens in a single turn (with white going first); for instance, the notation 2. Nf3 Nc6 indicates that white moved a knight to f3 and black moved a knight to c6 on the second turn of the game.\n\nThere\u2019s a bit more to algebraic notation than this, but the point is that you can unambiguously describe a game of chess without needing to be in front of a chessboard. Your opponent can even be on the other side of the world! In fact, you don\u2019t even need a physical chess set if you have a good memory: you can just read the mailed chess moves and update boards you have in your imagination.\n\nComputers have good memories. A program on a modern computer can easily store billions of strings like '2. Nf3 Nc6' . This is how computers can play chess without having a physical chessboard. They model data to represent a chessboard, and you can write code to work with this model.\n\nThis is where lists and dictionaries can come in. For example, the dictionary {'1h': 'bking', '6c': 'wqueen', '2g': 'bbishop', '5h': 'bqueen', '3e': 'wking'} could represent the chess board in Figure 5-2.\n\nFigure 5-2: A chess board modeled by the dictionary '1h': 'bking', '6c': 'wqueen', '2g': 'bbishop', '5h': 'bqueen', '3e': 'wking'}\n\nBut for another example, you\u2019ll use a game that\u2019s a little simpler than chess: tic-tac-toe.\n\nA tic-tac-toe board looks like a large hash symbol (#) with nine slots that can each contain an X , an O , or a blank. To represent the board with a dictionary, you can assign each slot a string-value key, as shown in Figure 5-3.\n\nFigure 5-3: The slots of a tic-tac-toe board with their corresponding keys\n\nYou can use string values to represent what\u2019s in each slot on the board: 'X' , 'O' , or ' ' (a space). Thus, you\u2019ll need to store nine strings. You can use a dictionary of values for this. The string value with the key 'top-R' can represent the top-right corner, the string value with the key 'low-L' can represent the bottom-left corner, the string value with the key 'mid-M' can represent the middle, and so on.\n\nThis dictionary is a data structure that represents a tic-tac-toe board. Store this board-as-a-dictionary in a variable named theBoard . Open a new file editor window, and enter the following source code, saving it as ticTacToe.py :\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': ' ', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '}\n\nThe data structure stored in the theBoard variable represents the tic-tac-toe board in Figure 5-4.\n\nFigure 5-4: An empty tic-tac-toe board\n\nSince the value for every key in theBoard is a single-space string, this dictionary represents a completely clear board. If player X went first and chose the middle space, you could represent that board with this dictionary:\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': 'X', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '}\n\nThe data structure in theBoard now represents the tic-tac-toe board in Figure 5-5.\n\nFigure 5-5: The first move\n\nA board where player O has won by placing O s across the top might look like this:\n\ntheBoard = {'top-L': 'O', 'top-M': 'O', 'top-R': 'O', 'mid-L': 'X', 'mid-M': 'X', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': 'X'}\n\nThe data structure in theBoard now represents the tic-tac-toe board in Figure 5-6.\n\nFigure 5-6: Player O wins.\n\nOf course, the player sees only what is printed to the screen, not the contents of variables. Let\u2019s create a function to print the board dictionary onto the screen. Make the following addition to ticTacToe.py (new code is in bold):\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': ' ', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '} def printBoard(board): print(board['top-L'] + '|' + board['top-M'] + '|' + board['top-R']) print('-+-+-') print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) print('-+-+-') print(board['low-L'] + '|' + board['low-M'] + '|' + board['low-R']) printBoard(theBoard)\n\nYou can view the execution of this program at https://autbor.com/tictactoe1/ . When you run this program, printBoard() will print out a blank tic-tac-toe board.\n\n| | -+-+- | | -+-+- | |\n\nThe printBoard() function can handle any tic-tac-toe data structure you pass it. Try changing the code to the following:\n\ntheBoard = {'top-L': 'O', 'top-M': 'O', 'top-R': 'O', 'mid-L': 'X', 'mid-M': 'X', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': 'X'} def printBoard(board): print(board['top-L'] + '|' + board['top-M'] + '|' + board['top-R']) print('-+-+-') print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) print('-+-+-') print(board['low-L'] + '|' + board['low-M'] + '|' + board['low-R']) printBoard(theBoard)\n\nYou can view the execution of this program at https://autbor.com/tictactoe2/ . Now when you run this program, the new board will be printed to the screen.\n\nO|O|O -+-+- X|X| -+-+- | |X\n\nBecause you created a data structure to represent a tic-tac-toe board and wrote code in printBoard() to interpret that data structure, you now have a program that \u201cmodels\u201d the tic-tac-toe board. You could have organized your data structure differently (for example, using keys like 'TOP-LEFT' instead of 'top-L' ), but as long as the code works with your data structures, you will have a correctly working program.\n\nFor example, the printBoard() function expects the tic-tac-toe data structure to be a dictionary with keys for all nine slots. If the dictionary you passed was missing, say, the 'mid-L' key, your program would no longer work.\n\nO|O|O -+-+- Traceback (most recent call last): File \"ticTacToe.py\", line 10, in <module> printBoard(theBoard) File \"ticTacToe.py\", line 6, in printBoard print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) KeyError: 'mid-L'\n\nNow let\u2019s add code that allows the players to enter their moves. Modify the ticTacToe.py program to look like this:\n\ntheBoard = {'top-L': ' ', 'top-M': ' ', 'top-R': ' ', 'mid-L': ' ', 'mid-M': ' ', 'mid-R': ' ', 'low-L': ' ', 'low-M': ' ', 'low-R': ' '} def printBoard(board): print(board['top-L'] + '|' + board['top-M'] + '|' + board['top-R']) print('-+-+-') print(board['mid-L'] + '|' + board['mid-M'] + '|' + board['mid-R']) print('-+-+-') print(board['low-L'] + '|' + board['low-M'] + '|' + board['low-R']) turn = 'X' for i in range(9): \u278a printBoard(theBoard) print('Turn for ' + turn + '. Move on which space?') \u278b move = input() \u278c theBoard[move] = turn \u278d if turn == 'X': turn = 'O' else: turn = 'X' printBoard(theBoard)\n\nYou can view the execution of this program at https://autbor.com/tictactoe3/ . The new code prints out the board at the start of each new turn \u278a , gets the active player\u2019s move \u278b , updates the game board accordingly \u278c , and then swaps the active player \u278d before moving on to the next turn.\n\nWhen you run this program, it will look something like this:\n\n| | -+-+- | | -+-+- | | Turn for X. Move on which space? mid-M | | -+-+- |X| -+-+- | | --snip-- O|O|X -+-+- X|X|O -+-+- O| |X Turn for X. Move on which space? low-M O|O|X -+-+- X|X|O -+-+- O|X|X\n\nThis isn\u2019t a complete tic-tac-toe game\u2014for instance, it doesn\u2019t ever check whether a player has won\u2014but it\u2019s enough to see how data structures can be used in programs.\n\nModeling a tic-tac-toe board was fairly simple: the board needed only a single dictionary value with nine key-value pairs. As you model more complicated things, you may find you need dictionaries and lists that contain other dictionaries and lists. Lists are useful to contain an ordered series of values, and dictionaries are useful for associating keys with values. For example, here\u2019s a program that uses a dictionary that contains other dictionaries of what items guests are bringing to a picnic. The totalBrought() function can read this data structure and calculate the total number of an item being brought by all the guests.\n\nallGuests = {'Alice': {'apples': 5, 'pretzels': 12}, 'Bob': {'ham sandwiches': 3, 'apples': 2}, 'Carol': {'cups': 3, 'apple pies': 1}} def totalBrought(guests, item): numBrought = 0 \u278a for k, v in guests.items(): \u278b numBrought = numBrought + v.get(item, 0) return numBrought print('Number of things being brought:') print(' - Apples\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'apples'))) print(' - Cups\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'cups'))) print(' - Cakes\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'cakes'))) print(' - Ham Sandwiches ' + str(totalBrought(allGuests, 'ham sandwiches'))) print(' - Apple Pies\u00a0\u00a0\u00a0\u00a0\u00a0' + str(totalBrought(allGuests, 'apple pies')))\n\nYou can view the execution of this program at https://autbor.com/guestpicnic/ . Inside the totalBrought() function, the for loop iterates over the key-value pairs in guests \u278a . Inside the loop, the string of the guest\u2019s name is assigned to k , and the dictionary of picnic items they\u2019re bringing is assigned to v . If the item parameter exists as a key in this dictionary, its value (the quantity) is added to numBrought \u278b . If it does not exist as a key, the get() method returns 0 to be added to numBrought .\n\nThe output of this program looks like this:\n\nNumber of things being brought: - Apples 7 - Cups 3 - Cakes 0 - Ham Sandwiches 3 - Apple Pies 1\n\nThis may seem like such a simple thing to model that you wouldn\u2019t need to bother with writing a program to do it. But realize that this same totalBrought() function could easily handle a dictionary that contains thousands of guests, each bringing thousands of different picnic items. Then having this information in a data structure along with the totalBrought() function would save you a lot of time!\n\nYou can model things with data structures in whatever way you like, as long as the rest of the code in your program can work with the data model correctly. When you first begin programming, don\u2019t worry so much about the \u201cright\u201d way to model data. As you gain more experience, you may come up with more efficient models, but the important thing is that the data model works for your program\u2019s needs.", "source": "https://automatetheboringstuff.com/2e/chapter5/", "category": "5DICTIONARIES AND STRUCTURING DATA"}
{"instruction": "What is '6MANIPULATING STRINGS' and how does it work in Python?", "input": "", "output": "Text is one of the most common forms of data your programs will handle. You already know how to concatenate two string values together with the + operator, but you can do much more than that. You can extract partial strings from string values, add or remove spacing, convert letters to lowercase or uppercase, and check that strings are formatted correctly. You can even write Python code to access the clipboard for copying and pasting text.\n\nIn this chapter, you\u2019ll learn all this and more. Then you\u2019ll work through two different programming projects: a simple clipboard that stores multiple strings of text and a program to automate the boring chore of formatting pieces of text.", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "How do I use 'Working with Strings' in Python?", "input": "", "output": "Let\u2019s look at some of the ways Python lets you write, print, and access strings in your code.\n\nTyping string values in Python code is fairly straightforward: they begin and end with a single quote. But then how can you use a quote inside a string? Typing 'That is Alice's cat.' won\u2019t work, because Python thinks the string ends after Alice , and the rest ( s cat.' ) is invalid Python code. Fortunately, there are multiple ways to type strings.\n\nStrings can begin and end with double quotes, just as they do with single quotes. One benefit of using double quotes is that the string can have a single quote character in it. Enter the following into the interactive shell:\n\n>>> spam = \"That is Alice's cat.\"\n\nSince the string begins with a double quote, Python knows that the single quote is part of the string and not marking the end of the string. However, if you need to use both single quotes and double quotes in the string, you\u2019ll need to use escape characters.\n\nAn escape character lets you use characters that are otherwise impossible to put into a string. An escape character consists of a backslash ( \\ ) followed by the character you want to add to the string. (Despite consisting of two characters, it is commonly referred to as a singular escape character.) For example, the escape character for a single quote is \\' . You can use this inside a string that begins and ends with single quotes. To see how escape characters work, enter the following into the interactive shell:\n\n>>> spam = 'Say hi to Bob\\'s mother.'\n\nPython knows that since the single quote in Bob\\'s has a backslash, it is not a single quote meant to end the string value. The escape characters \\' and \\\" let you put single quotes and double quotes inside your strings, respectively.\n\nTable 6-1 lists the escape characters you can use.\n\nTable 6-1: Escape Characters\n\nEnter the following into the interactive shell:\n\n>>> print(\"Hello there!\\nHow are you?\\nI\\'m doing fine.\") Hello there! How are you? I'm doing fine.\n\nYou can place an r before the beginning quotation mark of a string to make it a raw string. A raw string completely ignores all escape characters and prints any backslash that appears in the string. For example, enter the following into the interactive shell:\n\n>>> print(r'That is Carol\\'s cat.') That is Carol\\'s cat.\n\nBecause this is a raw string, Python considers the backslash as part of the string and not as the start of an escape character. Raw strings are helpful if you are typing string values that contain many backslashes, such as the strings used for Windows file paths like r'C:\\Users\\Al\\Desktop' or regular expressions described in the next chapter.\n\nWhile you can use the \\n escape character to put a newline into a string, it is often easier to use multiline strings. A multiline string in Python begins and ends with either three single quotes or three double quotes. Any quotes, tabs, or newlines in between the \u201ctriple quotes\u201d are considered part of the string. Python\u2019s indentation rules for blocks do not apply to lines inside a multiline string.\n\nOpen the file editor and write the following:\n\nprint('''Dear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob''')\n\nSave this program as catnapping.py and run it. The output will look like this:\n\nDear Alice, Eve's cat has been arrested for catnapping, cat burglary, and extortion. Sincerely, Bob\n\nNotice that the single quote character in Eve's does not need to be escaped. Escaping single and double quotes is optional in multiline strings. The following print() call would print identical text but doesn\u2019t use a multiline string:\n\nprint('Dear Alice,\\n\\nEve\\'s cat has been arrested for catnapping, cat burglary, and extortion.\\n\\nSincerely,\\nBob')\n\nWhile the hash character ( # ) marks the beginning of a comment for the rest of the line, a multiline string is often used for comments that span multiple lines. The following is perfectly valid Python code:\n\n\"\"\"This is a test Python program. Written by Al Sweigart al@inventwithpython.com This program was designed for Python 3, not Python 2. \"\"\" def spam(): \"\"\"This is a multiline comment to help explain what the spam() function does.\"\"\" print('Hello!')\n\nStrings use indexes and slices the same way lists do. You can think of the string 'Hello, world!' as a list and each character in the string as an item with a corresponding index.\n\n'\u00a0\u00a0\u00a0H\u00a0\u00a0\u00a0e\u00a0\u00a0\u00a0l\u00a0\u00a0\u00a0l\u00a0\u00a0\u00a0o\u00a0\u00a0\u00a0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0w\u00a0\u00a0\u00a0o\u00a0\u00a0\u00a0r\u00a0\u00a0\u00a0l\u00a0\u00a0\u00a0\u00a0d\u00a0\u00a0\u00a0\u00a0!\u00a0\u00a0\u00a0' 0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a02\u00a0\u00a0\u00a03\u00a0\u00a0\u00a04\u00a0\u00a0\u00a05\u00a0\u00a0\u00a06\u00a0\u00a0\u00a07\u00a0\u00a0\u00a08\u00a0\u00a0\u00a09\u00a0\u00a0\u00a010\u00a0\u00a0\u00a011\u00a0\u00a0\u00a012\n\nThe space and exclamation point are included in the character count, so 'Hello, world!' is 13 characters long, from H at index 0 to ! at index 12.\n\nEnter the following into the interactive shell:\n\n>>> spam = 'Hello, world!' >>> spam[0] 'H' >>> spam[4] 'o' >>> spam[-1] '!' >>> spam[0:5] 'Hello' >>> spam[:5] 'Hello' >>> spam[7:] 'world!'\n\nIf you specify an index, you\u2019ll get the character at that position in the string. If you specify a range from one index to another, the starting index is included and the ending index is not. That\u2019s why, if spam is 'Hello, world!' , spam[0:5] is 'Hello' . The substring you get from spam[0:5] will include everything from spam[0] to spam[4] , leaving out the comma at index 5 and the space at index 6. This is similar to how range(5) will cause a for loop to iterate up to, but not including, 5 .\n\nNote that slicing a string does not modify the original string. You can capture a slice from one variable in a separate variable. Try entering the following into the interactive shell:\n\n>>> spam = 'Hello, world!' >>> fizz = spam[0:5] >>> fizz 'Hello'\n\nBy slicing and storing the resulting substring in another variable, you can have both the whole string and the substring handy for quick, easy access.\n\nThe in and not in operators can be used with strings just like with list values. An expression with two strings joined using in or not in will evaluate to a Boolean True or False . Enter the following into the interactive shell:\n\n>>> 'Hello' in 'Hello, World' True >>> 'Hello' in 'Hello' True >>> 'HELLO' in 'Hello, World' False >>> '' in 'spam' True >>> 'cats' not in 'cats and dogs' False\n\nThese expressions test whether the first string (the exact string, case-sensitive) can be found within the second string.", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "Explain the concept of 'Putting Strings Inside Other Strings' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Putting strings inside other strings is a common operation in programming. So far, we\u2019ve been using the + operator and string concatenation to do this:\n\n>>> name = 'Al' >>> age = 4000 >>> 'Hello, my name is ' + name + '. I am ' + str(age) + ' years old.' 'Hello, my name is Al. I am 4000 years old.'\n\nHowever, this requires a lot of tedious typing. A simpler approach is to use string interpolation , in which the %s operator inside the string acts as a marker to be replaced by values following the string. One benefit of string interpolation is that str() doesn\u2019t have to be called to convert values to strings. Enter the following into the interactive shell:\n\n>>> name = 'Al' >>> age = 4000 >>> 'My name is %s. I am %s years old.' % (name, age) 'My name is Al. I am 4000 years old.'\n\nPython 3.6 introduced f-strings , which is similar to string interpolation except that braces are used instead of %s , with the expressions placed directly inside the braces. Like raw strings, f-strings have an f prefix before the starting quotation mark. Enter the following into the interactive shell:\n\n>>> name = 'Al' >>> age = 4000 >>> f'My name is {name}. Next year I will be {age + 1}.' 'My name is Al. Next year I will be 4001.'\n\nRemember to include the f prefix; otherwise, the braces and their contents will be a part of the string value:\n\n>>> 'My name is {name}. Next year I will be {age + 1}.' 'My name is {name}. Next year I will be {age + 1}.'", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "How do I use 'Useful String Methods' in Python?", "input": "", "output": "Several string methods analyze strings or create transformed string values. This section describes the methods you\u2019ll be using most often.\n\nThe upper() and lower() string methods return a new string where all the letters in the original string have been converted to uppercase or lowercase, respectively. Nonletter characters in the string remain unchanged. Enter the following into the interactive shell:\n\n>>> spam = 'Hello, world!' >>> spam = spam.upper() >>> spam 'HELLO, WORLD!' >>> spam = spam.lower() >>> spam 'hello, world!'\n\nNote that these methods do not change the string itself but return new string values. If you want to change the original string, you have to call upper() or lower() on the string and then assign the new string to the variable where the original was stored. This is why you must use spam = spam.upper() to change the string in spam instead of simply spam.upper() . (This is just like if a variable eggs contains the value 10 . Writing eggs + 3 does not change the value of eggs , but eggs = eggs + 3 does.)\n\nThe upper() and lower() methods are helpful if you need to make a case-insensitive comparison. For example, the strings 'great' and 'GREat' are not equal to each other. But in the following small program, it does not matter whether the user types Great , GREAT , or grEAT , because the string is first converted to lowercase.\n\nprint('How are you?') feeling = input() if feeling.lower() == 'great': print('I feel great too.') else: print('I hope the rest of your day is good.')\n\nWhen you run this program, the question is displayed, and entering a variation on great , such as GREat , will still give the output I feel great too . Adding code to your program to handle variations or mistakes in user input, such as inconsistent capitalization, will make your programs easier to use and less likely to fail.\n\nHow are you? GREat I feel great too.\n\nYou can view the execution of this program at https://autbor.com/convertlowercase/ . The isupper() and islower() methods will return a Boolean True value if the string has at least one letter and all the letters are uppercase or lowercase, respectively. Otherwise, the method returns False . Enter the following into the interactive shell, and notice what each method call returns:\n\n>>> spam = 'Hello, world!' >>> spam.islower() False >>> spam.isupper() False >>> 'HELLO'.isupper() True >>> 'abc12345'.islower() True >>> '12345'.islower() False >>> '12345'.isupper() False\n\nSince the upper() and lower() string methods themselves return strings, you can call string methods on those returned string values as well. Expressions that do this will look like a chain of method calls. Enter the following into the interactive shell:\n\n>>> 'Hello'.upper() 'HELLO' >>> 'Hello'.upper().lower() 'hello' >>> 'Hello'.upper().lower().upper() 'HELLO' >>> 'HELLO'.lower() 'hello' >>> 'HELLO'.lower().islower() True\n\nAlong with islower() and isupper() , there are several other string methods that have names beginning with the word is . These methods return a Boolean value that describes the nature of the string. Here are some common is X string methods:\n\nisalpha() Returns True if the string consists only of letters and isn\u2019t blank\n\nisalnum() Returns True if the string consists only of letters and numbers and is not blank\n\nisdecimal() Returns True if the string consists only of numeric characters and is not blank\n\nisspace() Returns True if the string consists only of spaces, tabs, and newlines and is not blank\n\nistitle() Returns True if the string consists only of words that begin with an uppercase letter followed by only lowercase letters\n\nEnter the following into the interactive shell:\n\n>>> 'hello'.isalpha() True >>> 'hello123'.isalpha() False >>> 'hello123'.isalnum() True >>> 'hello'.isalnum() True >>> '123'.isdecimal() True >>> '\u00a0\u00a0\u00a0\u00a0'.isspace() True >>> 'This Is Title Case'.istitle() True >>> 'This Is Title Case 123'.istitle() True >>> 'This Is not Title Case'.istitle() False >>> 'This Is NOT Title Case Either'.istitle() False\n\nThe is X() string methods are helpful when you need to validate user input. For example, the following program repeatedly asks users for their age and a password until they provide valid input. Open a new file editor window and enter this program, saving it as validateInput.py :\n\nwhile True: print('Enter your age:') age = input() if age.isdecimal(): break print('Please enter a number for your age.') while True: print('Select a new password (letters and numbers only):') password = input() if password.isalnum(): break print('Passwords can only have letters and numbers.')\n\nIn the first while loop, we ask the user for their age and store their input in age . If age is a valid (decimal) value, we break out of this first while loop and move on to the second, which asks for a password. Otherwise, we inform the user that they need to enter a number and again ask them to enter their age. In the second while loop, we ask for a password, store the user\u2019s input in password , and break out of the loop if the input was alpha\u00adnumeric. If it wasn\u2019t, we\u2019re not satisfied, so we tell the user the password needs to be alphanumeric and again ask them to enter a password.\n\nWhen run, the program\u2019s output looks like this:\n\nEnter your age: forty two Please enter a number for your age. Enter your age: 42 Select a new password (letters and numbers only): secr3t! Passwords can only have letters and numbers. Select a new password (letters and numbers only): secr3t\n\nYou can view the execution of this program at https://autbor.com/validateinput/ . Calling isdecimal() and isalnum() on variables, we\u2019re able to test whether the values stored in those variables are decimal or not, alphanumeric or not. Here, these tests help us reject the input forty two but accept 42 , and reject secr3t! but accept secr3t .\n\nThe startswith() and endswith() methods return True if the string value they are called on begins or ends (respectively) with the string passed to the method; otherwise, they return False . Enter the following into the interactive shell:\n\n>>> 'Hello, world!'.startswith('Hello') True >>> 'Hello, world!'.endswith('world!') True >>> 'abc123'.startswith('abcdef') False >>> 'abc123'.endswith('12') False >>> 'Hello, world!'.startswith('Hello, world!') True >>> 'Hello, world!'.endswith('Hello, world!') True\n\nThese methods are useful alternatives to the == equals operator if you need to check only whether the first or last part of the string, rather than the whole thing, is equal to another string.\n\nThe join() method is useful when you have a list of strings that need to be joined together into a single string value. The join() method is called on a string, gets passed a list of strings, and returns a string. The returned string is the concatenation of each string in the passed-in list. For example, enter the following into the interactive shell:\n\n>>> ', '.join(['cats', 'rats', 'bats']) 'cats, rats, bats' >>> ' '.join(['My', 'name', 'is', 'Simon']) 'My name is Simon' >>> 'ABC'.join(['My', 'name', 'is', 'Simon']) 'MyABCnameABCisABCSimon'\n\nNotice that the string join() calls on is inserted between each string of the list argument. For example, when join(['cats', 'rats', 'bats']) is called on the ', ' string, the returned string is 'cats, rats, bats' .\n\nRemember that join() is called on a string value and is passed a list value. (It\u2019s easy to accidentally call it the other way around.) The split() method does the opposite: It\u2019s called on a string value and returns a list of strings. Enter the following into the interactive shell:\n\n>>> 'My name is Simon'.split() ['My', 'name', 'is', 'Simon']\n\nBy default, the string 'My name is Simon' is split wherever whitespace characters such as the space, tab, or newline characters are found. These whitespace characters are not included in the strings in the returned list. You can pass a delimiter string to the split() method to specify a different string to split upon. For example, enter the following into the interactive shell:\n\n>>> 'MyABCnameABCisABCSimon'.split('ABC') ['My', 'name', 'is', 'Simon'] >>> 'My name is Simon'.split('m') ['My na', 'e is Si', 'on']\n\nA common use of split() is to split a multiline string along the newline characters. Enter the following into the interactive shell:\n\n>>> spam = '''Dear Alice, How have you been? I am fine. There is a container in the fridge that is labeled \"Milk Experiment.\" Please do not drink it. Sincerely, Bob''' >>> spam.split('\\n') ['Dear Alice,', 'How have you been? I am fine.', 'There is a container in the fridge', 'that is labeled \"Milk Experiment.\"', '', 'Please do not drink it.', 'Sincerely,', 'Bob']\n\nPassing split() the argument '\\n' lets us split the multiline string stored in spam along the newlines and return a list in which each item corresponds to one line of the string.\n\nThe partition() string method can split a string into the text before and after a separator string. This method searches the string it is called on for the separator string it is passed, and returns a tuple of three substrings for the \u201cbefore,\u201d \u201cseparator,\u201d and \u201cafter\u201d substrings. Enter the following into the interactive shell:\n\n>>> 'Hello, world!'.partition('w') ('Hello, ', 'w', 'orld!') >>> 'Hello, world!'.partition('world') ('Hello, ', 'world', '!')\n\nIf the separator string you pass to partition() occurs multiple times in the string that partition() calls on, the method splits the string only on the first occurrence:\n\n>>> 'Hello, world!'.partition('o') ('Hell', 'o', ', world!')\n\nIf the separator string can\u2019t be found, the first string returned in the tuple will be the entire string, and the other two strings will be empty:\n\n>>> 'Hello, world!'.partition('XYZ') ('Hello, world!', '', '')\n\nYou can use the multiple assignment trick to assign the three returned strings to three variables:\n\n>>> before, sep, after = 'Hello, world!'.partition(' ') >>> before 'Hello,' >>> after 'world!'\n\nThe partition() method is useful for splitting a string whenever you need the parts before, including, and after a particular separator string.\n\nThe rjust() and ljust() string methods return a padded version of the string they are called on, with spaces inserted to justify the text. The first argument to both methods is an integer length for the justified string. Enter the following into the interactive shell:\n\n>>> 'Hello'.rjust(10) '\u00a0\u00a0\u00a0\u00a0\u00a0Hello' >>> 'Hello'.rjust(20) '\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hello' >>> 'Hello, World'.rjust(20) '\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hello, World' >>> 'Hello'.ljust(10) 'Hello\u00a0\u00a0\u00a0\u00a0\u00a0'\n\n'Hello'.rjust(10) says that we want to right-justify 'Hello' in a string of total length 10 . 'Hello' is five characters, so five spaces will be added to its left, giving us a string of 10 characters with 'Hello' justified right.\n\nAn optional second argument to rjust() and ljust() will specify a fill character other than a space character. Enter the following into the interactive shell:\n\n>>> 'Hello'.rjust(20, '*') '***************Hello' >>> 'Hello'.ljust(20, '-') 'Hello---------------'\n\nThe center() string method works like ljust() and rjust() but centers the text rather than justifying it to the left or right. Enter the following into the interactive shell:\n\n>>> 'Hello'.center(20) '\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hello\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0' >>> 'Hello'.center(20, '=') '=======Hello========'\n\nThese methods are especially useful when you need to print tabular data that has correct spacing. Open a new file editor window and enter the following code, saving it as picnicTable.py :\n\ndef printPicnic(itemsDict, leftWidth, rightWidth): print('PICNIC ITEMS'.center(leftWidth + rightWidth, '-')) for k, v in itemsDict.items(): print(k.ljust(leftWidth, '.') + str(v).rjust(rightWidth)) picnicItems = {'sandwiches': 4, 'apples': 12, 'cups': 4, 'cookies': 8000} printPicnic(picnicItems, 12, 5) printPicnic(picnicItems, 20, 6)\n\nYou can view the execution of this program at https://autbor.com/picnictable/ . In this program, we define a printPicnic() method that will take in a dictionary of information and use center() , ljust() , and rjust() to display that information in a neatly aligned table-like format.\n\nThe dictionary that we\u2019ll pass to printPicnic() is picnicItems . In picnicItems , we have 4 sandwiches, 12 apples, 4 cups, and 8,000 cookies. We want to organize this information into two columns, with the name of the item on the left and the quantity on the right.\n\nTo do this, we decide how wide we want the left and right columns to be. Along with our dictionary, we\u2019ll pass these values to printPicnic() .\n\nThe printPicnic() function takes in a dictionary, a leftWidth for the left column of a table, and a rightWidth for the right column. It prints a title, PICNIC ITEMS , centered above the table. Then, it loops through the dictionary, printing each key-value pair on a line with the key justified left and padded by periods, and the value justified right and padded by spaces.\n\nAfter defining printPicnic() , we define the dictionary picnicItems and call printPicnic() twice, passing it different widths for the left and right table columns.\n\nWhen you run this program, the picnic items are displayed twice. The first time the left column is 12 characters wide, and the right column is 5 characters wide. The second time they are 20 and 6 characters wide, respectively.\n\n---PICNIC ITEMS-- sandwiches..\u00a0\u00a0\u00a0\u00a04 apples......\u00a0\u00a0\u00a012 cups........\u00a0\u00a0\u00a0\u00a04 cookies..... 8000 -------PICNIC ITEMS------- sandwiches..........\u00a0\u00a0\u00a0\u00a0\u00a04 apples..............\u00a0\u00a0\u00a0\u00a012 cups................\u00a0\u00a0\u00a0\u00a0\u00a04 cookies.............\u00a0\u00a08000\n\nUsing rjust() , ljust() , and center() lets you ensure that strings are neatly aligned, even if you aren\u2019t sure how many characters long your strings are.\n\nSometimes you may want to strip off whitespace characters (space, tab, and newline) from the left side, right side, or both sides of a string. The strip() string method will return a new string without any whitespace characters at the beginning or end. The lstrip() and rstrip() methods will remove whitespace characters from the left and right ends, respectively. Enter the following into the interactive shell:\n\n>>> spam = '\u00a0\u00a0\u00a0\u00a0Hello, World\u00a0\u00a0\u00a0\u00a0' >>> spam.strip() 'Hello, World' >>> spam.lstrip() 'Hello, World\u00a0\u00a0\u00a0\u00a0' >>> spam.rstrip() '\u00a0\u00a0\u00a0\u00a0Hello, World'\n\nOptionally, a string argument will specify which characters on the ends should be stripped. Enter the following into the interactive shell:\n\n>>> spam = 'SpamSpamBaconSpamEggsSpamSpam' >>> spam.strip('ampS') 'BaconSpamEggs'\n\nPassing strip() the argument 'ampS' will tell it to strip occurrences of a , m , p , and capital S from the ends of the string stored in spam . The order of the characters in the string passed to strip() does not matter: strip('ampS') will do the same thing as strip('mapS') or strip('Spam') .", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "Explain the concept of 'Numeric Values of Characters with the ord() and chr() Functions' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Computers store information as bytes\u2014strings of binary numbers, which means we need to be able to convert text to numbers. Because of this, every text character has a corresponding numeric value called a Unicode code point . For example, the numeric code point is 65 for 'A' , 52 for '4' , and 33 for '!' . You can use the ord() function to get the code point of a one-character string, and the chr() function to get the one-character string of an integer code point. Enter the following into the interactive shell:\n\n>>> ord('A') 65 >>> ord('4') 52 >>> ord('!') 33 >>> chr(65) 'A'\n\nThese functions are useful when you need to do an ordering or mathematical operation on characters:\n\n>>> ord('B') 66 >>> ord('A') < ord('B') True >>> chr(ord('A')) 'A' >>> chr(ord('A') + 1) 'B'\n\nThere is more to Unicode and code points, but those details are beyond the scope of this book. If you\u2019d like to know more, I recommend watching Ned Batchelder\u2019s 2012 PyCon talk, \u201cPragmatic Unicode, or, How Do I Stop the Pain?\u201d at https://youtu.be/sgHbC6udIqc .", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "How do I use 'Copying and Pasting Strings with the pyperclip Module' in Python?", "input": "", "output": "The pyperclip module has copy() and paste() functions that can send text to and receive text from your computer\u2019s clipboard. Sending the output of your program to the clipboard will make it easy to paste it into an email, word processor, or some other software.\n\nThe pyperclip module does not come with Python. To install it, follow the directions for installing third-party modules in Appendix A. After installing pyperclip , enter the following into the interactive shell:\n\n>>> import pyperclip >>> pyperclip.copy('Hello, world!') >>> pyperclip.paste() 'Hello, world!'\n\nOf course, if something outside of your program changes the clipboard contents, the paste() function will return it. For example, if I copied this sentence to the clipboard and then called paste() , it would look like this:\n\n>>> pyperclip.paste() 'For example, if I copied this sentence to the clipboard and then called paste(), it would look like this:'", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "What is 'Project: Multi-Clipboard Automatic Messages' and how does it work in Python?", "input": "", "output": "If you\u2019ve responded to a large number of emails with similar phrasing, you\u2019ve probably had to do a lot of repetitive typing. Maybe you keep a text document with these phrases so you can easily copy and paste them using the clipboard. But your clipboard can only store one message at a time, which isn\u2019t very convenient. Let\u2019s make this process a bit easier with a program that stores multiple phrases.\n\nYou want to be able to run this program with a command line argument that is a short key phrase\u2014for instance, agree or busy . The message associated with that key phrase will be copied to the clipboard so that the user can paste it into an email. This way, the user can have long, detailed messages without having to retype them.\n\nOpen a new file editor window and save the program as mclip.py . You need to start the program with a #! ( shebang ) line (see Appendix B) and should also write a comment that briefly describes the program. Since you want to associate each piece of text with its key phrase, you can store these as strings in a dictionary. The dictionary will be the data structure that organizes your key phrases and text. Make your program look like the following:\n\n#! python3 # mclip.py - A multi-clipboard program. TEXT = {'agree': \"\"\"Yes, I agree. That sounds fine to me.\"\"\", 'busy': \"\"\"Sorry, can we do this later this week or next week?\"\"\", 'upsell': \"\"\"Would you consider making this a monthly donation?\"\"\"}\n\nThe command line arguments will be stored in the variable sys.argv . (See Appendix B for more information on how to use command line arguments in your programs.) The first item in the sys.argv list should always be a string containing the program\u2019s filename ( 'mclip.py' ), and the second item should be the first command line argument. For this program, this argument is the key phrase of the message you want. Since the command line argument is mandatory, you display a usage message to the user if they forget to add it (that is, if the sys.argv list has fewer than two values in it). Make your program look like the following:\n\n#! python3 # mclip.py - A multi-clipboard program. TEXT = {'agree': \"\"\"Yes, I agree. That sounds fine to me.\"\"\", 'busy': \"\"\"Sorry, can we do this later this week or next week?\"\"\", 'upsell': \"\"\"Would you consider making this a monthly donation?\"\"\"} i mport sys if len(sys.argv) < 2: print('Usage: python mclip.py [keyphrase] - copy phrase text') sys.exit() keyphrase = sys.argv[1]\u00a0\u00a0\u00a0\u00a0# first command line arg is the keyphrase\n\nNow that the key phrase is stored as a string in the variable keyphrase , you need to see whether it exists in the TEXT dictionary as a key. If so, you want to copy the key\u2019s value to the clipboard using pyperclip.copy() . (Since you\u2019re using the pyperclip module, you need to import it.) Note that you don\u2019t actually need the keyphrase variable; you could just use sys.argv[1] everywhere keyphrase is used in this program. But a variable named keyphrase is much more readable than something cryptic like sys.argv[1] .\n\nMake your program look like the following:\n\n#! python3 # mclip.py - A multi-clipboard program. TEXT = {'agree': \"\"\"Yes, I agree. That sounds fine to me.\"\"\", 'busy': \"\"\"Sorry, can we do this later this week or next week?\"\"\", 'upsell': \"\"\"Would you consider making this a monthly donation?\"\"\"} import sys , pyperclip if len(sys.argv) < 2: print('Usage: py mclip.py [keyphrase] - copy phrase text') sys.exit() keyphrase = sys.argv[1]\u00a0\u00a0\u00a0\u00a0# first command line arg is the keyphrase if keyphrase in TEXT: pyperclip.copy(TEXT[keyphrase]) print('Text for ' + keyphrase + ' copied to clipboard.') else: print('There is no text for ' + keyphrase)\n\nThis new code looks in the TEXT dictionary for the key phrase. If the key phrase is a key in the dictionary, we get the value corresponding to that key, copy it to the clipboard, and print a message saying that we copied the value. Otherwise, we print a message saying there\u2019s no key phrase with that name.\n\nThat\u2019s the complete script. Using the instructions in Appendix B for launching command line programs easily, you now have a fast way to copy messages to the clipboard. You will have to modify the TEXT dictionary value in the source whenever you want to update the program with a new message.\n\nOn Windows, you can create a batch file to run this program with the WIN-R Run window. (For more about batch files, see Appendix B.) Enter the following into the file editor and save the file as mclip.bat in the C:\\Windows folder:\n\n@py.exe C:\\ path_to_file \\mclip.py %* @pause\n\nWith this batch file created, running the multi-clipboard program on Windows is just a matter of pressing WIN-R and typing mclip key phrase .", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "What is 'Project: Adding Bullets to Wiki Markup' and how does it work in Python?", "input": "", "output": "When editing a Wikipedia article, you can create a bulleted list by putting each list item on its own line and placing a star in front. But say you have a really large list that you want to add bullet points to. You could just type those stars at the beginning of each line, one by one. Or you could automate this task with a short Python script.\n\nThe bulletPointAdder.py script will get the text from the clipboard, add a star and space to the beginning of each line, and then paste this new text to the clipboard. For example, if I copied the following text (for the Wikipedia article \u201cList of Lists of Lists\u201d) to the clipboard:\n\nLists of animals Lists of aquarium life Lists of biologists by author abbreviation Lists of cultivars\n\nand then ran the bulletPointAdder.py program, the clipboard would then contain the following:\n\n* Lists of animals * Lists of aquarium life * Lists of biologists by author abbreviation * Lists of cultivars\n\nThis star-prefixed text is ready to be pasted into a Wikipedia article as a bulleted list.\n\nYou want the bulletPointAdder.py program to do the following:\n\n1. Paste text from the clipboard.\n2. Do something to it.\n3. Copy the new text to the clipboard.\n\nThat second step is a little tricky, but steps 1 and 3 are pretty straightforward: they just involve the pyperclip.copy() and pyperclip.paste() functions. For now, let\u2019s just write the part of the program that covers steps 1 and 3. Enter the following, saving the program as bulletPointAdder.py :\n\n#! python3 # bulletPointAdder.py - Adds Wikipedia bullet points to the start # of each line of text on the clipboard. import pyperclip text = pyperclip.paste() # TODO: Separate lines and add stars. pyperclip.copy(text)\n\nThe TODO comment is a reminder that you should complete this part of the program eventually. The next step is to actually implement that piece of the program.\n\nThe call to pyperclip.paste() returns all the text on the clipboard as one big string. If we used the \u201cList of Lists of Lists\u201d example, the string stored in text would look like this:\n\n'Lists of animals\\nLists of aquarium life\\nLists of biologists by author abbreviation\\nLists of cultivars'\n\nThe \\n newline characters in this string cause it to be displayed with multiple lines when it is printed or pasted from the clipboard. There are many \u201clines\u201d in this one string value. You want to add a star to the start of each of these lines.\n\nYou could write code that searches for each \\n newline character in the string and then adds the star just after that. But it would be easier to use the split() method to return a list of strings, one for each line in the original string, and then add the star to the front of each string in the list.\n\nMake your program look like the following:\n\n#! python3 # bulletPointAdder.py - Adds Wikipedia bullet points to the start # of each line of text on the clipboard. import pyperclip text = pyperclip.paste() # Separate lines and add stars. lines = text.split('\\n') for i in range(len(lines)):\u00a0\u00a0\u00a0\u00a0# loop through all indexes in the \"lines\" list lines[i] = '* ' + lines[i] # add star to each string in \"lines\" list pyperclip.copy(text)\n\nWe split the text along its newlines to get a list in which each item is one line of the text. We store the list in lines and then loop through the items in lines . For each line, we add a star and a space to the start of the line. Now each string in lines begins with a star.\n\nThe lines list now contains modified lines that start with stars. But pyperclip.copy() is expecting a single string value, however, not a list of string values. To make this single string value, pass lines into the join() method to get a single string joined from the list\u2019s strings. Make your program look like the following:\n\n#! python3 # bulletPointAdder.py - Adds Wikipedia bullet points to the start # of each line of text on the clipboard. import pyperclip text = pyperclip.paste() # Separate lines and add stars. lines = text.split('\\n') for i in range(len(lines)):\u00a0\u00a0\u00a0\u00a0# loop through all indexes for \"lines\" list lines[i] = '* ' + lines[i] # add star to each string in \"lines\" list text = '\\n'.join(lines) pyperclip.copy(text)\n\nWhen this program is run, it replaces the text on the clipboard with text that has stars at the start of each line. Now the program is complete, and you can try running it with text copied to the clipboard.\n\nEven if you don\u2019t need to automate this specific task, you might want to automate some other kind of text manipulation, such as removing trailing spaces from the end of lines or converting text to uppercase or lowercase. Whatever your needs, you can use the clipboard for input and output.", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "Provide a guide on 'A Short Program: Pig Latin' in Python.", "input": "", "output": "Pig Latin is a silly made-up language that alters English words. If a word begins with a vowel, the word yay is added to the end of it. If a word begins with a consonant or consonant cluster (like ch or gr ), that consonant or cluster is moved to the end of the word followed by ay .\n\nLet\u2019s write a Pig Latin program that will output something like this:\n\nEnter the English message to translate into Pig Latin: My name is AL SWEIGART and I am 4,000 years old. Ymay amenay isyay ALYAY EIGARTSWAY andyay Iyay amyay 4,000 yearsyay oldyay.\n\nThis program works by altering a string using the methods introduced in this chapter. Type the following source code into the file editor, and save the file as pigLat.py :\n\n# English to Pig Latin print('Enter the English message to translate into Pig Latin:') message = input() VOWELS = ('a', 'e', 'i', 'o', 'u', 'y') pigLatin = [] # A list of the words in Pig Latin. for word in message.split(): # Separate the non-letters at the start of this word: prefixNonLetters = '' while len(word) > 0 and not word[0].isalpha(): prefixNonLetters += word[0] word = word[1:] if len(word) == 0: pigLatin.append(prefixNonLetters) continue # Separate the non-letters at the end of this word: suffixNonLetters = '' while not word[-1].isalpha(): suffixNonLetters = word[-1] + suffixNonLetters word = word[:-1] # Remember if the word was in uppercase or title case. wasUpper = word.isupper() wasTitle = word.istitle() word = word.lower() # Make the word lowercase for translation. # Separate the consonants at the start of this word: prefixConsonants = '' while len(word) > 0 and not word[0] in VOWELS: prefixConsonants += word[0] word = word[1:] # Add the Pig Latin ending to the word: if prefixConsonants != '': word += prefixConsonants + 'ay' else: word += 'yay' # Set the word back to uppercase or title case: if wasUpper: word = word.upper() if wasTitle: word = word.title() # Add the non-letters back to the start or end of the word. pigLatin.append(prefixNonLetters + word + suffixNonLetters) # Join all the words back together into a single string: print(' '.join(pigLatin))\n\nLet\u2019s look at this code line by line, starting at the top:\n\n# English to Pig Latin print('Enter the English message to translate into Pig Latin:') message = input() VOWELS = ('a', 'e', 'i', 'o', 'u', 'y')\n\nFirst, we ask the user to enter the English text to translate into Pig Latin. Also, we create a constant that holds every lowercase vowel letter (and y ) as a tuple of strings. This will be used later in our program.\n\nNext, we\u2019re going to create the pigLatin variable to store the words as we translate them into Pig Latin:\n\npigLatin = [] # A list of the words in Pig Latin. for word in message.split(): # Separate the non-letters at the start of this word: prefixNonLetters = '' while len(word) > 0 and not word[0].isalpha(): prefixNonLetters += word[0] word = word[1:] if len(word) == 0: pigLatin.append(prefixNonLetters) continue\n\nWe need each word to be its own string, so we call message.split() to get a list of the words as separate strings. The string 'My name is AL SWEIGART and I am 4,000 years old.' would cause split() to return ['My', 'name', 'is', 'AL', 'SWEIGART', 'and', 'I', 'am', '4,000', 'years', 'old.'] .\n\nWe need to remove any non-letters from the start and end of each word so that strings like 'old.' translate to 'oldyay.' instead of 'old.yay' . We\u2019ll save these non-letters to a variable named prefixNonLetters .\n\n# Separate the non-letters at the end of this word: suffixNonLetters = '' while not word[-1].isalpha(): suffixNonLetters = word[-1] + suffixNonLetters word = word[:-1]\n\nA loop that calls isalpha() on the first character in the word will determine if we should remove a character from a word and concatenate it to the end of prefixNonLetters . If the entire word is made of non-letter characters, like '4,000' , we can simply append it to the pigLatin list and continue to the next word to translate. We also need to save the non-letters at the end of the word string. This code is similar to the previous loop.\n\nNext, we\u2019ll make sure the program remembers if the word was in uppercase or title case so we can restore it after translating the word to Pig Latin:\n\n# Remember if the word was in uppercase or title case. wasUpper = word.isupper() wasTitle = word.istitle() word = word.lower() # Make the word lowercase for translation.\n\nFor the rest of the code in the for loop, we\u2019ll work on a lowercase version of word .\n\nTo convert a word like sweigart to eigart-sway , we need to remove all of the consonants from the beginning of word :\n\n# Separate the consonants at the start of this word: prefixConsonants = '' while len(word) > 0 and not word[0] in VOWELS: prefixConsonants += word[0] word = word[1:]\n\nWe use a loop similar to the loop that removed the non-letters from the start of word , except now we are pulling off consonants and storing them to a variable named prefixConsonants .\n\nIf there were any consonants at the start of the word, they are now in prefixConsonants and we should concatenate that variable and the string 'ay' to the end of word . Otherwise, we can assume word begins with a vowel and we only need to concatenate 'yay' :\n\n# Add the Pig Latin ending to the word: if prefixConsonants != '': word += prefixConsonants + 'ay' else: word += 'yay'\n\nRecall that we set word to its lowercase version with word = word.lower() . If word was originally in uppercase or title case, this code will convert word back to its original case:\n\n# Set the word back to uppercase or title case: if wasUpper: word = word.upper() if wasTitle: word = word.title()\n\nAt the end of the for loop, we append the word, along with any non-letter prefix or suffix it originally had, to the pigLatin list:\n\n# Add the non-letters back to the start or end of the word. pigLatin.append(prefixNonLetters + word + suffixNonLetters) # Join all the words back together into a single string: print(' '.join(pigLatin))\n\nAfter this loop finishes, we combine the list of strings into a single string by calling the join() method. This single string is passed to print() to display our Pig Latin on the screen.\n\nYou can find other short, text-based Python programs like this one at https://github.com/asweigart/pythonstdiogames/ .", "source": "https://automatetheboringstuff.com/2e/chapter6/", "category": "6MANIPULATING STRINGS"}
{"instruction": "How do I use '7PATTERN MATCHING WITH REGULAR EXPRESSIONS' in Python?", "input": "", "output": "You may be familiar with searching for text by pressing CTRL- F and entering the words you\u2019re looking for. Regular expressions go one step further: they allow you to specify a pattern of text to search for. You may not know a business\u2019s exact phone number, but if you live in the United States or Canada, you know it will be three digits, followed by a hyphen, and then four more digits (and optionally, a three-digit area code at the start). This is how you, as a human, know a phone number when you see it: 415-555-1234 is a phone number, but 4,155,551,234 is not.\n\nWe also recognize all sorts of other text patterns every day: email addresses have @ symbols in the middle, US social security numbers have nine digits and two hyphens, website URLs often have periods and forward slashes, news headlines use title case, social media hashtags begin with # and contain no spaces, and more.\n\nRegular expressions are helpful, but few non-programmers know about them even though most modern text editors and word processors, such as Microsoft Word or OpenOffice, have find and find-and-replace features that can search based on regular expressions. Regular expressions are huge time-savers, not just for software users but also for programmers. In fact, tech writer Cory Doctorow argues that we should be teaching regular expressions even before programming:\n\nKnowing [regular expressions] can mean the difference between solving a problem in 3 steps and solving it in 3,000 steps. When you\u2019re a nerd, you forget that the problems you solve with a couple keystrokes can take other people days of tedious, error-prone work to slog through. 1\n\nIn this chapter, you\u2019ll start by writing a program to find text patterns without using regular expressions and then see how to use regular expressions to make the code much less bloated. I\u2019ll show you basic matching with regular expressions and then move on to some more powerful features, such as string substitution and creating your own character classes. Finally, at the end of the chapter, you\u2019ll write a program that can automatically extract phone numbers and email addresses from a block of text.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "How do I use 'Finding Patterns of Text Without Regular Expressions' in Python?", "input": "", "output": "Say you want to find an American phone number in a string. You know the pattern if you\u2019re American: three numbers, a hyphen, three numbers, a hyphen, and four numbers. Here\u2019s an example: 415-555-4242.\n\nLet\u2019s use a function named isPhoneNumber() to check whether a string matches this pattern, returning either True or False . Open a new file editor tab and enter the following code; then save the file as isPhoneNumber.py :\n\ndef isPhoneNumber(text): \u278a if len(text) != 12: return False for i in range(0, 3): \u278b if not text[i].isdecimal(): return False \u278c if text[3] != '-': return False for i in range(4, 7): \u278d if not text[i].isdecimal(): return False \u278e if text[7] != '-': return False for i in range(8, 12): \u278f if not text[i].isdecimal(): return False \u2790 return True print('Is 415-555-4242 a phone number?') print(isPhoneNumber('415-555-4242')) print('Is Moshi moshi a phone number?') print(isPhoneNumber('Moshi moshi'))\n\nWhen this program is run, the output looks like this:\n\nIs 415-555-4242 a phone number? True Is Moshi moshi a phone number? False\n\nThe isPhoneNumber() function has code that does several checks to see whether the string in text is a valid phone number. If any of these checks fail, the function returns False . First the code checks that the string is exactly 12 characters \u278a . Then it checks that the area code (that is, the first three characters in text ) consists of only numeric characters \u278b . The rest of the function checks that the string follows the pattern of a phone number: the number must have the first hyphen after the area code \u278c , three more numeric characters \u278d , then another hyphen \u278e , and finally four more numbers \u278f . If the program execution manages to get past all the checks, it returns True \u2790 .\n\nCalling isPhoneNumber() with the argument '415-555-4242' will return True . Calling isPhoneNumber() with 'Moshi moshi' will return False ; the first test fails because 'Moshi moshi' is not 12 characters long.\n\nIf you wanted to find a phone number within a larger string, you would have to add even more code to find the phone number pattern. Replace the last four print() function calls in isPhoneNumber.py with the following:\n\nmessage = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.' for i in range(len(message)): \u278a chunk = message[i:i+12] \u278b if isPhoneNumber(chunk): print('Phone number found: ' + chunk) print('Done')\n\nWhen this program is run, the output will look like this:\n\nPhone number found: 415-555-1011 Phone number found: 415-555-9999 Done\n\nOn each iteration of the for loop, a new chunk of 12 characters from message is assigned to the variable chunk \u278a . For example, on the first iteration, i is 0 , and chunk is assigned message[0:12] (that is, the string 'Call me at 4' ). On the next iteration, i is 1 , and chunk is assigned message[1:13] (the string 'all me at 41' ). In other words, on each iteration of the for loop, chunk takes on the following values:\n\n* 'Call me at 4'\n* 'all me at 41'\n* 'll me at 415'\n* 'l me at 415-'\n* . . . and so on.\n\nYou pass chunk to isPhoneNumber() to see whether it matches the phone number pattern \u278b , and if so, you print the chunk.\n\nContinue to loop through message , and eventually the 12 characters in chunk will be a phone number. The loop goes through the entire string, testing each 12-character piece and printing any chunk it finds that satisfies isPhoneNumber() . Once we\u2019re done going through message , we print Done .\n\nWhile the string in message is short in this example, it could be millions of characters long and the program would still run in less than a second. A similar program that finds phone numbers using regular expressions would also run in less than a second, but regular expressions make it quicker to write these programs.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "How do I use 'Finding Patterns of Text with Regular Expressions' in Python?", "input": "", "output": "The previous phone number\u2013finding program works, but it uses a lot of code to do something limited: the isPhoneNumber() function is 17 lines but can find only one pattern of phone numbers. What about a phone number formatted like 415.555.4242 or (415) 555-4242? What if the phone number had an extension, like 415-555-4242 x99? The isPhoneNumber() function would fail to validate them. You could add yet more code for these additional patterns, but there is an easier way.\n\nRegular expressions, called regexes for short, are descriptions for a pattern of text. For example, a \\d in a regex stands for a digit character\u2014that is, any single numeral from 0 to 9. The regex \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d is used by Python to match the same text pattern the previous isPhoneNumber() function did: a string of three numbers, a hyphen, three more numbers, another hyphen, and four numbers. Any other string would not match the \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d regex.\n\nBut regular expressions can be much more sophisticated. For example, adding a 3 in braces ( {3} ) after a pattern is like saying, \u201cMatch this pattern three times.\u201d So the slightly shorter regex \\d{3}-\\d{3}-\\d{4} also matches the correct phone number format.\n\nAll the regex functions in Python are in the re module. Enter the following into the interactive shell to import this module:\n\n>>> import re\n\nPassing a string value representing your regular expression to re.compile() returns a Regex pattern object (or simply, a Regex object).\n\nTo create a Regex object that matches the phone number pattern, enter the following into the interactive shell. (Remember that \\d means \u201ca digit character\u201d and \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d is the regular expression for a phone number pattern.)\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d')\n\nNow the phoneNumRegex variable contains a Regex object.\n\nA Regex object\u2019s search() method searches the string it is passed for any matches to the regex. The search() method will return None if the regex pattern is not found in the string. If the pattern is found, the search() method returns a Match object, which have a group() method that will return the actual matched text from the searched string. (I\u2019ll explain groups shortly.) For example, enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') >>> mo = phoneNumRegex.search('My number is 415-555-4242.') >>> print('Phone number found: ' + mo.group()) Phone number found: 415-555-4242\n\nThe mo variable name is just a generic name to use for Match objects. This example might seem complicated at first, but it is much shorter than the earlier isPhoneNumber.py program and does the same thing.\n\nHere, we pass our desired pattern to re.compile() and store the resulting Regex object in phoneNumRegex . Then we call search() on phoneNumRegex and pass search() the string we want to match for during the search. The result of the search gets stored in the variable mo . In this example, we know that our pattern will be found in the string, so we know that a Match object will be returned. Knowing that mo contains a Match object and not the null value None , we can call group() on mo to return the match. Writing mo.group() inside our print() function call displays the whole match, 415-555-4242 .\n\nWhile there are several steps to using regular expressions in Python, each step is fairly simple.\n\n1. Import the regex module with import re .\n2. Create a Regex object with the re.compile() function. (Remember to use a raw string.)\n3. Pass the string you want to search into the Regex object\u2019s search() method. This returns a Match object.\n4. Call the Match object\u2019s group() method to return a string of the actual matched text.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "How do I use 'More Pattern Matching with Regular Expressions' in Python?", "input": "", "output": "Now that you know the basic steps for creating and finding regular expression objects using Python, you\u2019re ready to try some of their more powerful pattern-matching capabilities.\n\nSay you want to separate the area code from the rest of the phone number. Adding parentheses will create groups in the regex: (\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d) . Then you can use the group() match object method to grab the matching text from just one group.\n\nThe first set of parentheses in a regex string will be group 1 . The second set will be group 2 . By passing the integer 1 or 2 to the group() match object method, you can grab different parts of the matched text. Passing 0 or nothing to the group() method will return the entire matched text. Enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d-\\d\\d\\d\\d)') >>> mo = phoneNumRegex.search('My number is 415-555-4242.') >>> mo.group(1) '415' >>> mo.group(2) '555-4242' >>> mo.group(0) '415-555-4242' >>> mo.group() '415-555-4242'\n\nIf you would like to retrieve all the groups at once, use the groups() method\u2014note the plural form for the name.\n\n>>> mo.groups() ('415', '555-4242') >>> areaCode, mainNumber = mo.groups() >>> print(areaCode) 415 >>> print(mainNumber) 555-4242\n\nSince mo.groups() returns a tuple of multiple values, you can use the multiple-assignment trick to assign each value to a separate variable, as in the previous areaCode, mainNumber = mo.groups() line.\n\nParentheses have a special meaning in regular expressions, but what do you do if you need to match a parenthesis in your text? For instance, maybe the phone numbers you are trying to match have the area code set in parentheses. In this case, you need to escape the ( and ) characters with a backslash. Enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'(\\(\\d\\d\\d\\)) (\\d\\d\\d-\\d\\d\\d\\d)') >>> mo = phoneNumRegex.search('My phone number is (415) 555-4242.') >>> mo.group(1) '(415)' >>> mo.group(2) '555-4242'\n\nThe \\( and \\) escape characters in the raw string passed to re.compile() will match actual parenthesis characters. In regular expressions, the following characters have special meanings:\n\n.\u00a0\u00a0^\u00a0\u00a0$\u00a0\u00a0*\u00a0\u00a0+\u00a0\u00a0?\u00a0\u00a0{\u00a0\u00a0}\u00a0\u00a0[\u00a0\u00a0]\u00a0\u00a0\\\u00a0\u00a0|\u00a0\u00a0(\u00a0\u00a0)\n\nIf you want to detect these characters as part of your text pattern, you need to escape them with a backslash:\n\n\\.\u00a0\u00a0\\^\u00a0\u00a0\\$\u00a0\u00a0\\*\u00a0\u00a0\\+\u00a0\u00a0\\?\u00a0\u00a0\\{\u00a0\u00a0\\}\u00a0\u00a0\\[\u00a0\u00a0\\]\u00a0\u00a0\\\\\u00a0\u00a0\\|\u00a0\u00a0\\(\u00a0\u00a0\\)\n\nMake sure to double-check that you haven\u2019t mistaken escaped parentheses \\( and \\) for parentheses ( and ) in a regular expression. If you receive an error message about \u201cmissing )\u201d or \u201cunbalanced parenthesis,\u201d you may have forgotten to include the closing unescaped parenthesis for a group, like in this example:\n\n>>> re.compile(r'(\\(Parentheses\\)') Traceback (most recent call last): -- snip -- re.error: missing ), unterminated subpattern at position 0\n\nThe error message tells you that there is an opening parenthesis at index 0 of the r'(\\(Parentheses\\)' string that is missing its corresponding closing parenthesis.\n\nThe | character is called a pipe . You can use it anywhere you want to match one of many expressions. For example, the regular expression r'Batman|Tina Fey' will match either 'Batman' or 'Tina Fey' .\n\nWhen both Batman and Tina Fey occur in the searched string, the first occurrence of matching text will be returned as the Match object. Enter the following into the interactive shell:\n\n>>> heroRegex = re.compile (r'Batman|Tina Fey') >>> mo1 = heroRegex.search('Batman and Tina Fey') >>> mo1.group() 'Batman' >>> mo2 = heroRegex.search('Tina Fey and Batman') >>> mo2.group() 'Tina Fey'\n\nYou can also use the pipe to match one of several patterns as part of your regex. For example, say you wanted to match any of the strings 'Batman' , 'Batmobile' , 'Batcopter' , and 'Batbat' . Since all these strings start with Bat , it would be nice if you could specify that prefix only once. This can be done with parentheses. Enter the following into the interactive shell:\n\n>>> batRegex = re.compile(r'Bat(man|mobile|copter|bat)') >>> mo = batRegex.search('Batmobile lost a wheel') >>> mo.group() 'Batmobile' >>> mo.group(1) 'mobile'\n\nThe method call mo.group() returns the full matched text 'Batmobile' , while mo.group(1) returns just the part of the matched text inside the first parentheses group, 'mobile' . By using the pipe character and grouping parentheses, you can specify several alternative patterns you would like your regex to match.\n\nIf you need to match an actual pipe character, escape it with a backslash, like \\| .\n\nSometimes there is a pattern that you want to match only optionally. That is, the regex should find a match regardless of whether that bit of text is there. The ? character flags the group that precedes it as an optional part of the pattern. For example, enter the following into the interactive shell:\n\n>>> batRegex = re.compile(r'Bat(wo)?man') >>> mo1 = batRegex.search('The Adventures of Batman') >>> mo1.group() 'Batman' >>> mo2 = batRegex.search('The Adventures of Batwoman') >>> mo2.group() 'Batwoman'\n\nThe (wo)? part of the regular expression means that the pattern wo is an optional group. The regex will match text that has zero instances or one instance of wo in it. This is why the regex matches both 'Batwoman' and 'Batman' .\n\nUsing the earlier phone number example, you can make the regex look for phone numbers that do or do not have an area code. Enter the following into the interactive shell:\n\n>>> phoneRegex = re.compile(r'(\\d\\d\\d-)?\\d\\d\\d-\\d\\d\\d\\d') >>> mo1 = phoneRegex.search('My number is 415-555-4242') >>> mo1.group() '415-555-4242' >>> mo2 = phoneRegex.search('My number is 555-4242') >>> mo2.group() '555-4242'\n\nYou can think of the ? as saying, \u201cMatch zero or one of the group preceding this question mark.\u201d\n\nIf you need to match an actual question mark character, escape it with \\? .\n\nThe * (called the star or asterisk ) means \u201cmatch zero or more\u201d\u2014the group that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. Let\u2019s look at the Batman example again.\n\n>>> batRegex = re.compile(r'Bat(wo)*man') >>> mo1 = batRegex.search('The Adventures of Batman') >>> mo1.group() 'Batman' >>> mo2 = batRegex.search('The Adventures of Batwoman') >>> mo2.group() 'Batwoman' >>> mo3 = batRegex.search('The Adventures of Batwowowowoman') >>> mo3.group() 'Batwowowowoman'\n\nFor 'Batman' , the (wo)* part of the regex matches zero instances of wo in the string; for 'Batwoman' , the (wo)* matches one instance of wo ; and for 'Batwowowowoman' , (wo)* matches four instances of wo .\n\nIf you need to match an actual star character, prefix the star in the regular expression with a backslash, \\* .\n\nWhile * means \u201cmatch zero or more,\u201d the + (or plus ) means \u201cmatch one or more.\u201d Unlike the star, which does not require its group to appear in the matched string, the group preceding a plus must appear at least once . It is not optional. Enter the following into the interactive shell, and compare it with the star regexes in the previous section:\n\n>>> batRegex = re.compile(r'Bat(wo)+man') >>> mo1 = batRegex.search('The Adventures of Batwoman') >>> mo1.group() 'Batwoman' >>> mo2 = batRegex.search('The Adventures of Batwowowowoman') >>> mo2.group() 'Batwowowowoman' >>> mo3 = batRegex.search('The Adventures of Batman') >>> mo3 == None True\n\nThe regex Bat(wo)+man will not match the string 'The Adventures of Batman' , because at least one wo is required by the plus sign.\n\nIf you need to match an actual plus sign character, prefix the plus sign with a backslash to escape it: \\+ .\n\nIf you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in braces. For example, the regex (Ha){3} will match the string 'HaHaHa' , but it will not match 'HaHa' , since the latter has only two repeats of the (Ha) group.\n\nInstead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the braces. For example, the regex (Ha){3,5} will match 'HaHaHa' , 'HaHaHaHa' , and 'HaHaHaHaHa' .\n\nYou can also leave out the first or second number in the braces to leave the minimum or maximum unbounded. For example, (Ha){3,} will match three or more instances of the (Ha) group, while (Ha){,5} will match zero to five instances. Braces can help make your regular expressions shorter. These two regular expressions match identical patterns:\n\n(Ha){3} (Ha)(Ha)(Ha)\n\nAnd these two regular expressions also match identical patterns:\n\n(Ha){3,5} ((Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha))|((Ha)(Ha)(Ha)(Ha)(Ha))\n\nEnter the following into the interactive shell:\n\n>>> haRegex = re.compile(r'(Ha){3}') >>> mo1 = haRegex.search('HaHaHa') >>> mo1.group() 'HaHaHa' >>> mo2 = haRegex.search('Ha') >>> mo2 == None True\n\nHere, (Ha){3} matches 'HaHaHa' but not 'Ha' . Since it doesn\u2019t match 'Ha' , search() returns None .", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Explain the concept of 'Greedy and Non-greedy Matching' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Since (Ha){3,5} can match three, four, or five instances of Ha in the string 'HaHaHaHaHa' , you may wonder why the Match object\u2019s call to group() in the previous brace example returns 'HaHaHaHaHa' instead of the shorter possibilities. After all, 'HaHaHa' and 'HaHaHaHa' are also valid matches of the regular expression (Ha){3,5} .\n\nPython\u2019s regular expressions are greedy by default, which means that in ambiguous situations they will match the longest string possible. The non-greedy (also called lazy ) version of the braces, which matches the shortest string possible, has the closing brace followed by a question mark.\n\nEnter the following into the interactive shell, and notice the difference between the greedy and non-greedy forms of the braces searching the same string:\n\n>>> greedyHaRegex = re.compile(r'(Ha){3,5}') >>> mo1 = greedyHaRegex.search('HaHaHaHaHa') >>> mo1.group() 'HaHaHaHaHa' >>> nongreedyHaRegex = re.compile(r'(Ha){3,5}?') >>> mo2 = nongreedyHaRegex.search('HaHaHaHaHa') >>> mo2.group() 'HaHaHa'\n\nNote that the question mark can have two meanings in regular expressions: declaring a non-greedy match or flagging an optional group. These meanings are entirely unrelated.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Provide a guide on 'The findall() Method' in Python.", "input": "", "output": "In addition to the search() method, Regex objects also have a findall() method. While search() will return a Match object of the first matched text in the searched string, the findall() method will return the strings of every match in the searched string. To see how search() returns a Match object only on the first instance of matching text, enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') >>> mo = phoneNumRegex.search('Cell: 415-555-9999 Work: 212-555-0000') >>> mo.group() '415-555-9999'\n\nOn the other hand, findall() will not return a Match object but a list of strings\u2014 as long as there are no groups in the regular expression . Each string in the list is a piece of the searched text that matched the regular expression. Enter the following into the interactive shell:\n\n>>> phoneNumRegex = re.compile(r'\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d') # has no groups >>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000') ['415-555-9999', '212-555-0000']\n\nIf there are groups in the regular expression, then findall() will return a list of tuples. Each tuple represents a found match, and its items are the matched strings for each group in the regex. To see findall() in action, enter the following into the interactive shell (notice that the regular expression being compiled now has groups in parentheses):\n\n>>> phoneNumRegex = re.compile(r'(\\d\\d\\d)-(\\d\\d\\d)-(\\d\\d\\d\\d)') # has groups >>> phoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000') [('415', '555', '9999'), ('212', '555', '0000')]\n\nTo summarize what the findall() method returns, remember the following:\n\n* When called on a regex with no groups, such as \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d , the method findall() returns a list of string matches, such as ['415-555-9999', '212-555-0000'] .\n* When called on a regex that has groups, such as (\\d\\d\\d)-(\\d\\d\\d)-(\\d\\d\\d\\d) , the method findall() returns a list of tuples of strings (one string for each group), such as [('415', '555', '9999'), ('212', '555', '0000')] .", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Explain the concept of 'Character Classes' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "In the earlier phone number regex example, you learned that \\d could stand for any numeric digit. That is, \\d is shorthand for the regular expression (0|1|2|3|4|5|6|7|8|9) . There are many such shorthand character classes , as shown in Table 7-1.\n\nTable 7-1: Shorthand Codes for Common Character Classes\n\nCharacter classes are nice for shortening regular expressions. The character class [0-5] will match only the numbers 0 to 5 ; this is much shorter than typing (0|1|2|3|4|5) . Note that while \\d matches digits and \\w matches digits, letters, and the underscore, there is no shorthand character class that matches only letters. (Though you can use the [a-zA-Z] character class, as explained next.)\n\nFor example, enter the following into the interactive shell:\n\n>>> xmasRegex = re.compile(r'\\d+\\s\\w+') >>> xmasRegex.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, 7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge') ['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']\n\nThe regular expression \\d+\\s\\w+ will match text that has one or more numeric digits ( \\d+ ), followed by a whitespace character ( \\s ), followed by one or more letter/digit/underscore characters ( \\w+ ). The findall() method returns all matching strings of the regex pattern in a list.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "What is 'Making Your Own Character Classes' and how does it work in Python?", "input": "", "output": "There are times when you want to match a set of characters but the shorthand character classes ( \\d , \\w , \\s , and so on) are too broad. You can define your own character class using square brackets. For example, the character class [aeiouAEIOU] will match any vowel, both lowercase and uppercase. Enter the following into the interactive shell:\n\n>>> vowelRegex = re.compile(r'[aeiouAEIOU]') >>> vowelRegex.findall('RoboCop eats baby food. BABY FOOD.') ['o', 'o', 'o', 'e', 'a', 'a', 'o', 'o', 'A', 'O', 'O']\n\nYou can also include ranges of letters or numbers by using a hyphen. For example, the character class [a-zA-Z0-9] will match all lowercase letters, uppercase letters, and numbers.\n\nNote that inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape the . , * , ? , or () characters with a preceding backslash. For example, the character class [0-5.] will match digits 0 to 5 and a period. You do not need to write it as [0-5\\.] .\n\nBy placing a caret character ( ^ ) just after the character class\u2019s opening bracket, you can make a negative character class . A negative character class will match all the characters that are not in the character class. For example, enter the following into the interactive shell:\n\n>>> consonantRegex = re.compile(r'[^aeiouAEIOU]') >>> consonantRegex.findall('RoboCop eats baby food. BABY FOOD.') ['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'b', 'b', 'y', ' ', 'f', 'd', '.', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']\n\nNow, instead of matching every vowel, we\u2019re matching every character that isn\u2019t a vowel.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "What is 'The Caret and Dollar Sign Characters' and how does it work in Python?", "input": "", "output": "You can also use the caret symbol ( ^ ) at the start of a regex to indicate that a match must occur at the beginning of the searched text. Likewise, you can put a dollar sign ( $ ) at the end of the regex to indicate the string must end with this regex pattern. And you can use the ^ and $ together to indicate that the entire string must match the regex\u2014that is, it\u2019s not enough for a match to be made on some subset of the string.\n\nFor example, the r'^Hello' regular expression string matches strings that begin with 'Hello' . Enter the following into the interactive shell:\n\n>>> beginsWithHello = re.compile(r'^Hello') >>> beginsWithHello.search('Hello, world!') <re.Match object; span=(0, 5), match='Hello'> >>> beginsWithHello.search('He said hello.') == None True\n\nThe r'\\d$' regular expression string matches strings that end with a numeric character from 0 to 9. Enter the following into the interactive shell:\n\n>>> endsWithNumber = re.compile(r'\\d$') >>> endsWithNumber.search('Your number is 42') <re.Match object; span=(16, 17), match='2'> >>> endsWithNumber.search('Your number is forty two.') == None True\n\nThe r'^\\d+$' regular expression string matches strings that both begin and end with one or more numeric characters. Enter the following into the interactive shell:\n\n>>> wholeStringIsNum = re.compile(r'^\\d+$') >>> wholeStringIsNum.search('1234567890') <re.Match object; span=(0, 10), match='1234567890'> >>> wholeStringIsNum.search('12345xyz67890') == None True >>> wholeStringIsNum.search('12\u00a0\u00a034567890') == None True\n\nThe last two search() calls in the previous interactive shell example demonstrate how the entire string must match the regex if ^ and $ are used.\n\nI always confuse the meanings of these two symbols, so I use the mnemonic \u201cCarrots cost dollars\u201d to remind myself that the caret comes first and the dollar sign comes last.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Provide a guide on 'The Wildcard Character' in Python.", "input": "", "output": "The . (or dot ) character in a regular expression is called a wildcard and will match any character except for a newline. For example, enter the following into the interactive shell:\n\n>>> atRegex = re.compile(r'.at') >>> atRegex.findall('The cat in the hat sat on the flat mat.') ['cat', 'hat', 'sat', 'lat', 'mat']\n\nRemember that the dot character will match just one character, which is why the match for the text flat in the previous example matched only lat . To match an actual dot, escape the dot with a backslash: \\. .\n\nSometimes you will want to match everything and anything. For example, say you want to match the string 'First Name:' , followed by any and all text, followed by 'Last Name:' , and then followed by anything again. You can use the dot-star ( .* ) to stand in for that \u201canything.\u201d Remember that the dot character means \u201cany single character except the newline,\u201d and the star character means \u201czero or more of the preceding character.\u201d\n\nEnter the following into the interactive shell:\n\n>>> nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)') >>> mo = nameRegex.search('First Name: Al Last Name: Sweigart') >>> mo.group(1) 'Al' >>> mo.group(2) 'Sweigart'\n\nThe dot-star uses greedy mode: It will always try to match as much text as possible. To match any and all text in a non-greedy fashion, use the dot, star, and question mark ( .*? ). Like with braces, the question mark tells Python to match in a non-greedy way.\n\nEnter the following into the interactive shell to see the difference between the greedy and non-greedy versions:\n\n>>> nongreedyRegex = re.compile(r'<.*?>') >>> mo = nongreedyRegex.search('<To serve man> for dinner.>') >>> mo.group() '<To serve man>' >>> greedyRegex = re.compile(r'<.*>') >>> mo = greedyRegex.search('<To serve man> for dinner.>') >>> mo.group() '<To serve man> for dinner.>'\n\nBoth regexes roughly translate to \u201cMatch an opening angle bracket, followed by anything, followed by a closing angle bracket.\u201d But the string '<To serve man> for dinner.>' has two possible matches for the closing angle bracket. In the non-greedy version of the regex, Python matches the shortest possible string: '<To serve man>' . In the greedy version, Python matches the longest possible string: '<To serve man> for dinner.>' .\n\nThe dot-star will match everything except a newline. By passing re.DOTALL as the second argument to re.compile() , you can make the dot character match all characters, including the newline character.\n\nEnter the following into the interactive shell:\n\n>>> noNewlineRegex = re.compile('.*') >>> noNewlineRegex.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group() 'Serve the public trust.' >>> newlineRegex = re.compile('.*', re.DOTALL) >>> newlineRegex.search('Serve the public trust.\\nProtect the innocent. \\nUphold the law.').group() 'Serve the public trust.\\nProtect the innocent.\\nUphold the law.'\n\nThe regex noNewlineRegex , which did not have re.DOTALL passed to the re.compile() call that created it, will match everything only up to the first newline character, whereas newlineRegex , which did have re.DOTALL passed to re.compile() , matches everything. This is why the newlineRegex.search() call matches the full string, including its newline characters.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "How do I use 'Review of Regex Symbols' in Python?", "input": "", "output": "This chapter covered a lot of notation, so here\u2019s a quick review of what you learned about basic regular expression syntax:\n\n* The ? matches zero or one of the preceding group.\n* The * matches zero or more of the preceding group.\n* The + matches one or more of the preceding group.\n* The {n} matches exactly n of the preceding group.\n* The {n,} matches n or more of the preceding group.\n* The {,m} matches 0 to m of the preceding group.\n* The {n,m} matches at least n and at most m of the preceding group.\n* {n,m}? or *? or +? performs a non-greedy match of the preceding group.\n* ^spam means the string must begin with spam .\n* spam$ means the string must end with spam .\n* The . matches any character, except newline characters.\n* \\d , \\w , and \\s match a digit, word, or space character, respectively.\n* \\D , \\W , and \\S match anything except a digit, word, or space character, respectively.\n* [abc] matches any character between the brackets (such as a , b , or c ).\n* [^abc] matches any character that isn\u2019t between the brackets.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Explain the concept of 'Case-Insensitive Matching' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Normally, regular expressions match text with the exact casing you specify. For example, the following regexes match completely different strings:\n\n>>> regex1 = re.compile('RoboCop') >>> regex2 = re.compile('ROBOCOP') >>> regex3 = re.compile('robOcop') >>> regex4 = re.compile('RobocOp')\n\nBut sometimes you care only about matching the letters without worrying whether they\u2019re uppercase or lowercase. To make your regex case-insensitive, you can pass re.IGNORECASE or re.I as a second argument to re.compile() . Enter the following into the interactive shell:\n\n>>> robocop = re.compile(r'robocop', re.I) >>> robocop.search('RoboCop is part man, part machine, all cop.').group() 'RoboCop' >>> robocop.search('ROBOCOP protects the innocent.').group() 'ROBOCOP' >>> robocop.search('Al, why does your programming book talk about robocop so much?').group() 'robocop'", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Explain the concept of 'Substituting Strings with the sub() Method' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Regular expressions can not only find text patterns but can also substitute new text in place of those patterns. The sub() method for Regex objects is passed two arguments. The first argument is a string to replace any matches. The second is the string for the regular expression. The sub() method returns a string with the substitutions applied.\n\nFor example, enter the following into the interactive shell:\n\n>>> namesRegex = re.compile(r'Agent \\w+') >>> namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.') 'CENSORED gave the secret documents to CENSORED.'\n\nSometimes you may need to use the matched text itself as part of the substitution. In the first argument to sub() , you can type \\1 , \\2 , \\3 , and so on, to mean \u201cEnter the text of group 1 , 2 , 3 , and so on, in the substitution.\u201d\n\nFor example, say you want to censor the names of the secret agents by showing just the first letters of their names. To do this, you could use the regex Agent (\\w)\\w* and pass r'\\1****' as the first argument to sub() . The \\1 in that string will be replaced by whatever text was matched by group 1 \u2014that is, the (\\w) group of the regular expression.\n\n>>> agentNamesRegex = re.compile(r'Agent (\\w)\\w*') >>> agentNamesRegex.sub(r'\\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.') A**** told C**** that E**** knew B**** was a double agent.'", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Explain the concept of 'Managing Complex Regexes' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Regular expressions are fine if the text pattern you need to match is simple. But matching complicated text patterns might require long, convoluted regular expressions. You can mitigate this by telling the re.compile() function to ignore whitespace and comments inside the regular expression string. This \u201cverbose mode\u201d can be enabled by passing the variable re.VERBOSE as the second argument to re.compile() .\n\nNow instead of a hard-to-read regular expression like this:\n\nphoneRegex = re.compile(r'((\\d{3}|\\(\\d{3}\\))?(\\s|-|\\.)?\\d{3}(\\s|-|\\.)\\d{4} (\\s*(ext|x|ext.)\\s*\\d{2,5})?)')\n\nyou can spread the regular expression over multiple lines with comments like this:\n\nphoneRegex = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# area code (\\s|-|\\.)?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator \\d{3}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# first 3 digits (\\s|-|\\.)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator \\d{4}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# last 4 digits (\\s*(ext|x|ext.)\\s*\\d{2,5})?\u00a0\u00a0# extension )''', re.VERBOSE)\n\nNote how the previous example uses the triple-quote syntax ( ''' ) to create a multiline string so that you can spread the regular expression definition over many lines, making it much more legible.\n\nThe comment rules inside the regular expression string are the same as regular Python code: the # symbol and everything after it to the end of the line are ignored. Also, the extra spaces inside the multiline string for the regular expression are not considered part of the text pattern to be matched. This lets you organize the regular expression so it\u2019s easier to read.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "Provide a guide on 'Combining re.IGNORECASE, re.DOTALL, and re.VERBOSE' in Python.", "input": "", "output": "What if you want to use re.VERBOSE to write comments in your regular expression but also want to use re.IGNORECASE to ignore capitalization? Unfortunately, the re.compile() function takes only a single value as its second argument. You can get around this limitation by combining the re.IGNORECASE , re.DOTALL , and re.VERBOSE variables using the pipe character ( | ), which in this context is known as the bitwise or operator.\n\nSo if you want a regular expression that\u2019s case-insensitive and includes newlines to match the dot character, you would form your re.compile() call like this:\n\n>>> someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL)\n\nIncluding all three options in the second argument will look like this:\n\n>>> someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL | re.VERBOSE)\n\nThis syntax is a little old-fashioned and originates from early versions of Python. The details of the bitwise operators are beyond the scope of this book, but check out the resources at https://nostarch.com/automatestuff2/ for more information. You can also pass other options for the second argument; they\u2019re uncommon, but you can read more about them in the resources, too.", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "What is 'Project: Phone Number and Email Address Extractor' and how does it work in Python?", "input": "", "output": "Say you have the boring task of finding every phone number and email address in a long web page or document. If you manually scroll through the page, you might end up searching for a long time. But if you had a program that could search the text in your clipboard for phone numbers and email addresses, you could simply press CTRL- A to select all the text, press CTRL- C to copy it to the clipboard, and then run your program. It could replace the text on the clipboard with just the phone numbers and email addresses it finds.\n\nWhenever you\u2019re tackling a new project, it can be tempting to dive right into writing code. But more often than not, it\u2019s best to take a step back and consider the bigger picture. I recommend first drawing up a high-level plan for what your program needs to do. Don\u2019t think about the actual code yet\u2014you can worry about that later. Right now, stick to broad strokes.\n\nFor example, your phone and email address extractor will need to do the following:\n\n1. Get the text off the clipboard.\n2. Find all phone numbers and email addresses in the text.\n3. Paste them onto the clipboard.\n\nNow you can start thinking about how this might work in code. The code will need to do the following:\n\n1. Use the pyperclip module to copy and paste strings.\n2. Create two regexes, one for matching phone numbers and the other for matching email addresses.\n3. Find all matches, not just the first match, of both regexes.\n4. Neatly format the matched strings into a single string to paste.\n5. Display some kind of message if no matches were found in the text.\n\nThis list is like a road map for the project. As you write the code, you can focus on each of these steps separately. Each step is fairly manageable and expressed in terms of things you already know how to do in Python.\n\nFirst, you have to create a regular expression to search for phone numbers. Create a new file, enter the following, and save it as phoneAndEmail.py :\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( (\\d{3}|\\(\\d{3}\\))?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# area code (\\s|-|\\.)?\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator (\\d{3})\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# first 3 digits (\\s|-|\\.)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# separator (\\d{4})\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# last 4 digits (\\s*(ext|x|ext.)\\s*(\\d{2,5}))?\u00a0\u00a0\u00a0\u00a0# extension )''', re.VERBOSE) # TODO: Create email regex. # TODO: Find matches in clipboard text. # TODO: Copy results to the clipboard.\n\nThe TODO comments are just a skeleton for the program. They\u2019ll be replaced as you write the actual code.\n\nThe phone number begins with an optional area code, so the area code group is followed with a question mark. Since the area code can be just three digits (that is, \\d{3} ) or three digits within parentheses (that is, \\(\\d{3}\\) ), you should have a pipe joining those parts. You can add the regex comment # Area code to this part of the multiline string to help you remember what (\\d{3}|\\(\\d{3}\\))? is supposed to match.\n\nThe phone number separator character can be a space ( \\s ), hyphen ( - ), or period ( . ), so these parts should also be joined by pipes. The next few parts of the regular expression are straightforward: three digits, followed by another separator, followed by four digits. The last part is an optional extension made up of any number of spaces followed by ext , x , or ext. , followed by two to five digits.\n\nYou will also need a regular expression that can match email addresses. Make your program look like the following:\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( -- snip -- # Create email regex. emailRegex = re.compile(r'''( \u278a [a-zA-Z0-9._%+-]+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# username \u278b @\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# @ symbol \u278c [a-zA-Z0-9.-]+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# domain name (\\.[a-zA-Z]{2,4})\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0# dot-something )''', re.VERBOSE) # TODO: Find matches in clipboard text. # TODO: Copy results to the clipboard.\n\nThe username part of the email address \u278a is one or more characters that can be any of the following: lowercase and uppercase letters, numbers, a dot, an underscore, a percent sign, a plus sign, or a hyphen. You can put all of these into a character class: [a-zA-Z0-9._%+-] .\n\nThe domain and username are separated by an @ symbol \u278b . The domain name \u278c has a slightly less permissive character class with only letters, numbers, periods, and hyphens: [a-zA-Z0-9.-] . And last will be the \u201cdot-com\u201d part (technically known as the top-level domain ), which can really be dot-anything. This is between two and four characters.\n\nThe format for email addresses has a lot of weird rules. This regular expression won\u2019t match every possible valid email address, but it\u2019ll match almost any typical email address you\u2019ll encounter.\n\nNow that you have specified the regular expressions for phone numbers and email addresses, you can let Python\u2019s re module do the hard work of finding all the matches on the clipboard. The pyperclip.paste() function will get a string value of the text on the clipboard, and the findall() regex method will return a list of tuples.\n\nMake your program look like the following:\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. import pyperclip, re phoneRegex = re.compile(r'''( -- snip -- # Find matches in clipboard text. text = str(pyperclip.paste()) \u278a matches = [] \u278b for groups in phoneRegex.findall(text): phoneNum = '-'.join([groups[1], groups[3], groups[5]]) if groups[8] != '': phoneNum += ' x' + groups[8] matches.append(phoneNum) \u278c for groups in emailRegex.findall(text): matches.append(groups[0]) # TODO: Copy results to the clipboard.\n\nThere is one tuple for each match, and each tuple contains strings for each group in the regular expression. Remember that group 0 matches the entire regular expression, so the group at index 0 of the tuple is the one you are interested in.\n\nAs you can see at \u278a , you\u2019ll store the matches in a list variable named matches . It starts off as an empty list, and a couple for loops. For the email addresses, you append group 0 of each match \u278c . For the matched phone numbers, you don\u2019t want to just append group 0 . While the program detects phone numbers in several formats, you want the phone number appended to be in a single, standard format. The phoneNum variable contains a string built from groups 1 , 3 , 5 , and 8 of the matched text \u278b . (These groups are the area code, first three digits, last four digits, and extension.)\n\nNow that you have the email addresses and phone numbers as a list of strings in matches , you want to put them on the clipboard. The pyperclip.copy() function takes only a single string value, not a list of strings, so you call the join() method on matches .\n\nTo make it easier to see that the program is working, let\u2019s print any matches you find to the terminal. If no phone numbers or email addresses were found, the program should tell the user this.\n\nMake your program look like the following:\n\n#! python3 # phoneAndEmail.py - Finds phone numbers and email addresses on the clipboard. -- snip -- for groups in emailRegex.findall(text): matches.append(groups[0]) # Copy results to the clipboard. if len(matches) > 0: pyperclip.copy('\\n'.join(matches)) print('Copied to clipboard:') print('\\n'.join(matches)) else: print('No phone numbers or email addresses found.')\n\nFor an example, open your web browser to the No Starch Press contact page at https://nostarch.com/contactus/ , press CTRL- A to select all the text on the page, and press CTRL -C to copy it to the clipboard. When you run this program, the output will look something like this:\n\nCopied to clipboard: 800-420-7240 415-863-9900 415-863-9950 info@nostarch.com media@nostarch.com academic@nostarch.com info@nostarch.com\n\nIdentifying patterns of text (and possibly substituting them with the sub() method) has many different potential applications. For example, you could:\n\n* Find website URLs that begin with http:// or https:// .\n* Clean up dates in different date formats (such as 3/14/2019, 03-14-2019, and 2015/3/19) by replacing them with dates in a single, standard format.\n* Remove sensitive information such as Social Security or credit card numbers.\n* Find common typos such as multiple spaces between words, accidentally accidentally repeated words, or multiple exclamation marks at the end of sentences. Those are annoying!!", "source": "https://automatetheboringstuff.com/2e/chapter7/", "category": "7PATTERN MATCHING WITH REGULAR EXPRESSIONS"}
{"instruction": "How do I use '8INPUT VALIDATION' in Python?", "input": "", "output": "Input validation code checks that values entered by the user, such as text from the input() function, are formatted correctly. For example, if you want users to enter their ages, your code shouldn\u2019t accept nonsensical answers such as negative numbers (which are outside the range of acceptable integers) or words (which are the wrong data type). Input validation can also prevent bugs or security vulnerabilities. If you implement a withdrawFromAccount() function that takes an argument for the amount to subtract from an account, you need to ensure the amount is a positive number. If the withdrawFromAccount() function subtracts a negative number from the account, the \u201cwithdrawal\u201d will end up adding money!\n\nTypically, we perform input validation by repeatedly asking the user for input until they enter valid text, as in the following example:\n\nwhile True: print('Enter your age:') age = input() try: age = int(age) except: print('Please use numeric digits.') continue if age < 1: print('Please enter a positive number.') continue break print(f'Your age is {age}.')\n\nWhen you run this program, the output could look like this:\n\nEnter your age: five Please use numeric digits. Enter your age: -2 Please enter a positive number. Enter your age: 30 Your age is 30.\n\nWhen you run this code, you\u2019ll be prompted for your age until you enter a valid one. This ensures that by the time the execution leaves the while loop, the age variable will contain a valid value that won\u2019t crash the program later on.\n\nHowever, writing input validation code for every input() call in your program quickly becomes tedious. Also, you may miss certain cases and allow invalid input to pass through your checks. In this chapter, you\u2019ll learn how to use the third-party PyInputPlus module for input validation.", "source": "https://automatetheboringstuff.com/2e/chapter8/", "category": "8INPUT VALIDATION"}
{"instruction": "Provide a guide on 'The PyInputPlus Module' in Python.", "input": "", "output": "PyInputPlus contains functions similar to input() for several kinds of data: numbers, dates, email addresses, and more. If the user ever enters invalid input, such as a badly formatted date or a number that is outside of an intended range, PyInputPlus will reprompt them for input just like our code in the previous section did. PyInputPlus also has other useful features like a limit for the number of times it reprompts users and a timeout if users are required to respond within a time limit.\n\nPyInputPlus is not a part of the Python Standard Library, so you must install it separately using Pip. To install PyInputPlus, run pip install --user pyinputplus from the command line. Appendix A has complete instructions for installing third-party modules. To check if PyInputPlus installed correctly, import it in the interactive shell:\n\n>>> import pyinputplus\n\nIf no errors appear when you import the module, it has been successfully installed.\n\nPyInputPlus has several functions for different kinds of input:\n\ninputStr() Is like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation function to it\n\ninputNum() Ensures the user enters a number and returns an int or float, depending on if the number has a decimal point in it\n\ninputChoice() Ensures the user enters one of the provided choices\n\ninputMenu() Is similar to inputChoice() , but provides a menu with numbered or lettered options\n\ninputDatetime() Ensures the user enters a date and time\n\ninputYesNo() Ensures the user enters a \u201cyes\u201d or \u201cno\u201d response\n\ninputBool() Is similar to inputYesNo() , but takes a \u201cTrue\u201d or \u201cFalse\u201d response and returns a Boolean value\n\ninputEmail() Ensures the user enters a valid email address\n\ninputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with that name exists\n\ninputPassword() Is like the built-in input() , but displays * characters as the user types so that passwords, or other sensitive information, aren\u2019t displayed on the screen\n\nThese functions will automatically reprompt the user for as long as they enter invalid input:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum() five 'five' is not a number. 42 >>> response 42\n\nThe as pyip code in the import statement saves us from typing pyinputplus each time we want to call a PyInputPlus function. Instead we can use the shorter pyip name. If you take a look at the example, you see that unlike input() , these functions return an int or float value: 42 and 3.14 instead of the strings '42' and '3.14' .\n\nJust as you can pass a string to input() to provide a prompt, you can pass a string to a PyInputPlus function\u2019s prompt keyword argument to display a prompt:\n\n>>> response = input('Enter a number: ') Enter a number: 42 >>> response '42' >>> import pyinputplus as pyip >>> response = pyip.inputInt(prompt='Enter a number: ') Enter a number: cat 'cat' is not an integer. Enter a number: 42 >>> response 42\n\nUse Python\u2019s help() function to find out more about each of these functions. For example, help(pyip.inputChoice) displays help information for the inputChoice() function. Complete documentation can be found at https://pyinputplus.readthedocs.io/ .\n\nUnlike Python\u2019s built-in input() , PyInputPlus functions have several additional features for input validation, as shown in the next section.\n\nThe inputNum() , inputInt() , and inputFloat() functions, which accept int and float numbers, also have min , max , greaterThan , and lessThan keyword arguments for specifying a range of valid values. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum('Enter num: ', min=4) Enter num: 3 Input must be at minimum 4. Enter num: 4 >>> response 4 >>> response = pyip.inputNum('Enter num: ', greaterThan=4) Enter num: 4 Input must be greater than 4. Enter num: 5 >>> response 5 >>> response = pyip.inputNum('>', min=4, lessThan=6) Enter num: 6 Input must be less than 6. Enter num: 3 Input must be at minimum 4. Enter num: 4 >>> response 4\n\nThese keyword arguments are optional, but if supplied, the input cannot be less than the min argument or greater than the max argument (though the input can be equal to them). Also, the input must be greater than the greaterThan and less than the lessThan arguments (that is, the input cannot be equal to them).\n\nBy default, blank input isn\u2019t allowed unless the blank keyword argument is set to True :\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum('Enter num: ') Enter num: (blank input entered here) Blank values are not allowed. Enter num: 42 >>> response 42 >>> response = pyip.inputNum(blank=True) (blank input entered here) >>> response ''\n\nUse blank=True if you\u2019d like to make input optional so that the user doesn\u2019t need to enter anything.\n\nBy default, the PyInputPlus functions will continue to ask the user for valid input forever (or for as long as the program runs). If you\u2019d like a function to stop asking the user for input after a certain number of tries or a certain amount of time, you can use the limit and timeout keyword arguments. Pass an integer for the limit keyword argument to determine how many attempts a PyInputPlus function will make to receive valid input before giving up, and pass an integer for the timeout keyword argument to determine how many seconds the user has to enter valid input before the PyInputPlus function gives up.\n\nIf the user fails to enter valid input, these keyword arguments will cause the function to raise a RetryLimitException or TimeoutException , respectively. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum(limit=2) blah 'blah' is not a number. Enter num: number 'number' is not a number. Traceback (most recent call last): --snip-- pyinputplus.RetryLimitException >>> response = pyip.inputNum(timeout=10) 42 (entered after 10 seconds of waiting) Traceback (most recent call last): --snip-- pyinputplus.TimeoutException\n\nWhen you use these keyword arguments and also pass a default keyword argument, the function returns the default value instead of raising an exception. Enter the following into the interactive shell:\n\n>>> response = pyip.inputNum(limit=2, default='N/A') hello 'hello' is not a number. world 'world' is not a number. >>> response 'N/A'\n\nInstead of raising RetryLimitException , the inputNum() function simply returns the string 'N/A' .\n\nYou can also use regular expressions to specify whether an input is allowed or not. The allowRegexes and blockRegexes keyword arguments take a list of regular expression strings to determine what the PyInputPlus function will accept or reject as valid input. For example, enter the following code into the interactive shell so that inputNum() will accept Roman numerals in addition to the usual numbers:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum(allowRegexes=[r'(I|V|X|L|C|D|M)+', r'zero']) XLII >>> response 'XLII' >>> response = pyip.inputNum(allowRegexes=[r'(i|v|x|l|c|d|m)+', r'zero']) xlii >>> response 'xlii'\n\nOf course, this regex affects only what letters the inputNum() function will accept from the user; the function will still accept Roman numerals with invalid ordering such as 'XVX' or 'MILLI' because the r'(I|V|X|L|C|D|M)+' regular expression accepts those strings.\n\nYou can also specify a list of regular expression strings that a PyInputPlus function won\u2019t accept by using the blockRegexes keyword argument. Enter the following into the interactive shell so that inputNum() won\u2019t accept even numbers:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputNum(blockRegexes=[r'[02468]$']) 42 This response is invalid. 44 This response is invalid. 43 >>> response 43\n\nIf you specify both an allowRegexes and blockRegexes argument, the allow list overrides the block list. For example, enter the following into the interactive shell, which allows 'caterpillar' and 'category' but blocks anything else that has the word 'cat' in it:\n\n>>> import pyinputplus as pyip >>> response = pyip.inputStr(allowRegexes=[r'caterpillar', 'category'], blockRegexes=[r'cat']) cat This response is invalid. catastrophe This response is invalid. category >>> response 'category'\n\nThe PyInputPlus module\u2019s functions can save you from writing tedious input validation code yourself. But there\u2019s more to the PyInputPlus module than what has been detailed here. You can examine its full documentation online at https://pyinputplus.readthedocs.io/ .\n\nYou can write a function to perform your own custom validation logic by passing the function to inputCustom() . For example, say you want the user to enter a series of digits that adds up to 10. There is no pyinputplus.inputAddsUpToTen() function, but you can create your own function that:\n\n* Accepts a single string argument of what the user entered\n* Raises an exception if the string fails validation\n* Returns None (or has no return statement) if inputCustom() should return the string unchanged\n* Returns a non- None value if inputCustom() should return a different string from the one the user entered\n* Is passed as the first argument to inputCustom()\n\nFor example, we can create our own addsUpToTen() function, and then pass it to inputCustom() . Note that the function call looks like inputCustom(addsUpToTen) and not inputCustom(addsUpToTen()) because we are passing the addsUpToTen() function itself to inputCustom() , not calling addsUpToTen() and passing its return value.\n\n>>> import pyinputplus as pyip >>> def addsUpToTen(numbers): ... numbersList = list(numbers) ... for i, digit in enumerate(numbersList): ... numbersList[i] = int(digit) ... if sum(numbersList) != 10: ... raise Exception('The digits must add up to 10, not %s.' % (sum(numbersList))) ... return int(numbers) # Return an int form of numbers. ... >>> response = pyip.inputCustom(addsUpToTen) # No parentheses after addsUpToTen here. 123 The digits must add up to 10, not 6. 1235 The digits must add up to 10, not 11. 1234 >>> response # inputStr() returned an int, not a string. 1234 >>> response = pyip.inputCustom(addsUpToTen) hello invalid literal for int() with base 10: 'h' 55 >>> response\n\nThe inputCustom() function also supports the general PyInputPlus features, such as the blank , limit , timeout , default , allowRegexes , and blockRegexes keyword arguments. Writing your own custom validation function is useful when it\u2019s otherwise difficult or impossible to write a regular expression for valid input, as in the \u201cadds up to 10\u201d example.", "source": "https://automatetheboringstuff.com/2e/chapter8/", "category": "8INPUT VALIDATION"}
{"instruction": "How do I use 'Project: How to Keep an Idiot Busy for Hours' in Python?", "input": "", "output": "Let\u2019s use PyInputPlus to create a simple program that does the following:\n\n1. Ask the user if they\u2019d like to know how to keep an idiot busy for hours.\n2. If the user answers no, quit.\n3. If the user answers yes, go to Step 1.\n\nOf course, we don\u2019t know if the user will enter something besides \u201cyes\u201d or \u201cno,\u201d so we need to perform input validation. It would also be convenient for the user to be able to enter \u201cy\u201d or \u201cn\u201d instead of the full words. PyInputPlus\u2019s inputYesNo() function will handle this for us and, no matter what case the user enters, return a lowercase 'yes' or 'no' string value.\n\nWhen you run this program, it should look like the following:\n\nWant to know how to keep an idiot busy for hours? sure 'sure' is not a valid yes/no response. Want to know how to keep an idiot busy for hours? yes Want to know how to keep an idiot busy for hours? y Want to know how to keep an idiot busy for hours? Yes Want to know how to keep an idiot busy for hours? YES Want to know how to keep an idiot busy for hours? YES!!!!!! 'YES!!!!!!' is not a valid yes/no response. Want to know how to keep an idiot busy for hours? TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS. 'TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.' is not a valid yes/no response. Want to know how to keep an idiot busy for hours? no Thank you. Have a nice day.\n\nOpen a new file editor tab and save it as idiot.py . Then enter the following code:\n\nimport pyinputplus as pyip\n\nThis imports the PyInputPlus module. Since pyinputplus is a bit much to type, we\u2019ll use the name pyip for short.\n\nwhile True: prompt = 'Want to know how to keep an idiot busy for hours?\\n' response = pyip.inputYesNo(prompt)\n\nNext, while True: creates an infinite loop that continues to run until it encounters a break statement. In this loop, we call pyip.inputYesNo() to ensure that this function call won\u2019t return until the user enters a valid answer.\n\nif response == 'no': break\n\nThe pyip.inputYesNo() call is guaranteed to only return either the string yes or the string no . If it returned no , then our program breaks out of the infinite loop and continues to the last line, which thanks the user:\n\nprint('Thank you. Have a nice day.')\n\nOtherwise, the loop iterates once again.\n\nYou can also make use of the inputYesNo() function in non-English languages by passing yesVal and noVal keyword arguments. For example, the Spanish version of this program would have these two lines:\n\nprompt = '\u00bfQuieres saber c\u00f3mo mantener ocupado a un idiota durante horas?\\n' response = pyip.inputYesNo(prompt, yesVal='s\u00ed', noVal='no') if response == 's\u00ed':\n\nNow the user can enter either s\u00ed or s (in lower- or uppercase) instead of yes or y for an affirmative answer.", "source": "https://automatetheboringstuff.com/2e/chapter8/", "category": "8INPUT VALIDATION"}
{"instruction": "What is 'Project: Multiplication Quiz' and how does it work in Python?", "input": "", "output": "PyInputPlus\u2019s features can be useful for creating a timed multiplication quiz. By setting the allowRegexes , blockRegexes , timeout , and limit keyword argument to pyip.inputStr() , you can leave most of the implementation to PyInputPlus. The less code you need to write, the faster you can write your programs. Let\u2019s create a program that poses 10 multiplication problems to the user, where the valid input is the problem\u2019s correct answer. Open a new file editor tab and save the file as multiplicationQuiz.py .\n\nFirst, we\u2019ll import pyinputplus , random , and time . We\u2019ll keep track of how many questions the program asks and how many correct answers the user gives with the variables numberOfQuestions and correctAnswers . A for loop will repeatedly pose a random multiplication problem 10 times:\n\nimport pyinputplus as pyip import random, time numberOfQuestions = 10 correctAnswers = 0 for questionNumber in range(numberOfQuestions):\n\nInside the for loop, the program will pick two single-digit numbers to multiply. We\u2019ll use these numbers to create a #Q: N \u00d7 N = prompt for the user, where Q is the question number (1 to 10) and N are the two numbers to multiply.\n\n# Pick two random numbers: num1 = random.randint(0, 9) num2 = random.randint(0, 9) prompt = '#%s: %s x %s = ' % (questionNumber, num1, num2)\n\nThe pyip.inputStr() function will handle most of the features of this quiz program. The argument we pass for allowRegexes is a list with the regex string '^%s$' , where %s is replaced with the correct answer. The ^ and % characters ensure that the answer begins and ends with the correct number, though PyInputPlus trims any whitespace from the start and end of the user\u2019s response first just in case they inadvertently pressed the spacebar before or after their answer. The argument we pass for blocklistRegexes is a list with ('.*', 'Incorrect!') . The first string in the tuple is a regex that matches every possible string. Therefore, if the user response doesn\u2019t match the correct answer, the program will reject any other answer they provide. In that case, the 'Incorrect!' string is displayed and the user is prompted to answer again. Additionally, passing 8 for timeout and 3 for limit will ensure that the user only has 8 seconds and 3 tries to provide a correct answer:\n\ntry: # Right answers are handled by allowRegexes. # Wrong answers are handled by blockRegexes, with a custom message. pyip.inputStr(prompt, allowRegexes=['^%s$' % (num1 * num2)], blockRegexes=[('.*', 'Incorrect!')], timeout=8, limit=3)\n\nIf the user answers after the 8-second timeout has expired, even if they answer correctly, pyip.inputStr() raises a TimeoutException exception. If the user answers incorrectly more than 3 times, it raises a RetryLimitException exception. Both of these exception types are in the PyInputPlus module, so pyip. needs to prepend them:\n\nexcept pyip.TimeoutException: print('Out of time!') except pyip.RetryLimitException: print('Out of tries!')\n\nRemember that, just like how else blocks can follow an if or elif block, they can optionally follow the last except block. The code inside the following else block will run if no exception was raised in the try block. In our case, that means the code runs if the user entered the correct answer:\n\nelse: # This block runs if no exceptions were raised in the try block. print('Correct!') correctAnswers += 1\n\nNo matter which of the three messages, \u201cOut of time!\u201d, \u201cOut of tries!\u201d, or \u201cCorrect!\u201d, displays, let\u2019s place a 1-second pause at the end of the for loop to give the user time to read it. After the program has asked 10 questions and the for loop continues, let\u2019s show the user how many correct answers they made:\n\ntime.sleep(1) # Brief pause to let user see the result. print('Score: %s / %s' % (correctAnswers, numberOfQuestions))\n\nPyInputPlus is flexible enough that you can use it in a wide variety of programs that take keyboard input from the user, as demonstrated by the programs in this chapter.", "source": "https://automatetheboringstuff.com/2e/chapter8/", "category": "8INPUT VALIDATION"}
{"instruction": "Explain the concept of '9READING AND WRITING FILES' from 'Automate the Boring Stuff with Python'.", "input": "", "output": "Variables are a fine way to store data while your program is running, but if you want your data to persist even after your program has finished, you need to save it to a file. You can think of a file\u2019s contents as a single string value, potentially gigabytes in size. In this chapter, you will learn how to use Python to create, read, and save files on the hard drive.", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
{"instruction": "Provide a guide on 'Files and File Paths' in Python.", "input": "", "output": "A file has two key properties: a filename (usually written as one word) and a path . The path specifies the location of a file on the computer. For example, there is a file on my Windows laptop with the filename project.docx in the path C:\\Users\\Al\\Documents . The part of the filename after the last period is called the file\u2019s extension and tells you a file\u2019s type. The filename project.docx is a Word document, and Users , Al , and Documents all refer to folders (also called directories ). Folders can contain files and other folders. For example, project.docx is in the Documents folder, which is inside the Al folder, which is inside the Users folder. Figure 9-1 shows this folder organization.\n\nFigure 9-1: A file in a hierarchy of folders\n\nThe C:\\ part of the path is the root folder , which contains all other folders. On Windows, the root folder is named C:\\ and is also called the C: drive . On macOS and Linux, the root folder is / . In this book, I\u2019ll use the Windows-style root folder, C:\\ . If you are entering the interactive shell examples on macOS or Linux, enter / instead.\n\nAdditional volumes , such as a DVD drive or USB flash drive, will appear differently on different operating systems. On Windows, they appear as new, lettered root drives, such as D:\\ or E:\\ . On macOS, they appear as new folders under the /Volumes folder. On Linux, they appear as new folders under the /mnt (\u201cmount\u201d) folder. Also note that while folder names and filenames are not case-sensitive on Windows and macOS, they are case-sensitive on Linux.\n\nOn Windows, paths are written using backslashes ( \\ ) as the separator between folder names. The macOS and Linux operating systems, however, use the forward slash ( / ) as their path separator. If you want your programs to work on all operating systems, you will have to write your Python scripts to handle both cases.\n\nFortunately, this is simple to do with the Path() function in the pathlib module. If you pass it the string values of individual file and folder names in your path, Path() will return a string with a file path using the correct path separators. Enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> Path('spam', 'bacon', 'eggs') WindowsPath('spam/bacon/eggs') >>> str(Path('spam', 'bacon', 'eggs')) 'spam\\\\bacon\\\\eggs'\n\nNote that the convention for importing pathlib is to run from pathlib import Path , since otherwise we\u2019d have to enter pathlib.Path everywhere Path shows up in our code. Not only is this extra typing redundant, but it\u2019s also redundant.\n\nI\u2019m running this chapter\u2019s interactive shell examples on Windows, so Path('spam', 'bacon', 'eggs') returned a WindowsPath object for the joined path, represented as WindowsPath('spam/bacon/eggs') . Even though Windows uses backslashes, the WindowsPath representation in the interactive shell displays them using forward slashes, since open source software developers have historically favored the Linux operating system.\n\nIf you want to get a simple text string of this path, you can pass it to the str() function, which in our example returns 'spam\\\\bacon\\\\eggs' . (Notice that the backslashes are doubled because each backslash needs to be escaped by another backslash character.) If I had called this function on, say, Linux, Path() would have returned a PosixPath object that, when passed to str() , would have returned 'spam/bacon/eggs' . ( POSIX is a set of standards for Unix-like operating systems such as Linux.)\n\nThese Path objects (really, WindowsPath or PosixPath objects, depending on your operating system) will be passed to several of the file-related functions introduced in this chapter. For example, the following code joins names from a list of filenames to the end of a folder\u2019s name:\n\n>>> from pathlib import Path >>> myFiles = ['accounts.txt', 'details.csv', 'invite.docx'] >>> for filename in myFiles: print(Path(r'C:\\Users\\Al', filename)) C:\\Users\\Al\\accounts.txt C:\\Users\\Al\\details.csv C:\\Users\\Al\\invite.docx\n\nOn Windows, the backslash separates directories, so you can\u2019t use it in filenames. However, you can use backslashes in filenames on macOS and Linux. So while Path(r'spam\\eggs') refers to two separate folders (or a file eggs in a folder spam ) on Windows, the same command would refer to a single folder (or file) named spam\\eggs on macOS and Linux. For this reason, it\u2019s usually a good idea to always use forward slashes in your Python code (and I\u2019ll be doing so for the rest of this chapter). The pathlib module will ensure that it always works on all operating systems.\n\nNote that pathlib was introduced in Python 3.4 to replace older os.path functions. The Python Standard Library modules support it as of Python 3.6, but if you are working with legacy Python 2 versions, I recommend using pathlib2 , which gives you pathlib \u2019s features on Python 2.7. Appendix A has instructions for installing pathlib2 using pip. Whenever I\u2019ve replaced an older os.path function with pathlib , I\u2019ve made a short note. You can look up the older functions at https://docs.python.org/3/library/os.path.html .\n\nWe normally use the + operator to add two integer or floating-point numbers, such as in the expression 2 + 2 , which evaluates to the integer value 4 . But we can also use the + operator to concatenate two string values, like the expression 'Hello' + 'World' , which evaluates to the string value 'HelloWorld' . Similarly, the / operator that we normally use for division can also combine Path objects and strings. This is helpful for modifying a Path object after you\u2019ve already created it with the Path() function.\n\nFor example, enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> Path('spam') / 'bacon' / 'eggs' WindowsPath('spam/bacon/eggs') >>> Path('spam') / Path('bacon/eggs') WindowsPath('spam/bacon/eggs') >>> Path('spam') / Path('bacon', 'eggs') WindowsPath('spam/bacon/eggs')\n\nUsing the / operator with Path objects makes joining paths just as easy as string concatenation. It\u2019s also safer than using string concatenation or the join() method, like we do in this example:\n\n>>> homeFolder = r'C:\\Users\\Al' >>> subFolder = 'spam' >>> homeFolder + '\\\\' + subFolder 'C:\\\\Users\\\\Al\\\\spam' >>> '\\\\'.join([homeFolder, subFolder]) 'C:\\\\Users\\\\Al\\\\spam'\n\nA script that uses this code isn\u2019t safe, because its backslashes would only work on Windows. You could add an if statement that checks sys.platform (which contains a string describing the computer\u2019s operating system) to decide what kind of slash to use, but applying this custom code everywhere it\u2019s needed can be inconsistent and bug-prone.\n\nThe pathlib module solves these problems by reusing the / math division operator to join paths correctly, no matter what operating system your code is running on. The following example uses this strategy to join the same paths as in the previous example:\n\n>>> homeFolder = Path('C:/Users/Al') >>> subFolder = Path('spam') >>> homeFolder / subFolder WindowsPath('C:/Users/Al/spam') >>> str(homeFolder / subFolder) 'C:\\\\Users\\\\Al\\\\spam'\n\nThe only thing you need to keep in mind when using the / operator for joining paths is that one of the first two values must be a Path object. Python will give you an error if you try entering the following into the interactive shell:\n\n>>> 'spam' / 'bacon' / 'eggs' Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: unsupported operand type(s) for /: 'str' and 'str'\n\nPython evaluates the / operator from left to right and evaluates to a Path object, so either the first or second leftmost value must be a Path object for the entire expression to evaluate to a Path object. Here\u2019s how the / operator and a Path object evaluate to the final Path object.\n\nIf you see the TypeError: unsupported operand type(s) for /: 'str' and 'str' error message shown previously, you need to put a Path object on the left side of the expression.\n\nThe / operator replaces the older os.path.join() function, which you can learn more about from https://docs.python.org/3/library/os.path.html#os.path.join .\n\nEvery program that runs on your computer has a current working directory , or cwd . Any filenames or paths that do not begin with the root folder are assumed to be under the current working directory.\n\nYou can get the current working directory as a string value with the Path.cwd() function and change it using os.chdir() . Enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> import os >>> Path.cwd() WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37')' >>> os.chdir('C:\\\\Windows\\\\System32') >>> Path.cwd() WindowsPath('C:/Windows/System32')\n\nHere, the current working directory is set to C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37 , so the filename project.docx refers to C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37\\project.docx . When we change the current working directory to C:\\Windows\\System32 , the filename project.docx is interpreted as C:\\Windows\\System32\\project.docx .\n\nPython will display an error if you try to change to a directory that does not exist.\n\n>>> os.chdir('C:/ThisFolderDoesNotExist') Traceback (most recent call last): File \"<stdin>\", line 1, in <module> FileNotFoundError: [WinError 2] The system cannot find the file specified: 'C:/ThisFolderDoesNotExist'\n\nThere is no pathlib function for changing the working directory, because changing the current working directory while a program is running can often lead to subtle bugs.\n\nThe os.getcwd() function is the older way of getting the current working directory as a string.\n\nAll users have a folder for their own files on the computer called the home directory or home folder . You can get a Path object of the home folder by calling Path.home() :\n\n>>> Path.home() WindowsPath('C:/Users/Al')\n\nThe home directories are located in a set place depending on your operating system:\n\n* On Windows, home directories are under C:\\Users .\n* On Mac, home directories are under /Users .\n* On Linux, home directories are often under /home .\n\nYour scripts will almost certainly have permissions to read and write the files under your home directory, so it\u2019s an ideal place to put the files that your Python programs will work with.\n\nThere are two ways to specify a file path:\n\n* An absolute path , which always begins with the root folder\n* A relative path , which is relative to the program\u2019s current working directory\n\nThere are also the dot ( . ) and dot-dot ( .. ) folders. These are not real folders but special names that can be used in a path. A single period (\u201cdot\u201d) for a folder name is shorthand for \u201cthis directory.\u201d Two periods (\u201cdot-dot\u201d) means \u201cthe parent folder.\u201d\n\nFigure 9-2 is an example of some folders and files. When the current working directory is set to C:\\bacon , the relative paths for the other folders and files are set as they are in the figure.\n\nFigure 9-2: The relative paths for folders and files in the working directory C:\\bacon\n\nThe .\\ at the start of a relative path is optional. For example, .\\spam.txt and spam.txt refer to the same file.\n\nYour programs can create new folders (directories) with the os.makedirs() function. Enter the following into the interactive shell:\n\n>>> import os >>> os.makedirs('C:\\\\delicious\\\\walnut\\\\waffles')\n\nThis will create not just the C:\\delicious folder but also a walnut folder inside C:\\delicious and a waffles folder inside C:\\delicious\\walnut . That is, os.makedirs() will create any necessary intermediate folders in order to ensure that the full path exists. Figure 9-3 shows this hierarchy of folders.\n\nFigure 9-3: The result of os.makedirs('C:\\\\delicious\\\\walnut\\\\waffles')\n\nTo make a directory from a Path object, call the mkdir() method. For example, this code will create a spam folder under the home folder on my computer:\n\n>>> from pathlib import Path >>> Path(r'C:\\Users\\Al\\spam').mkdir()\n\nNote that mkdir() can only make one directory at a time; it won\u2019t make several subdirectories at once like os.makedirs() .\n\nThe pathlib module provides methods for checking whether a given path is an absolute path and returning the absolute path of a relative path.\n\nCalling the is_absolute() method on a Path object will return True if it represents an absolute path or False if it represents a relative path. For example, enter the following into the interactive shell, using your own files and folders instead of the exact ones listed here:\n\n>>> Path.cwd() WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37') >>> Path.cwd().is_absolute() True >>> Path('spam/bacon/eggs').is_absolute() False\n\nTo get an absolute path from a relative path, you can put Path.cwd() / in front of the relative Path object. After all, when we say \u201crelative path,\u201d we almost always mean a path that is relative to the current working directory. Enter the following into the interactive shell:\n\n>>> Path('my/relative/path') WindowsPath('my/relative/path') >>> Path.cwd() / Path('my/relative/path') WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37/my/relative/ path')\n\nIf your relative path is relative to another path besides the current working directory, just replace Path.cwd() with that other path instead. The following example gets an absolute path using the home directory instead of the current working directory:\n\n>>> Path('my/relative/path') WindowsPath('my/relative/path') >>> Path.home() / Path('my/relative/path') WindowsPath('C:/Users/Al/my/relative/path')\n\nThe os.path module also has some useful functions related to absolute and relative paths:\n\n* Calling os.path.abspath( path ) will return a string of the absolute path of the argument. This is an easy way to convert a relative path into an absolute one.\n* Calling os.path.isabs( path ) will return True if the argument is an absolute path and False if it is a relative path.\n* Calling os.path.relpath( path , start ) will return a string of a relative path from the start path to path . If start is not provided, the current working directory is used as the start path.\n\nTry these functions in the interactive shell:\n\n>>> os.path.abspath('.') 'C:\\\\Users\\\\Al\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37' >>> os.path.abspath('.\\\\Scripts') 'C:\\\\Users\\\\Al\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\Scripts' >>> os.path.isabs('.') False >>> os.path.isabs(os.path.abspath('.')) True\n\nSince C:\\Users\\Al\\AppData\\Local\\Programs\\Python\\Python37 was the working directory when os.path.abspath() was called, the \u201csingle-dot\u201d folder represents the absolute path 'C:\\\\Users\\\\Al\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37' .\n\nEnter the following calls to os.path.relpath() into the interactive shell:\n\n>>> os.path.relpath('C:\\\\Windows', 'C:\\\\') 'Windows' >>> os.path.relpath('C:\\\\Windows', 'C:\\\\spam\\\\eggs') '..\\\\..\\\\Windows'\n\nWhen the relative path is within the same parent folder as the path, but is within subfolders of a different path, such as 'C:\\\\Windows' and 'C:\\\\spam\\\\eggs' , you can use the \u201cdot-dot\u201d notation to return to the parent folder.\n\nGiven a Path object, you can extract the file path\u2019s different parts as strings using several Path object attributes. These can be useful for constructing new file paths based on existing ones. The attributes are diagrammed in Figure 9-4.\n\nFigure 9-4: The parts of a Windows (top) and macOS/Linux (bottom) file path\n\nThe parts of a file path include the following:\n\n* The anchor , which is the root folder of the filesystem\n* On Windows, the drive , which is the single letter that often denotes a physical hard drive or other storage device\n* The parent , which is the folder that contains the file\n* The name of the file, made up of the stem (or base name ) and the suffix (or extension )\n\nNote that Windows Path objects have a drive attribute, but macOS and Linux Path objects don\u2019t. The drive attribute doesn\u2019t include the first backslash.\n\nTo extract each attribute from the file path, enter the following into the interactive shell:\n\n>>> p = Path('C:/Users/Al/spam.txt') >>> p.anchor 'C:\\\\' >>> p.parent # This is a Path object, not a string. WindowsPath('C:/Users/Al') >>> p.name 'spam.txt' >>> p.stem 'spam' >>> p.suffix '.txt' >>> p.drive 'C:'\n\nThese attributes evaluate to simple string values, except for parent , which evaluates to another Path object.\n\nThe parents attribute (which is different from the parent attribute) evaluates to the ancestor folders of a Path object with an integer index:\n\n>>> Path.cwd() WindowsPath('C:/Users/Al/AppData/Local/Programs/Python/Python37') >>> Path.cwd().parents[0] WindowsPath('C:/Users/Al/AppData/Local/Programs/Python') >>> Path.cwd().parents[1] WindowsPath('C:/Users/Al/AppData/Local/Programs') >>> Path.cwd().parents[2] WindowsPath('C:/Users/Al/AppData/Local') >>> Path.cwd().parents[3] WindowsPath('C:/Users/Al/AppData') >>> Path.cwd().parents[4] WindowsPath('C:/Users/Al') >>> Path.cwd().parents[5] WindowsPath('C:/Users') >>> Path.cwd().parents[6] WindowsPath('C:/')\n\nThe older os.path module also has similar functions for getting the different parts of a path written in a string value. Calling os.path.dirname( path ) will return a string of everything that comes before the last slash in the path argument. Calling os.path.basename( path ) will return a string of everything that comes after the last slash in the path argument. The directory (or dir) name and base name of a path are outlined in Figure 9-5.\n\nFigure 9-5: The base name follows the last slash in a path and is the same as the filename. The dir name is everything before the last slash.\n\nFor example, enter the following into the interactive shell:\n\n>>> calcFilePath = 'C:\\\\Windows\\\\System32\\\\calc.exe' >>> os.path.basename(calcFilePath) 'calc.exe' >>> os.path.dirname(calcFilePath) 'C:\\\\Windows\\\\System32'\n\nIf you need a path\u2019s dir name and base name together, you can just call os.path.split() to get a tuple value with these two strings, like so:\n\n>>> calcFilePath = 'C:\\\\Windows\\\\System32\\\\calc.exe' >>> os.path.split(calcFilePath) ('C:\\\\Windows\\\\System32', 'calc.exe')\n\nNotice that you could create the same tuple by calling os.path.dirname() and os.path.basename() and placing their return values in a tuple:\n\n>>> (os.path.dirname(calcFilePath), os.path.basename(calcFilePath)) ('C:\\\\Windows\\\\System32', 'calc.exe')\n\nBut os.path.split() is a nice shortcut if you need both values.\n\nAlso, note that os.path.split() does not take a file path and return a list of strings of each folder. For that, use the split() string method and split on the string in os.sep . (Note that sep is in os , not os.path .) The os.sep variable is set to the correct folder-separating slash for the computer running the program, '\\\\' on Windows and '/' on macOS and Linux, and splitting on it will return a list of the individual folders.\n\nFor example, enter the following into the interactive shell:\n\n>>> calcFilePath.split(os.sep) ['C:', 'Windows', 'System32', 'calc.exe']\n\nThis returns all the parts of the path as strings.\n\nOn macOS and Linux systems, the returned list of folders will begin with a blank string, like this:\n\n>>> '/usr/bin'.split(os. sep) ['', 'usr', 'bin']\n\nThe split() string method will work to return a list of each part of the path.\n\nOnce you have ways of handling file paths, you can then start gathering information about specific files and folders. The os.path module provides functions for finding the size of a file in bytes and the files and folders inside a given folder.\n\n* Calling os.path.getsize( path ) will return the size in bytes of the file in the path argument.\n* Calling os.listdir( path ) will return a list of filename strings for each file in the path argument. (Note that this function is in the os module, not os.path .)\n\nHere\u2019s what I get when I try these functions in the interactive shell:\n\n>>> os.path.getsize('C:\\\\Windows\\\\System32\\\\calc.exe') 27648 >>> os.listdir('C:\\\\Windows\\\\System32') ['0409', '12520437.cpx', '12520850.cpx', '5U877.ax', 'aaclient.dll', -- snip -- 'xwtpdui.dll', 'xwtpw32.dll', 'zh-CN', 'zh-HK', 'zh-TW', 'zipfldr.dll']\n\nAs you can see, the calc.exe program on my computer is 27,648 bytes in size, and I have a lot of files in C:\\Windows\\system32 . If I want to find the total size of all the files in this directory, I can use os.path.getsize() and os.listdir() together.\n\n>>> totalSize = 0 >>> for filename in os.listdir('C:\\\\Windows\\\\System32'): totalSize = totalSize + os.path.getsize(os.path.join('C:\\\\Windows\\\\System32', filename)) >>> print(totalSize) 2559970473\n\nAs I loop over each filename in the C:\\Windows\\System32 folder, the totalSize variable is incremented by the size of each file. Notice how when I call os.path.getsize() , I use os.path.join() to join the folder name with the current filename. The integer that os.path.getsize() returns is added to the value of totalSize . After looping through all the files, I print totalSize to see the total size of the C:\\Windows\\System32 folder.\n\nIf you want to work on specific files, the glob() method is simpler to use than listdir() . Path objects have a glob() method for listing the contents of a folder according to a glob pattern . Glob patterns are like a simplified form of regular expressions often used in command line commands. The glob() method returns a generator object (which are beyond the scope of this book) that you\u2019ll need to pass to list() to easily view in the interactive shell:\n\n>>> p = Path('C:/Users/Al/Desktop') >>> p.glob('*') <generator object Path.glob at 0x000002A6E389DED0> >>> list(p.glob('*')) # Make a list from the generator. [WindowsPath('C:/Users/Al/Desktop/1.png'), WindowsPath('C:/Users/Al/ Desktop/22-ap.pdf'), WindowsPath('C:/Users/Al/Desktop/cat.jpg'), --snip-- WindowsPath('C:/Users/Al/Desktop/zzz.txt')]\n\nThe asterisk ( * ) stands for \u201cmultiple of any characters,\u201d so p.glob('*') returns a generator of all files in the path stored in p .\n\nLike with regexes, you can create complex expressions:\n\n>>> list(p.glob('*.txt') # Lists all text files. [WindowsPath('C:/Users/Al/Desktop/foo.txt'), --snip-- WindowsPath('C:/Users/Al/Desktop/zzz.txt')]\n\nThe glob pattern '*.txt' will return files that start with any combination of characters as long as it ends with the string '.txt' , which is the text file extension.\n\nIn contrast with the asterisk, the question mark ( ? ) stands for any single character:\n\n>>> list(p.glob('project?.docx') [WindowsPath('C:/Users/Al/Desktop/project1.docx'), WindowsPath('C:/Users/Al/ Desktop/project2.docx'), --snip-- WindowsPath('C:/Users/Al/Desktop/project9.docx')]\n\nThe glob expression 'project?.docx' will return 'project1.docx' or 'project5.docx' , but it will not return 'project10.docx' , because ? only matches to one character\u2014so it will not match to the two-character string '10' .\n\nFinally, you can also combine the asterisk and question mark to create even more complex glob expressions, like this:\n\n>>> list(p.glob('*.?x?') [WindowsPath('C:/Users/Al/Desktop/calc.exe'), WindowsPath('C:/Users/Al/ Desktop/foo.txt'), --snip-- WindowsPath('C:/Users/Al/Desktop/zzz.txt')]\n\nThe glob expression '*.?x?' will return files with any name and any three-character extension where the middle character is an 'x' .\n\nBy picking out files with specific attributes, the glob() method lets you easily specify the files in a directory you want to perform some operation on. You can use a for loop to iterate over the generator that glob() returns:\n\n>>> p = Path('C:/Users/Al/Desktop') >>> for textFilePathObj in p.glob('*.txt'): ... print(textFilePathObj) # Prints the Path object as a string. ... # Do something with the text file. ... C:\\Users\\Al\\Desktop\\foo.txt C:\\Users\\Al\\Desktop\\spam.txt C:\\Users\\Al\\Desktop\\zzz.txt\n\nIf you want to perform some operation on every file in a directory, you can use either os.listdir(p) or p.glob('*') .\n\nMany Python functions will crash with an error if you supply them with a path that does not exist. Luckily, Path objects have methods to check whether a given path exists and whether it is a file or folder. Assuming that a variable p holds a Path object, you could expect the following:\n\n* Calling p.exists() returns True if the path exists or returns False if it doesn\u2019t exist.\n* Calling p.is_file() returns True if the path exists and is a file, or returns False otherwise.\n* Calling p.is_dir() returns True if the path exists and is a directory, or returns False otherwise.\n\nOn my computer, here\u2019s what I get when I try these methods in the interactive shell:\n\n>>> winDir = Path('C:/Windows') >>> notExistsDir = Path('C:/This/Folder/Does/Not/Exist') >>> calcFile = Path('C:/Windows /System32/calc.exe') >>> winDir.exists() True >>> winDir.is_dir() True >>> notExistsDir.exists() False >>> calcFile.is_file() True >>> calcFile.is_dir() False\n\nYou can determine whether there is a DVD or flash drive currently attached to the computer by checking for it with the exists() method. For instance, if I wanted to check for a flash drive with the volume named D:\\ on my Windows computer, I could do that with the following:\n\n>>> dDrive = Path('D:/') >>> dDrive.exists() False\n\nOops! It looks like I forgot to plug in my flash drive.\n\nThe older os.path module can accomplish the same task with the os.path.exists( path ) , os.path.isfile( path ) , and os.path.isdir( path ) functions, which act just like their Path function counterparts. As of Python 3.6, these functions can accept Path objects as well as strings of the file paths.", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
{"instruction": "Provide a guide on 'The File Reading/Writing Process' in Python.", "input": "", "output": "Once you are comfortable working with folders and relative paths, you\u2019ll be able to specify the location of files to read and write. The functions covered in the next few sections will apply to plaintext files. Plaintext files contain only basic text characters and do not include font, size, or color information. Text files with the .txt extension or Python script files with the .py extension are examples of plaintext files. These can be opened with Windows\u2019s Notepad or macOS\u2019s TextEdit application. Your programs can easily read the contents of plaintext files and treat them as an ordinary string value.\n\nBinary files are all other file types, such as word processing documents, PDFs, images, spreadsheets, and executable programs. If you open a binary file in Notepad or TextEdit, it will look like scrambled nonsense, like in Figure 9-6.\n\nFigure 9-6: The Windows calc.exe program opened in Notepad\n\nSince every different type of binary file must be handled in its own way, this book will not go into reading and writing raw binary files directly. Fortunately, many modules make working with binary files easier\u2014you will explore one of them, the shelve module, later in this chapter. The pathlib module\u2019s read_text() method returns a string of the full contents of a text file. Its write_text() method creates a new text file (or overwrites an existing one) with the string passed to it. Enter the following into the interactive shell:\n\n>>> from pathlib import Path >>> p = Path('spam.txt') >>> p.write_text('Hello, world!') 13 >>> p.read_text() 'Hello, world!'\n\nThese method calls create a spam.txt file with the content 'Hello, world!' . The 13 that write_text() returns indicates that 13 characters were written to the file. (You can often disregard this information.) The read_text() call reads and returns the contents of our new file as a string: 'Hello, world!' .\n\nKeep in mind that these Path object methods only provide basic interactions with files. The more common way of writing to a file involves using the open() function and file objects. There are three steps to reading or writing files in Python:\n\n1. Call the open() function to return a File object.\n2. Call the read() or write() method on the File object.\n3. Close the file by calling the close() method on the File object.\n\nWe\u2019ll go over these steps in the following sections.\n\nTo open a file with the open() function, you pass it a string path indicating the file you want to open; it can be either an absolute or relative path. The open() function returns a File object.\n\nTry it by creating a text file named hello.txt using Notepad or TextEdit. Type Hello, world! as the content of this text file and save it in your user home folder. Then enter the following into the interactive shell:\n\n>>> helloFile = open(Path.home() / 'hello.txt')\n\nThe open() function can also accept strings. If you\u2019re using Windows, enter the following into the interactive shell:\n\n>>> helloFile = open('C:\\\\Users\\\\ your_home_folder \\\\hello.txt')\n\nIf you\u2019re using macOS, enter the following into the interactive shell instead:\n\n>>> helloFile = open('/Users/ your_home_folder /hello.txt')\n\nMake sure to replace your_home_folder with your computer username. For example, my username is Al , so I\u2019d enter 'C:\\\\Users\\\\Al\\\\hello.txt' on Windows. Note that the open() function only accepts Path objects as of Python 3.6. In previous versions, you always need to pass a string to open() .\n\nBoth these commands will open the file in \u201creading plaintext\u201d mode, or read mode for short. When a file is opened in read mode, Python lets you only read data from the file; you can\u2019t write or modify it in any way. Read mode is the default mode for files you open in Python. But if you don\u2019t want to rely on Python\u2019s defaults, you can explicitly specify the mode by passing the string value 'r' as a second argument to open() . So open('/Users/Al/hello.txt', 'r') and open('/Users/Al/hello.txt') do the same thing.\n\nThe call to open() returns a File object. A File object represents a file on your computer; it is simply another type of value in Python, much like the lists and dictionaries you\u2019re already familiar with. In the previous example, you stored the File object in the variable helloFile . Now, whenever you want to read from or write to the file, you can do so by calling methods on the File object in helloFile .\n\nNow that you have a File object, you can start reading from it. If you want to read the entire contents of a file as a string value, use the File object\u2019s read() method. Let\u2019s continue with the hello.txt File object you stored in helloFile . Enter the following into the interactive shell:\n\n>>> helloContent = helloFile.read() >>> helloContent 'Hello, world!'\n\nIf you think of the contents of a file as a single large string value, the read() method returns the string that is stored in the file.\n\nAlternatively, you can use the readlines() method to get a list of string values from the file, one string for each line of text. For example, create a file named sonnet29.txt in the same directory as hello.txt and write the following text in it:\n\nWhen, in disgrace with fortune and men's eyes, I all alone beweep my outcast state, And trouble deaf heaven with my bootless cries, And look upon myself and curse my fate,\n\nMake sure to separate the four lines with line breaks. Then enter the following into the interactive shell:\n\n>>> sonnetFile = open(Path.home() / 'sonnet29.txt') >>> sonnetFile.readlines() [When, in disgrace with fortune and men's eyes,\\n', ' I all alone beweep my outcast state,\\n', And trouble deaf heaven with my bootless cries,\\n', And look upon myself and curse my fate,']\n\nNote that, except for the last line of the file, each of the string values ends with a newline character \\n . A list of strings is often easier to work with than a single large string value.\n\nPython allows you to write content to a file in a way similar to how the print() function \u201cwrites\u201d strings to the screen. You can\u2019t write to a file you\u2019ve opened in read mode, though. Instead, you need to open it in \u201cwrite plaintext\u201d mode or \u201cappend plaintext\u201d mode, or write mode and append mode for short.\n\nWrite mode will overwrite the existing file and start from scratch, just like when you overwrite a variable\u2019s value with a new value. Pass 'w' as the second argument to open() to open the file in write mode. Append mode, on the other hand, will append text to the end of the existing file. You can think of this as appending to a list in a variable, rather than overwriting the variable altogether. Pass 'a' as the second argument to open() to open the file in append mode.\n\nIf the filename passed to open() does not exist, both write and append mode will create a new, blank file. After reading or writing a file, call the close() method before opening the file again.\n\nLet\u2019s put these concepts together. Enter the following into the interactive shell:\n\n>>> baconFile = open('bacon.txt', 'w') >>> baconFile.write('Hello, world!\\n') 13 >>> baconFile.close() >>> baconFile = open('bacon.txt', 'a') >>> baconFile.write('Bacon is not a vegetable.') 25 >>> baconFile.close() >>> baconFile = open('bacon.txt') >>> content = baconFile.read() >>> baconFile.close() >>> print(content) Hello, world! Bacon is not a vegetable.\n\nFirst, we open bacon.txt in write mode. Since there isn\u2019t a bacon.txt yet, Python creates one. Calling write() on the opened file and passing write() the string argument 'Hello, world! /n' writes the string to the file and returns the number of characters written, including the newline. Then we close the file.\n\nTo add text to the existing contents of the file instead of replacing the string we just wrote, we open the file in append mode. We write 'Bacon is not a vegetable.' to the file and close it. Finally, to print the file contents to the screen, we open the file in its default read mode, call read() , store the resulting File object in content , close the file, and print content .\n\nNote that the write() method does not automatically add a newline character to the end of the string like the print() function does. You will have to add this character yourself.\n\nAs of Python 3.6, you can also pass a Path object to the open() function instead of a string for the filename.", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
{"instruction": "How do I use 'Saving Variables with the shelve Module' in Python?", "input": "", "output": "You can save variables in your Python programs to binary shelf files using the shelve module. This way, your program can restore data to variables from the hard drive. The shelve module will let you add Save and Open features to your program. For example, if you ran a program and entered some configuration settings, you could save those settings to a shelf file and then have the program load them the next time it is run.\n\nEnter the following into the interactive shell:\n\n>>> import shelve >>> shelfFile = shelve.open('mydata') >>> cats = ['Zophie', 'Pooka', 'Simon'] >>> shelfFile['cats'] = cats >>> shelfFile.close()\n\nTo read and write data using the shelve module, you first import shelve . Call shelve.open() and pass it a filename, and then store the returned shelf value in a variable. You can make changes to the shelf value as if it were a dictionary. When you\u2019re done, call close() on the shelf value. Here, our shelf value is stored in shelfFile . We create a list cats and write shelfFile['cats'] = cats to store the list in shelfFile as a value associated with the key 'cats' (like in a dictionary). Then we call close() on shelfFile . Note that as of Python 3.7, you have to pass the open() shelf method filenames as strings. You can\u2019t pass it Path object.\n\nAfter running the previous code on Windows, you will see three new files in the current working directory: mydata.bak , mydata.dat , and mydata.dir . On macOS, only a single mydata.db file will be created.\n\nThese binary files contain the data you stored in your shelf. The format of these binary files is not important; you only need to know what the shelve module does, not how it does it. The module frees you from worrying about how to store your program\u2019s data to a file.\n\nYour programs can use the shelve module to later reopen and retrieve the data from these shelf files. Shelf values don\u2019t have to be opened in read or write mode\u2014they can do both once opened. Enter the following into the interactive shell:\n\n>>> shelfFile = shelve.open('mydata') >>> type(shelfFile) <class 'shelve.DbfilenameShelf'> >>> shelfFile['cats'] ['Zophie', 'Pooka', 'Simon'] >>> shelfFile.close()\n\nHere, we open the shelf files to check that our data was stored correctly. Entering shelfFile['cats'] returns the same list that we stored earlier, so we know that the list is correctly stored, and we call close() .\n\nJust like dictionaries, shelf values have keys() and values() methods that will return list-like values of the keys and values in the shelf. Since these methods return list-like values instead of true lists, you should pass them to the list() function to get them in list form. Enter the following into the interactive shell:\n\n>>> shelfFile = shelve.open('mydata') >>> list(shelfFile.keys()) ['cats'] >>> list(shelfFile.values()) [['Zophie', 'Pooka', 'Simon']] >>> shelfFile.close()\n\nPlaintext is useful for creating files that you\u2019ll read in a text editor such as Notepad or TextEdit, but if you want to save data from your Python programs, use the shelve module.", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
{"instruction": "How do I use 'Saving Variables with the pprint.pformat() Function' in Python?", "input": "", "output": "Recall from \u201cPretty Printing\u201d on page 118 that the pprint.pprint() function will \u201cpretty print\u201d the contents of a list or dictionary to the screen, while the pprint.pformat() function will return this same text as a string instead of printing it. Not only is this string formatted to be easy to read, but it is also syntactically correct Python code. Say you have a dictionary stored in a variable and you want to save this variable and its contents for future use. Using pprint.pformat() will give you a string that you can write to a .py file. This file will be your very own module that you can import whenever you want to use the variable stored in it.\n\nFor example, enter the following into the interactive shell:\n\n>>> import pprint >>> cats = [{'name': 'Zophie', 'desc': 'chubby'}, {'name': 'Pooka', 'desc': 'fluffy'}] >>> pprint.pformat(cats) \"[{'desc': 'chubby', 'name': 'Zophie'}, {'desc': 'fluffy', 'name': 'Pooka'}]\" >>> fileObj = open('myCats.py', 'w') >>> fileObj.write('cats = ' + pprint.pformat(cats) + '\\n') 83 >>> fileObj.close()\n\nHere, we import pprint to let us use pprint.pformat() . We have a list of dictionaries, stored in a variable cats . To keep the list in cats available even after we close the shell, we use pprint.pformat() to return it as a string. Once we have the data in cats as a string, it\u2019s easy to write the string to a file, which we\u2019ll call myCats.py .\n\nThe modules that an import statement imports are themselves just Python scripts. When the string from pprint.pformat() is saved to a .py file, the file is a module that can be imported just like any other.\n\nAnd since Python scripts are themselves just text files with the .py file extension, your Python programs can even generate other Python programs. You can then import these files into scripts.\n\n>>> import myCats >>> myCats.cats [{'name': 'Zophie', 'desc': 'chubby'}, {'name': 'Pooka', 'desc': 'fluffy'}] >>> myCats.cats[0] {'name': 'Zophie', 'desc': 'chubby'} >>> myCats.cats[0]['name'] 'Zophie'\n\nThe benefit of creating a .py file (as opposed to saving variables with the shelve module) is that because it is a text file, the contents of the file can be read and modified by anyone with a simple text editor. For most applications, however, saving data using the shelve module is the preferred way to save variables to a file. Only basic data types such as integers, floats, strings, lists, and dictionaries can be written to a file as simple text. File objects, for example, cannot be encoded as text.", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
{"instruction": "What is 'Project: Generating Random Quiz Files' and how does it work in Python?", "input": "", "output": "Say you\u2019re a geography teacher with 35 students in your class and you want to give a pop quiz on US state capitals. Alas, your class has a few bad eggs in it, and you can\u2019t trust the students not to cheat. You\u2019d like to randomize the order of questions so that each quiz is unique, making it impossible for anyone to crib answers from anyone else. Of course, doing this by hand would be a lengthy and boring affair. Fortunately, you know some Python.\n\nHere is what the program does:\n\n1. Creates 35 different quizzes\n2. Creates 50 multiple-choice questions for each quiz, in random order\n3. Provides the correct answer and three random wrong answers for each question, in random order\n4. Writes the quizzes to 35 text files\n5. Writes the answer keys to 35 text files\n\nThis means the code will need to do the following:\n\n1. Store the states and their capitals in a dictionary\n2. Call open() , write() , and close() for the quiz and answer key text files\n3. Use random.shuffle() to randomize the order of the questions and multiple-choice options\n\nThe first step is to create a skeleton script and fill it with your quiz data. Create a file named randomQuizGenerator.py , and make it look like the following:\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. \u278a import random # The quiz data. Keys are states and values are their capitals. \u278b capitals = {'Alabama': 'Montgomery', 'Alaska': 'Juneau', 'Arizona': 'Phoenix', 'Arkansas': 'Little Rock', 'California': 'Sacramento', 'Colorado': 'Denver', 'Connecticut': 'Hartford', 'Delaware': 'Dover', 'Florida': 'Tallahassee', 'Georgia': 'Atlanta', 'Hawaii': 'Honolulu', 'Idaho': 'Boise', 'Illinois': 'Springfield', 'Indiana': 'Indianapolis', 'Iowa': 'Des Moines', 'Kansas': 'Topeka', 'Kentucky': 'Frankfort', 'Louisiana': 'Baton Rouge', 'Maine': 'Augusta', 'Maryland': 'Annapolis', 'Massachusetts': 'Boston', 'Michigan': 'Lansing', 'Minnesota': 'Saint Paul', 'Mississippi': 'Jackson', 'Missouri': 'Jefferson City', 'Montana': 'Helena', 'Nebraska': 'Lincoln', 'Nevada': 'Carson City', 'New Hampshire': 'Concord', 'New Jersey': 'Trenton', 'New Mexico': 'Santa Fe', 'New York': 'Albany', 'North Carolina': 'Raleigh', 'North Dakota': 'Bismarck', 'Ohio': 'Columbus', 'Oklahoma': 'Oklahoma City', 'Oregon': 'Salem', 'Pennsylvania': 'Harrisburg', 'Rhode Island': 'Providence', 'South Carolina': 'Columbia', 'South Dakota': 'Pierre', 'Tennessee': 'Nashville', 'Texas': 'Austin', 'Utah': 'Salt Lake City', 'Vermont': 'Montpelier', 'Virginia': 'Richmond', 'Washington': 'Olympia', 'West Virginia': 'Charleston', 'Wisconsin': 'Madison', 'Wyoming': 'Cheyenne'} # Generate 35 quiz files. \u278c for quizNum in range(35): # TODO: Create the quiz and answer key files. # TODO: Write out the header for the quiz. # TODO: Shuffle the order of the states. # TODO: Loop through all 50 states, making a question for each.\n\nSince this program will be randomly ordering the questions and answers, you\u2019ll need to import the random module \u278a to make use of its functions. The capitals variable \u278b contains a dictionary with US states as keys and their capitals as values. And since you want to create 35 quizzes, the code that actually generates the quiz and answer key files (marked with TODO comments for now) will go inside a for loop that loops 35 times \u278c . (This number can be changed to generate any number of quiz files.)\n\nNow it\u2019s time to start filling in those TODO s.\n\nThe code in the loop will be repeated 35 times\u2014once for each quiz\u2014so you have to worry about only one quiz at a time within the loop. First you\u2019ll create the actual quiz file. It needs to have a unique filename and should also have some kind of standard header in it, with places for the student to fill in a name, date, and class period. Then you\u2019ll need to get a list of states in randomized order, which can be used later to create the questions and answers for the quiz.\n\nAdd the following lines of code to randomQuizGenerator.py :\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. -- snip -- # Generate 35 quiz files. for quizNum in range(35): # Create the quiz and answer key files. \u278a quizFile = open(f'capitalsquiz{quizNum + 1}.txt', 'w') \u278b answerKeyFile = open(f'capitalsquiz_answers{quizNum + 1}.txt', 'w') # Write out the header for the quiz. \u278c quizFile.write('Name:\\n\\nDate:\\n\\nPeriod:\\n\\n') quizFile.write((' ' * 20) + f'State Capitals Quiz (Form{quizNum + 1})') quizFile.write('\\n\\n') # Shuffle the order of the states. states = list(capitals.keys()) \u278d random.shuffle(states) # TODO: Loop through all 50 states, making a question for each.\n\nThe filenames for the quizzes will be capitalsquiz<N>.txt , where <N> is a unique number for the quiz that comes from quizNum , the for loop\u2019s counter. The answer key for capitalsquiz<N>.txt will be stored in a text file named capitalsquiz_answers<N>.txt . Each time through the loop, the {quizNum + 1} placeholder in f'capitalsquiz{quizNum + 1}.txt' and f'capitalsquiz_answers{quizNum + 1}.txt' will be replaced by the unique number, so the first quiz and answer key created will be capitalsquiz1.txt and capitalsquiz_answers1.txt . These files will be created with calls to the open() function at \u278a and \u278b , with 'w' as the second argument to open them in write mode.\n\nThe write() statements at \u278c create a quiz header for the student to fill out. Finally, a randomized list of US states is created with the help of the random.shuffle() function \u278d , which randomly reorders the values in any list that is passed to it.\n\nNow you need to generate the answer options for each question, which will be multiple choice from A to D. You\u2019ll need to create another for loop\u2014this one to generate the content for each of the 50 questions on the quiz. Then there will be a third for loop nested inside to generate the multiple-choice options for each question. Make your code look like the following:\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. -- snip -- # Loop through all 50 states, making a question for each. for questionNum in range(50): # Get right and wrong answers. \u278a correctAnswer = capitals[states[questionNum]] \u278b wrongAnswers = list(capitals.values()) \u278c del wrongAnswers[wrongAnswers.index(correctAnswer)] \u278d wrongAnswers = random.sample(wrongAnswers, 3) \u278e answerOptions = wrongAnswers + [correctAnswer] \u278f random.shuffle(answerOptions) # TODO: Write the question and answer options to the quiz file. # TODO: Write the answer key to a file.\n\nThe correct answer is easy to get\u2014it\u2019s stored as a value in the capitals dictionary \u278a . This loop will loop through the states in the shuffled states list, from states[0] to states[49] , find each state in capitals , and store that state\u2019s corresponding capital in correctAnswer .\n\nThe list of possible wrong answers is trickier. You can get it by duplicating all the values in the capitals dictionary \u278b , deleting the correct answer \u278c , and selecting three random values from this list \u278d . The random.sample() function makes it easy to do this selection. Its first argument is the list you want to select from; the second argument is the number of values you want to select. The full list of answer options is the combination of these three wrong answers with the correct answers \u278e . Finally, the answers need to be randomized \u278f so that the correct response isn\u2019t always choice D.\n\nAll that is left is to write the question to the quiz file and the answer to the answer key file. Make your code look like the following:\n\n#! python3 # randomQuizGenerator.py - Creates quizzes with questions and answers in # random order, along with the answer key. -- snip -- # Loop through all 50 states, making a question for each. for questionNum in range(50): -- snip -- # Write the question and the answer options to the quiz file. quizFile.write(f'{questionNum + 1}. What is the capital of {states[questionNum]}?\\n') \u278a for i in range(4): \u278b quizFile.write(f\"\u00a0\u00a0\u00a0\u00a0{'ABCD'[i]}. { answerOptions[i]}\\n\") quizFile.write('\\n') # Write the answer key to a file. \u278c answerKeyFile.write(f\"{questionNum + 1}. {'ABCD'[answerOptions.index(correctAnswer)]}\") quizFile.close() answerKeyFile.close()\n\nA for loop that goes through integers 0 to 3 will write the answer options in the answerOptions list \u278a . The expression 'ABCD'[i] at \u278b treats the string 'ABCD' as an array and will evaluate to 'A' , 'B' , 'C' , and then 'D' on each respective iteration through the loop.\n\nIn the final line \u278c , the expression answerOptions.index(correctAnswer) will find the integer index of the correct answer in the randomly ordered answer options, and 'ABCD'[answerOptions.index(correctAnswer)] will evaluate to the correct answer\u2019s letter to be written to the answer key file.\n\nAfter you run the program, this is how your capitalsquiz1.txt file will look, though of course your questions and answer options may be different from those shown here, depending on the outcome of your random.shuffle() calls:\n\nName: Date: Period: State Capitals Quiz (Form 1) 1. What is the capital of West Virginia? A. Hartford B. Santa Fe C. Harrisburg D. Charleston 2. What is the capital of Colorado? A. Raleigh B. Harrisburg C. Denver D. Lincoln -- snip --\n\nThe corresponding capitalsquiz_answers1.txt text file will look like this:\n\n1. D 2. C 3. A 4. C -- snip --", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
{"instruction": "What is 'Project: Updatable Multi-Clipboard' and how does it work in Python?", "input": "", "output": "Let\u2019s rewrite the \u201cmulti-clipboard\u201d program from Chapter 6 so that it uses the shelve module. The user will now be able to save new strings to load to the clipboard without having to modify the source code. We\u2019ll name this new program mcb.pyw (since \u201cmcb\u201d is shorter to type than \u201cmulti-clipboard\u201d). The .pyw extension means that Python won\u2019t show a Terminal window when it runs this program. (See Appendix B for more details.)\n\nThe program will save each piece of clipboard text under a keyword. For example, when you run py mcb.pyw save spam , the current contents of the clipboard will be saved with the keyword spam . This text can later be loaded to the clipboard again by running py mcb.pyw spam . And if the user forgets what keywords they have, they can run py mcb.pyw list to copy a list of all keywords to the clipboard.\n\nHere\u2019s what the program does:\n\n1. The command line argument for the keyword is checked.\n2. If the argument is save , then the clipboard contents are saved to the keyword.\n3. If the argument is list , then all the keywords are copied to the clipboard.\n4. Otherwise, the text for the keyword is copied to the clipboard.\n\nThis means the code will need to do the following:\n\n1. Read the command line arguments from sys.argv .\n2. Read and write to the clipboard.\n3. Save and load to a shelf file.\n\nIf you use Windows, you can easily run this script from the Run... window by creating a batch file named mcb.bat with the following content:\n\n@pyw.exe C:\\Python34\\mcb.pyw %*\n\nLet\u2019s start by making a skeleton script with some comments and basic setup. Make your code look like the following:\n\n#! python3 # mcb.pyw - Saves and loads pieces of text to the clipboard. \u278a # Usage: py.exe mcb.pyw save <keyword> - Saves clipboard to keyword. #\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0py.exe mcb.pyw <keyword> - Loads keyword to clipboard. #\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0py.exe mcb.pyw list - Loads all keywords to clipboard. \u278b import shelve, pyperclip, sys \u278c mcbShelf = shelve.open('mcb') # TODO: Save clipboard content. # TODO: List keywords and load content. mcbShelf.close()\n\nIt\u2019s common practice to put general usage information in comments at the top of the file \u278a . If you ever forget how to run your script, you can always look at these comments for a reminder. Then you import your modules \u278b . Copying and pasting will require the pyperclip module, and reading the command line arguments will require the sys module. The shelve module will also come in handy: Whenever the user wants to save a new piece of clipboard text, you\u2019ll save it to a shelf file. Then, when the user wants to paste the text back to their clipboard, you\u2019ll open the shelf file and load it back into your program. The shelf file will be named with the prefix mcb \u278c .\n\nThe program does different things depending on whether the user wants to save text to a keyword, load text into the clipboard, or list all the existing keywords. Let\u2019s deal with that first case. Make your code look like the following:\n\n#! python3 # mcb.pyw - Saves and loads pieces of text to the clipboard. -- snip -- # Save clipboard content. \u278a if len(sys.argv) == 3 and sys.argv[1].lower() == 'save': \u278b mcbShelf[sys.argv[2]] = pyperclip.paste() elif len(sys.argv) == 2: \u278c # TODO: List keywords and load content. mcbShelf.close()\n\nIf the first command line argument (which will always be at index 1 of the sys.argv list) is 'save' \u278a , the second command line argument is the keyword for the current content of the clipboard. The keyword will be used as the key for mcbShelf , and the value will be the text currently on the clipboard \u278b .\n\nIf there is only one command line argument, you will assume it is either 'list' or a keyword to load content onto the clipboard. You will implement that code later. For now, just put a TODO comment there \u278c .\n\nFinally, let\u2019s implement the two remaining cases: the user wants to load clipboard text in from a keyword, or they want a list of all available keywords. Make your code look like the following:\n\n#! python3 # mcb.pyw - Saves and loads pieces of text to the clipboard. -- snip -- # Save clipboard content. if len(sys.argv) == 3 and sys.argv[1].lower() == 'save': mcbShelf[sys.argv[2]] = pyperclip.paste() elif len(sys.argv) == 2: # List keywords and load content. \u278a if sys.argv[1].lower() == 'list': \u278b pyperclip.copy(str(list(mcbShelf.keys()))) elif sys.argv[1] in mcbShelf: \u278c pyperclip.copy(mcbShelf[sys.argv[1]]) mcbShelf.close()\n\nIf there is only one command line argument, first let\u2019s check whether it\u2019s 'list' \u278a . If so, a string representation of the list of shelf keys will be copied to the clipboard \u278b . The user can paste this list into an open text editor to read it.\n\nOtherwise, you can assume the command line argument is a keyword. If this keyword exists in the mcbShelf shelf as a key, you can load the value onto the clipboard \u278c .\n\nAnd that\u2019s it! Launching this program has different steps depending on what operating system your computer uses. See Appendix B for details.\n\nRecall the password locker program you created in Chapter 6 that stored the passwords in a dictionary. Updating the passwords required changing the source code of the program. This isn\u2019t ideal, because average users don\u2019t feel comfortable changing source code to update their software. Also, every time you modify the source code to a program, you run the risk of accidentally introducing new bugs. By storing the data for a program in a different place than the code, you can make your programs easier for others to use and more resistant to bugs.", "source": "https://automatetheboringstuff.com/2e/chapter9/", "category": "9READING AND WRITING FILES"}
